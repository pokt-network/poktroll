package testkeyring

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"sync/atomic"
	"testing"

	"github.com/cosmos/cosmos-sdk/codec"
	codectypes "github.com/cosmos/cosmos-sdk/codec/types"
	"github.com/cosmos/cosmos-sdk/crypto/hd"
	"github.com/cosmos/cosmos-sdk/crypto/keyring"
	cryptotypes "github.com/cosmos/cosmos-sdk/crypto/types"
	cosmostypes "github.com/cosmos/cosmos-sdk/types"
	authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"
	"github.com/stretchr/testify/require"
)

// PreGeneratedAccount holds the address and mnemonic of an account which was
// pre-generated by the `gen_accounts` package. It is intended to be used ONLY
// in tests. It is useful for scenarios where it is necessary to know the address
// of a specific key in a separate context from that of keyring and/or module
// genesis state construction.
type PreGeneratedAccount struct {
	Address  cosmostypes.AccAddress `json:"address"`
	Mnemonic string                 `json:"mnemonic"`
}

// PreGeneratedAccountIterator is an iterator over the pre-generated accounts.
// A new iterator populated with existing pre-generated accounts can be created
// with the PreGeneratedAccounts function. Alternatively, a new iterator can be
// created with the NewPreGeneratedAccountIterator function, to which a list of
// pre-generated accounts to be iterated over must be provided.
type PreGeneratedAccountIterator struct {
	accounts  []*PreGeneratedAccount
	nextIndex uint32
}

// CreateOnChainAccount creates a new account with the given address keyring UID
// and stores it in the given keyring and account keeper. It returns the
// cosmostypes.AccAddress of the created account.
func CreateOnChainAccount(
	ctx context.Context,
	t *testing.T,
	keyringUID string,
	keyRing keyring.Keyring,
	accountKeeper AccountKeeper,
	preGeneratedAccts *PreGeneratedAccountIterator,
) cosmostypes.AccAddress {
	t.Helper()

	// Create an account.
	acct, ok := preGeneratedAccts.Next()
	require.True(t, ok)

	// Add the account to the keyring.
	err := acct.AddToKeyring(keyRing, keyringUID)
	require.NoError(t, err)

	// Add the account to the account keeper.
	err = acct.AddToAccountKeeper(ctx, accountKeeper)
	require.NoError(t, err)

	return acct.Address
}

// PreGeneratedAccountAtIndex returns the pre-generated account at the given index.
// It returns nil and false if the index is out of range.
func PreGeneratedAccountAtIndex(index uint32) (_ *PreGeneratedAccount, ok bool) {
	if preGeneratedAccounts.nextIndex >= uint32(len(preGeneratedAccounts.accounts)) {
		return nil, false
	}

	return preGeneratedAccounts.accounts[index], true
}

// MustPreGeneratedAccountAtIndex returns the pre-generated account at the given index.
// It panics on error; i.e. if the index is out of range.
func MustPreGeneratedAccountAtIndex(index uint32) *PreGeneratedAccount {
	account, ok := PreGeneratedAccountAtIndex(index)
	if !ok {
		panic("index out of range of pre-generated accounts list")
	}
	return account
}

// PreGeneratedAccounts returns a new PreGeneratedAccountIterator with the
// accounts which were pre-generated by the `gen_accounts` package (i.e. accounts_table.go).
func PreGeneratedAccounts() *PreGeneratedAccountIterator {
	return preGeneratedAccounts.Clone()
}

// NewPreGeneratedAccountIterator returns a new PreGeneratedAccountIterator with
// the given accounts. It is primarily used by the generated code to initially
// construct the preGeneratedAccounts variable.
func NewPreGeneratedAccountIterator(accounts ...*PreGeneratedAccount) *PreGeneratedAccountIterator {
	return &PreGeneratedAccountIterator{
		accounts:  accounts,
		nextIndex: 0,
	}
}

// Next returns the next account in the iterator. It is safe to call
// concurrently and is guaranteed to return a unique account on each call.
// If the iterator index goes out of range, it returns nil and false.
func (iter *PreGeneratedAccountIterator) Next() (_ *PreGeneratedAccount, ok bool) {
	// NB: instead of loading and incrementing in separate steps, just increment
	// and use nextIndex-1 for the current index.
	nextIndex := atomic.AddUint32(&iter.nextIndex, 1)
	currentIndex := nextIndex - 1

	if currentIndex > uint32(len(iter.accounts)) {
		return nil, false
	}

	return iter.accounts[currentIndex], true
}

func (iter *PreGeneratedAccountIterator) MustNext() *PreGeneratedAccount {
	account, ok := iter.Next()
	if !ok {
		panic("insufficient number of pre-generated accounts")
	}
	return account
}

// Clone returns a new PreGeneratedAccountIterator with the same accounts as the
// receiver but with its nextIndex reset to 0.
func (iter *PreGeneratedAccountIterator) Clone() *PreGeneratedAccountIterator {
	return NewPreGeneratedAccountIterator(iter.accounts...)
}

// Marshal returns the base64 and JSON encoded account string.
func (pga *PreGeneratedAccount) Marshal() (string, error) {
	accountJson, err := json.Marshal(pga)
	if err != nil {
		return "", err
	}

	accountStr := base64.StdEncoding.EncodeToString(accountJson)
	return accountStr, nil
}

// UnmarshalString parses the given base64 and JSON encoded account string into
// the PreGeneratedAccount receiver.
func (pga *PreGeneratedAccount) UnmarshalString(encodedAccountStr string) error {
	accountJson, err := base64.StdEncoding.DecodeString(encodedAccountStr)
	if err != nil {
		return err
	}
	return json.Unmarshal(accountJson, pga)
}

// AddToKeyring creates a new account in the given keyring with the given UID
// from this PreGeneratedAccount.
func (pga *PreGeneratedAccount) AddToKeyring(keyRing keyring.Keyring, uid string) error {
	_, err := keyRing.NewAccount(
		uid,
		pga.Mnemonic,
		keyring.DefaultBIP39Passphrase,
		cosmostypes.FullFundraiserPath,
		hd.Secp256k1,
	)
	return err
}

// AddToAccountKeeper creates a new account in the given account module keeper
// from this PreGeneratedAccount.
func (pga *PreGeneratedAccount) AddToAccountKeeper(
	ctx context.Context,
	keeper AccountKeeper,
) error {
	pubKey, err := mnemonicToPublicKey(pga.Mnemonic)
	if err != nil {
		return err
	}

	addr := cosmostypes.AccAddress(pubKey.Address().Bytes())

	accountNumber := keeper.NextAccountNumber(ctx)
	account := authtypes.NewBaseAccount(addr, pubKey, accountNumber, 0)
	keeper.SetAccount(ctx, account)

	return nil
}

// mustParsePreGeneratedAccount parses the given base64 and JSON encoded account
// string into a PreGeneratedAccount. It panics on error.
func mustParsePreGeneratedAccount(accountStr string) *PreGeneratedAccount {
	account := new(PreGeneratedAccount)
	if err := account.UnmarshalString(accountStr); err != nil {
		panic(err)
	}
	return account
}

// mnemonicToPublicKey uses an ephemeral keyring to derive a keypair from mnemonic
// and returns the public key portion.
func mnemonicToPublicKey(mnemonic string) (cryptotypes.PubKey, error) {
	// Construct an ephemeral keyring.
	registry := codectypes.NewInterfaceRegistry()
	cdc := codec.NewProtoCodec(registry)
	ephemeralKeyring := keyring.NewInMemory(cdc)

	// Derive a keypair from the mnemonic.
	record, err := ephemeralKeyring.NewAccount(
		"",
		mnemonic,
		keyring.DefaultBIP39Passphrase,
		cosmostypes.FullFundraiserPath,
		hd.Secp256k1,
	)
	if err != nil {
		return nil, err
	}

	return record.GetPubKey()
}
