package testkeyring

import (
	"encoding/base64"
	"encoding/json"
	"sync/atomic"

	sdktypes "github.com/cosmos/cosmos-sdk/types"
)

// PreGeneratedAccount holds the address and mnemonic of an account which was
// pre-generated by the `gen_accounts` package. It is intended to be used ONLY
// in tests. It is useful for scenarios where it is necessary to know the address
// of a specific key in a separate context from that of keyring and/or module
// genesis state construction.
type PreGeneratedAccount struct {
	Address  sdktypes.AccAddress `json:"address"`
	Mnemonic string              `json:"mnemonic"`
}

// PreGeneratedAccountIterator is an iterator over the pre-generated accounts.
// A new iterator populated with existing pre-generated accounts can be created
// with the PreGeneratedAccounts function. Alternatively, a new iterator can be
// created with the NewPreGeneratedAccountIterator function, to which a list of
// pre-generated accounts to be iterated over must be provided.
type PreGeneratedAccountIterator struct {
	accounts  []*PreGeneratedAccount
	nextIndex uint32
}

// PreGeneratedAccountAtIndex returns the pre-generated account at the given index.
// It returns nil and false if the index is out of range.
func PreGeneratedAccountAtIndex(index uint32) (_ *PreGeneratedAccount, ok bool) {
	if preGeneratedAccounts.nextIndex >= uint32(len(preGeneratedAccounts.accounts)) {
		return nil, false
	}

	return preGeneratedAccounts.accounts[index], true
}

// MustPreGeneratedAccountAtIndex returns the pre-generated account at the given index.
// It panics on error; i.e. if the index is out of range.
func MustPreGeneratedAccountAtIndex(index uint32) *PreGeneratedAccount {
	account, ok := PreGeneratedAccountAtIndex(index)
	if !ok {
		panic("index out of range of pre-generated accounts list")
	}
	return account
}

// PreGeneratedAccounts returns a new PreGeneratedAccountIterator with the
// accounts which were pre-generated by the `gen_accounts` package (i.e. accounts_table.go).
func PreGeneratedAccounts() *PreGeneratedAccountIterator {
	return preGeneratedAccounts.Clone()
}

// NewPreGeneratedAccountIterator returns a new PreGeneratedAccountIterator with
// the given accounts. It is primarily used by the generated code to initially
// construct the preGeneratedAccounts variable.
func NewPreGeneratedAccountIterator(accounts ...*PreGeneratedAccount) *PreGeneratedAccountIterator {
	return &PreGeneratedAccountIterator{
		accounts:  accounts,
		nextIndex: 0,
	}
}

// Next returns the next account in the iterator. It is safe to call
// concurrently and is guaranteed to return a unique account on each call.
// If the iterator index goes out of range, it returns nil and false.
func (iter *PreGeneratedAccountIterator) Next() (_ *PreGeneratedAccount, ok bool) {
	// NB: instead of loading and incrementing in separate steps, just increment
	// and use nextIndex-1 for the current index.
	nextIndex := atomic.AddUint32(&iter.nextIndex, 1)
	currentIndex := nextIndex - 1

	if currentIndex > uint32(len(iter.accounts)) {
		return nil, false
	}

	return iter.accounts[currentIndex], true
}

// Clone returns a new PreGeneratedAccountIterator with the same accounts as the
// receiver but with its nextIndex reset to 0.
func (iter *PreGeneratedAccountIterator) Clone() *PreGeneratedAccountIterator {
	return NewPreGeneratedAccountIterator(iter.accounts...)
}

// Marshal returns the base64 and JSON encoded account string.
func (pga *PreGeneratedAccount) Marshal() (string, error) {
	accountJson, err := json.Marshal(pga)
	if err != nil {
		return "", err
	}

	accountStr := base64.StdEncoding.EncodeToString(accountJson)
	return accountStr, nil
}

// UnmarshalString parses the given base64 and JSON encoded account string into
// the PreGeneratedAccount receiver.
func (pga *PreGeneratedAccount) UnmarshalString(encodedAccountStr string) error {
	accountJson, err := base64.StdEncoding.DecodeString(encodedAccountStr)
	if err != nil {
		return err
	}
	return json.Unmarshal(accountJson, pga)
}

// mustParsePreGeneratedAccount parses the given base64 and JSON encoded account
// string into a PreGeneratedAccount. It panics on error.
func mustParsePreGeneratedAccount(accountStr string) *PreGeneratedAccount {
	account := new(PreGeneratedAccount)
	if err := account.UnmarshalString(accountStr); err != nil {
		panic(err)
	}
	return account
}
