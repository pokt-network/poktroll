// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pocket/migration/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	github_com_cometbft_cometbft_crypto_ed25519 "github.com/cometbft/cometbft/crypto/ed25519"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	_ "github.com/pokt-network/poktroll/x/application/types"
	types "github.com/pokt-network/poktroll/x/shared/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgUpdateParams is the Msg/UpdateParams request type.
//
// - Used for updating the migration module parameters via governance
// - All parameters must be supplied
type MsgUpdateParams struct {
	// authority is the address that controls the module (defaults to x/gov unless overwritten).
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// Module parameters to update
	// NOTE: All parameters must be supplied
	Params Params `protobuf:"bytes,2,opt,name=params,proto3" json:"params"`
}

func (m *MsgUpdateParams) Reset()         { *m = MsgUpdateParams{} }
func (m *MsgUpdateParams) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParams) ProtoMessage()    {}
func (*MsgUpdateParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5cfeb615ae29ee6, []int{0}
}
func (m *MsgUpdateParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MsgUpdateParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParams.Merge(m, src)
}
func (m *MsgUpdateParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParams proto.InternalMessageInfo

func (m *MsgUpdateParams) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateParams) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

// MsgUpdateParamsResponse defines the response structure for executing a MsgUpdateParams message.
//
// - Empty response on success
type MsgUpdateParamsResponse struct {
}

func (m *MsgUpdateParamsResponse) Reset()         { *m = MsgUpdateParamsResponse{} }
func (m *MsgUpdateParamsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParamsResponse) ProtoMessage()    {}
func (*MsgUpdateParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5cfeb615ae29ee6, []int{1}
}
func (m *MsgUpdateParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MsgUpdateParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParamsResponse.Merge(m, src)
}
func (m *MsgUpdateParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParamsResponse proto.InternalMessageInfo

// MsgImportMorseClaimableAccounts is used to:
//
// - Create the on-chain MorseClaimableAccounts ONLY AND EXACTLY ONCE (per network / re-genesis)
// - Import Morse account state derived from Morse state export
type MsgImportMorseClaimableAccounts struct {
	// authority is the address that controls the module (defaults to x/gov unless overwritten).
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// Account state derived from Morse state export and `pocketd tx migration collect-morse-accounts`
	MorseAccountState MorseAccountState `protobuf:"bytes,2,opt,name=morse_account_state,json=morseAccountState,proto3" json:"morse_account_state"`
	// Validates the morse_account_state sha256 hash:
	// - Transaction fails if hash doesn't match on-chain computation
	// - Off-chain social consensus should be reached before verification
	//
	// Verification (high-level):
	//   $ pocketd tx migration collect-morse-accounts $<(pocket util export-genesis-for-reset)
	//
	// Additional docs:
	//   - pocket util export-genesis-for-migration --help
	//   - pocketd tx migration collect-morse-accounts --help
	MorseAccountStateHash []byte `protobuf:"bytes,3,opt,name=morse_account_state_hash,json=morseAccountStateHash,proto3" json:"morse_account_state_hash"`
}

func (m *MsgImportMorseClaimableAccounts) Reset()         { *m = MsgImportMorseClaimableAccounts{} }
func (m *MsgImportMorseClaimableAccounts) String() string { return proto.CompactTextString(m) }
func (*MsgImportMorseClaimableAccounts) ProtoMessage()    {}
func (*MsgImportMorseClaimableAccounts) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5cfeb615ae29ee6, []int{2}
}
func (m *MsgImportMorseClaimableAccounts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgImportMorseClaimableAccounts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MsgImportMorseClaimableAccounts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgImportMorseClaimableAccounts.Merge(m, src)
}
func (m *MsgImportMorseClaimableAccounts) XXX_Size() int {
	return m.Size()
}
func (m *MsgImportMorseClaimableAccounts) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgImportMorseClaimableAccounts.DiscardUnknown(m)
}

var xxx_messageInfo_MsgImportMorseClaimableAccounts proto.InternalMessageInfo

func (m *MsgImportMorseClaimableAccounts) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgImportMorseClaimableAccounts) GetMorseAccountState() MorseAccountState {
	if m != nil {
		return m.MorseAccountState
	}
	return MorseAccountState{}
}

func (m *MsgImportMorseClaimableAccounts) GetMorseAccountStateHash() []byte {
	if m != nil {
		return m.MorseAccountStateHash
	}
	return nil
}

// MsgImportMorseClaimableAccountsResponse is returned from MsgImportMorseClaimableAccounts.
//
// - Indicates the canonical hash of the imported MorseAccountState
// - Reports the number of claimable accounts imported
type MsgImportMorseClaimableAccountsResponse struct {
}

func (m *MsgImportMorseClaimableAccountsResponse) Reset() {
	*m = MsgImportMorseClaimableAccountsResponse{}
}
func (m *MsgImportMorseClaimableAccountsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgImportMorseClaimableAccountsResponse) ProtoMessage()    {}
func (*MsgImportMorseClaimableAccountsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5cfeb615ae29ee6, []int{3}
}
func (m *MsgImportMorseClaimableAccountsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgImportMorseClaimableAccountsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MsgImportMorseClaimableAccountsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgImportMorseClaimableAccountsResponse.Merge(m, src)
}
func (m *MsgImportMorseClaimableAccountsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgImportMorseClaimableAccountsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgImportMorseClaimableAccountsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgImportMorseClaimableAccountsResponse proto.InternalMessageInfo

// MsgClaimMorseAccount is used to:
//
// - Execute a claim (one-time minting of tokens on Shannon)
// - Claim the balance of a given Morse account per on-chain MorseClaimableAccounts
// - Mint claimed balance to the given Shannon account
//
// NOTE:
// - A transaction can contain ONE OR MORE Morse account/actor claim messages AND has EXACTLY ONE signer.
// - The Shannon account specified must be the message signer
// - Authz grants MAY be used to delegate claiming authority to other Shannon accounts
type MsgClaimMorseAccount struct {
	// The bech32-encoded address of the Shannon account which is signing for this message.
	// This account is liable for any fees incurred by violating the constraints of Morse
	// account/actor claim message fee waiving.
	ShannonSigningAddress string `protobuf:"bytes,4,opt,name=shannon_signing_address,json=shannonSigningAddress,proto3" json:"shannon_signing_address"`
	// The bech32-encoded address of the Shannon account to which the claimed balance will be minted.
	ShannonDestAddress string `protobuf:"bytes,1,opt,name=shannon_dest_address,json=shannonDestAddress,proto3" json:"shannon_dest_address"`
	// The ed25519 public key of the morse account with morse_src_address.
	MorsePublicKey github_com_cometbft_cometbft_crypto_ed25519.PubKey `protobuf:"bytes,5,opt,name=morse_public_key,json=morsePublicKey,proto3,casttype=github.com/cometbft/cometbft/crypto/ed25519.PubKey" json:"morse_public_key,omitempty"`
	// The hex-encoded signature, by the Morse account, of this message (where this field is nil).
	// I.e.: morse_signature = private_key.sign(marshal(MsgClaimMorseAccount{morse_signature: nil, ...}))
	MorseSignature []byte `protobuf:"bytes,3,opt,name=morse_signature,json=morseSignature,proto3" json:"morse_signature"`
}

func (m *MsgClaimMorseAccount) Reset()         { *m = MsgClaimMorseAccount{} }
func (m *MsgClaimMorseAccount) String() string { return proto.CompactTextString(m) }
func (*MsgClaimMorseAccount) ProtoMessage()    {}
func (*MsgClaimMorseAccount) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5cfeb615ae29ee6, []int{4}
}
func (m *MsgClaimMorseAccount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaimMorseAccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MsgClaimMorseAccount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaimMorseAccount.Merge(m, src)
}
func (m *MsgClaimMorseAccount) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaimMorseAccount) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaimMorseAccount.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaimMorseAccount proto.InternalMessageInfo

func (m *MsgClaimMorseAccount) GetShannonSigningAddress() string {
	if m != nil {
		return m.ShannonSigningAddress
	}
	return ""
}

func (m *MsgClaimMorseAccount) GetShannonDestAddress() string {
	if m != nil {
		return m.ShannonDestAddress
	}
	return ""
}

func (m *MsgClaimMorseAccount) GetMorsePublicKey() github_com_cometbft_cometbft_crypto_ed25519.PubKey {
	if m != nil {
		return m.MorsePublicKey
	}
	return nil
}

func (m *MsgClaimMorseAccount) GetMorseSignature() []byte {
	if m != nil {
		return m.MorseSignature
	}
	return nil
}

// MsgClaimMorseAccountResponse is returned from MsgClaimMorseAccount.
//
// - Indicates the morse_src_address of the claimed account
// - Reports the claimed balance and commit height
type MsgClaimMorseAccountResponse struct {
}

func (m *MsgClaimMorseAccountResponse) Reset()         { *m = MsgClaimMorseAccountResponse{} }
func (m *MsgClaimMorseAccountResponse) String() string { return proto.CompactTextString(m) }
func (*MsgClaimMorseAccountResponse) ProtoMessage()    {}
func (*MsgClaimMorseAccountResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5cfeb615ae29ee6, []int{5}
}
func (m *MsgClaimMorseAccountResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaimMorseAccountResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MsgClaimMorseAccountResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaimMorseAccountResponse.Merge(m, src)
}
func (m *MsgClaimMorseAccountResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaimMorseAccountResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaimMorseAccountResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaimMorseAccountResponse proto.InternalMessageInfo

// MsgClaimMorseApplication is used to:
//
// - Execute a claim (one-time minting of tokens on Shannon) of total tokens owned by a Morse account
// - Mint claimed tokens to the given Shannon account
// - Stake that Shannon account as an application for the given service_config and same stake amount
type MsgClaimMorseApplication struct {
	// The bech32-encoded address of the Shannon account which is signing for this message.
	// This account is liable for any fees incurred by violating the constraints of Morse
	// account/actor claim message fee waiving; the tx contains ONE OR MORE Morse account/actor
	// claim messages AND has EXACTLY ONE signer.
	ShannonSigningAddress string `protobuf:"bytes,5,opt,name=shannon_signing_address,json=shannonSigningAddress,proto3" json:"shannon_signing_address"`
	// The bech32-encoded address of the Shannon account to which the claimed tokens
	// will be minted and from which the application will be staked.
	ShannonDestAddress string `protobuf:"bytes,1,opt,name=shannon_dest_address,json=shannonDestAddress,proto3" json:"shannon_dest_address"`
	// The ed25519 public key of the morse account with morse_src_address.
	MorsePublicKey github_com_cometbft_cometbft_crypto_ed25519.PubKey `protobuf:"bytes,6,opt,name=morse_public_key,json=morsePublicKey,proto3,casttype=github.com/cometbft/cometbft/crypto/ed25519.PubKey" json:"morse_public_key,omitempty"`
	// The hex-encoded signature, by the Morse account, of this message (where this field is nil).
	// I.e.: morse_signature = private_key.sign(marshal(MsgClaimMorseAccount{morse_signature: nil, ...}))
	MorseSignature []byte `protobuf:"bytes,3,opt,name=morse_signature,json=morseSignature,proto3" json:"morse_signature"`
	// The services this application is staked to request service for.
	// NOTE: This is not a repeated field, as in MsgStakeApplication,
	// because an application can only be staked for one service.
	ServiceConfig *types.ApplicationServiceConfig `protobuf:"bytes,4,opt,name=service_config,json=serviceConfig,proto3" json:"service_config"`
}

func (m *MsgClaimMorseApplication) Reset()         { *m = MsgClaimMorseApplication{} }
func (m *MsgClaimMorseApplication) String() string { return proto.CompactTextString(m) }
func (*MsgClaimMorseApplication) ProtoMessage()    {}
func (*MsgClaimMorseApplication) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5cfeb615ae29ee6, []int{6}
}
func (m *MsgClaimMorseApplication) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaimMorseApplication) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MsgClaimMorseApplication) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaimMorseApplication.Merge(m, src)
}
func (m *MsgClaimMorseApplication) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaimMorseApplication) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaimMorseApplication.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaimMorseApplication proto.InternalMessageInfo

func (m *MsgClaimMorseApplication) GetShannonSigningAddress() string {
	if m != nil {
		return m.ShannonSigningAddress
	}
	return ""
}

func (m *MsgClaimMorseApplication) GetShannonDestAddress() string {
	if m != nil {
		return m.ShannonDestAddress
	}
	return ""
}

func (m *MsgClaimMorseApplication) GetMorsePublicKey() github_com_cometbft_cometbft_crypto_ed25519.PubKey {
	if m != nil {
		return m.MorsePublicKey
	}
	return nil
}

func (m *MsgClaimMorseApplication) GetMorseSignature() []byte {
	if m != nil {
		return m.MorseSignature
	}
	return nil
}

func (m *MsgClaimMorseApplication) GetServiceConfig() *types.ApplicationServiceConfig {
	if m != nil {
		return m.ServiceConfig
	}
	return nil
}

// MsgClaimMorseApplicationResponse is returned from MsgClaimMorseApplication.
//
// - Indicates the morse_src_address of the claimed account
// - Reports the unstaked balance claimed, application stake, and commit height
// - Returns the staked application
type MsgClaimMorseApplicationResponse struct {
}

func (m *MsgClaimMorseApplicationResponse) Reset()         { *m = MsgClaimMorseApplicationResponse{} }
func (m *MsgClaimMorseApplicationResponse) String() string { return proto.CompactTextString(m) }
func (*MsgClaimMorseApplicationResponse) ProtoMessage()    {}
func (*MsgClaimMorseApplicationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5cfeb615ae29ee6, []int{7}
}
func (m *MsgClaimMorseApplicationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaimMorseApplicationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MsgClaimMorseApplicationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaimMorseApplicationResponse.Merge(m, src)
}
func (m *MsgClaimMorseApplicationResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaimMorseApplicationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaimMorseApplicationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaimMorseApplicationResponse proto.InternalMessageInfo

// MsgClaimMorseSupplier is used to:
//
// - Execute a one-time minting of tokens on Shannon based on tokens owned by the given Morse account
// - Use the on-chain MorseClaimableAccounts for verification
// - Credit the minted tokens to the balance of the given Shannon account
// - Automatically stake that Shannon account as a supplier
//
// NOTE: The supplier module's staking fee parameter (at the time of claiming) is deducted from the claimed balance
type MsgClaimMorseSupplier struct {
	// The bech32-encoded address of the Shannon account which is signing for this message.
	// This account is liable for any fees incurred by violating the constraints of Morse
	// account/actor claim message fee waiving; the tx contains ONE OR MORE Morse account/actor
	// claim messages AND has EXACTLY ONE signer.
	ShannonSigningAddress string `protobuf:"bytes,6,opt,name=shannon_signing_address,json=shannonSigningAddress,proto3" json:"shannon_signing_address"`
	// The bech32-encoded address of the Shannon account to which the claimed tokens
	// will be minted and which become the supplier owner.
	// See: https://dev.poktroll.com/operate/configs/supplier_staking_config#staking-types.
	ShannonOwnerAddress string `protobuf:"bytes,1,opt,name=shannon_owner_address,json=shannonOwnerAddress,proto3" json:"shannon_owner_address"`
	// The bech32-encoded address of the Shannon account to which will become the supplier operator.
	// If empty, the shannon_owner_address will be used.
	// See: https://dev.poktroll.com/operate/configs/supplier_staking_config#staking-types.
	ShannonOperatorAddress string `protobuf:"bytes,2,opt,name=shannon_operator_address,json=shannonOperatorAddress,proto3" json:"shannon_operator_address"`
	// The hex-encoded address of the Morse non-custodial (i.e. operator) account.
	// - Unstaked balance will be migrated 1:1
	// - Stake will be migrated 1:1 from morse_node_address to shannon_operator_address
	// - Morse non-custodial (i.e. operator) address.
	// If morse_output_address is not set, this is the custodial address.
	// - See 'pocket nodes --help' for more information. Note that this refers to the Morse CLI.
	// E.g.: 00f9900606fa3d5c9179fc0c8513078a53a2073e
	MorseNodeAddress string `protobuf:"bytes,3,opt,name=morse_node_address,json=morseNodeAddress,proto3" json:"morse_node_address"`
	// The ed25519 public key of EITHER the Morse node/supplier operator OR owner account.
	// - MUST correspond to the private key which was used to produce the morse_signature.
	// - MUST correspond to ONE OF THE FOLLOWING:
	//   - morse_node_address
	//   - morse_output_address
	MorsePublicKey github_com_cometbft_cometbft_crypto_ed25519.PubKey `protobuf:"bytes,7,opt,name=morse_public_key,json=morsePublicKey,proto3,casttype=github.com/cometbft/cometbft/crypto/ed25519.PubKey" json:"morse_public_key"`
	// The hex-encoded signature, of this message (where this field is nil).
	// I.e.: morse_signature = private_key.sign(marshal(MsgClaimMorseSupplier{morse_signature: nil, ...}))
	// - MUST match morse_public_key.
	// - MUST be signed by ONE OF THE FOLLOWING:
	//   - Morse node account (i.e. operator); if signer_is_output_address is false
	//   - Morse output account (i.e. owner); if signer_is_output_address is true
	MorseSignature []byte `protobuf:"bytes,4,opt,name=morse_signature,json=morseSignature,proto3" json:"morse_signature"`
	// Set to true if the private key corresponding to the morse_output_address is producing the morse_signature.
	// For non-custodial claiming:
	// - This MUST be true.
	// - The morse_public_key MUST correspond to morse_output_address.
	// - The morse_signature MUST correspond to morse_output_address.
	SignerIsOutputAddress bool `protobuf:"varint,8,opt,name=signer_is_output_address,json=signerIsOutputAddress,proto3" json:"signer_is_output_address"`
	// The services this supplier is staked to provide service for.
	Services []*types.SupplierServiceConfig `protobuf:"bytes,5,rep,name=services,proto3" json:"services"`
}

func (m *MsgClaimMorseSupplier) Reset()         { *m = MsgClaimMorseSupplier{} }
func (m *MsgClaimMorseSupplier) String() string { return proto.CompactTextString(m) }
func (*MsgClaimMorseSupplier) ProtoMessage()    {}
func (*MsgClaimMorseSupplier) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5cfeb615ae29ee6, []int{8}
}
func (m *MsgClaimMorseSupplier) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaimMorseSupplier) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MsgClaimMorseSupplier) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaimMorseSupplier.Merge(m, src)
}
func (m *MsgClaimMorseSupplier) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaimMorseSupplier) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaimMorseSupplier.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaimMorseSupplier proto.InternalMessageInfo

func (m *MsgClaimMorseSupplier) GetShannonSigningAddress() string {
	if m != nil {
		return m.ShannonSigningAddress
	}
	return ""
}

func (m *MsgClaimMorseSupplier) GetShannonOwnerAddress() string {
	if m != nil {
		return m.ShannonOwnerAddress
	}
	return ""
}

func (m *MsgClaimMorseSupplier) GetShannonOperatorAddress() string {
	if m != nil {
		return m.ShannonOperatorAddress
	}
	return ""
}

func (m *MsgClaimMorseSupplier) GetMorseNodeAddress() string {
	if m != nil {
		return m.MorseNodeAddress
	}
	return ""
}

func (m *MsgClaimMorseSupplier) GetMorsePublicKey() github_com_cometbft_cometbft_crypto_ed25519.PubKey {
	if m != nil {
		return m.MorsePublicKey
	}
	return nil
}

func (m *MsgClaimMorseSupplier) GetMorseSignature() []byte {
	if m != nil {
		return m.MorseSignature
	}
	return nil
}

func (m *MsgClaimMorseSupplier) GetSignerIsOutputAddress() bool {
	if m != nil {
		return m.SignerIsOutputAddress
	}
	return false
}

func (m *MsgClaimMorseSupplier) GetServices() []*types.SupplierServiceConfig {
	if m != nil {
		return m.Services
	}
	return nil
}

// MsgClaimMorseSupplierResponse is returned from MsgClaimMorseSupplier.
//
// - Indicates the morse_operator_address of the claimed account
// - Reports the unstaked balance claimed, session end height, and staked supplier
// - Includes claim signer type and signer address
type MsgClaimMorseSupplierResponse struct {
}

func (m *MsgClaimMorseSupplierResponse) Reset()         { *m = MsgClaimMorseSupplierResponse{} }
func (m *MsgClaimMorseSupplierResponse) String() string { return proto.CompactTextString(m) }
func (*MsgClaimMorseSupplierResponse) ProtoMessage()    {}
func (*MsgClaimMorseSupplierResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5cfeb615ae29ee6, []int{9}
}
func (m *MsgClaimMorseSupplierResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaimMorseSupplierResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MsgClaimMorseSupplierResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaimMorseSupplierResponse.Merge(m, src)
}
func (m *MsgClaimMorseSupplierResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaimMorseSupplierResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaimMorseSupplierResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaimMorseSupplierResponse proto.InternalMessageInfo

// MsgRecoverMorseAccount is used to:
//
// - Execute a one-time minting of tokens on Shannon based on tokens owned by the given Morse account
// - Credit the minted tokens to the balance of the given Shannon account
// - Migrate unclaimable staked and liquid Morse tokens as liquid Shannon tokens
//
// - MAY ONLY be executed by the authority
// - ONLY intended for use on accounts with invalid addresses and/or known lost private keys
type MsgRecoverMorseAccount struct {
	// The bech32-encoded address of the migration module authority account ("gov" module address by default).
	// ONLY the authority, or its delegates, MAY recover Morse recoverable accounts.
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority"`
	// The bech32-encoded address of the Shannon account to which the Morse account's stake(s) and/or
	// balance(s) will be minted (recovered) as liquid Shannon tokens.
	ShannonDestAddress string `protobuf:"bytes,2,opt,name=shannon_dest_address,json=shannonDestAddress,proto3" json:"shannon_dest_address"`
	// EITHER:
	//   - The hex-encoded address of the recoverable Morse account whose stake(s) and/or balance(s) will be recovered.
	//     This address MAY be invalid but NEVER empty.
	//     E.g.: 00f9900606fa3d5c9179fc0c8513078a53a2073e
	//   - The name of a Morse module account whose balance will be recovered.
	//     E.g. "dao" or "fee-collector"
	MorseSrcAddress string `protobuf:"bytes,3,opt,name=morse_src_address,json=morseSrcAddress,proto3" json:"morse_src_address"`
}

func (m *MsgRecoverMorseAccount) Reset()         { *m = MsgRecoverMorseAccount{} }
func (m *MsgRecoverMorseAccount) String() string { return proto.CompactTextString(m) }
func (*MsgRecoverMorseAccount) ProtoMessage()    {}
func (*MsgRecoverMorseAccount) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5cfeb615ae29ee6, []int{10}
}
func (m *MsgRecoverMorseAccount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRecoverMorseAccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MsgRecoverMorseAccount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRecoverMorseAccount.Merge(m, src)
}
func (m *MsgRecoverMorseAccount) XXX_Size() int {
	return m.Size()
}
func (m *MsgRecoverMorseAccount) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRecoverMorseAccount.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRecoverMorseAccount proto.InternalMessageInfo

func (m *MsgRecoverMorseAccount) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgRecoverMorseAccount) GetShannonDestAddress() string {
	if m != nil {
		return m.ShannonDestAddress
	}
	return ""
}

func (m *MsgRecoverMorseAccount) GetMorseSrcAddress() string {
	if m != nil {
		return m.MorseSrcAddress
	}
	return ""
}

// MsgRecoverMorseAccountResponse is returned from MsgRecoverMorseAccount.
//
// - Indicates the morse_src_address of the recovered account
// - Reports the sum of any actor stakes and unstaked balance recovered
// - Reports the session end height in which the recovery was committed
// - Returns the destination Shannon address
type MsgRecoverMorseAccountResponse struct {
}

func (m *MsgRecoverMorseAccountResponse) Reset()         { *m = MsgRecoverMorseAccountResponse{} }
func (m *MsgRecoverMorseAccountResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRecoverMorseAccountResponse) ProtoMessage()    {}
func (*MsgRecoverMorseAccountResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e5cfeb615ae29ee6, []int{11}
}
func (m *MsgRecoverMorseAccountResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRecoverMorseAccountResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MsgRecoverMorseAccountResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRecoverMorseAccountResponse.Merge(m, src)
}
func (m *MsgRecoverMorseAccountResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRecoverMorseAccountResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRecoverMorseAccountResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRecoverMorseAccountResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgUpdateParams)(nil), "pocket.migration.MsgUpdateParams")
	proto.RegisterType((*MsgUpdateParamsResponse)(nil), "pocket.migration.MsgUpdateParamsResponse")
	proto.RegisterType((*MsgImportMorseClaimableAccounts)(nil), "pocket.migration.MsgImportMorseClaimableAccounts")
	proto.RegisterType((*MsgImportMorseClaimableAccountsResponse)(nil), "pocket.migration.MsgImportMorseClaimableAccountsResponse")
	proto.RegisterType((*MsgClaimMorseAccount)(nil), "pocket.migration.MsgClaimMorseAccount")
	proto.RegisterType((*MsgClaimMorseAccountResponse)(nil), "pocket.migration.MsgClaimMorseAccountResponse")
	proto.RegisterType((*MsgClaimMorseApplication)(nil), "pocket.migration.MsgClaimMorseApplication")
	proto.RegisterType((*MsgClaimMorseApplicationResponse)(nil), "pocket.migration.MsgClaimMorseApplicationResponse")
	proto.RegisterType((*MsgClaimMorseSupplier)(nil), "pocket.migration.MsgClaimMorseSupplier")
	proto.RegisterType((*MsgClaimMorseSupplierResponse)(nil), "pocket.migration.MsgClaimMorseSupplierResponse")
	proto.RegisterType((*MsgRecoverMorseAccount)(nil), "pocket.migration.MsgRecoverMorseAccount")
	proto.RegisterType((*MsgRecoverMorseAccountResponse)(nil), "pocket.migration.MsgRecoverMorseAccountResponse")
}

func init() { proto.RegisterFile("pocket/migration/tx.proto", fileDescriptor_e5cfeb615ae29ee6) }

var fileDescriptor_e5cfeb615ae29ee6 = []byte{
	// 1196 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x57, 0x4f, 0x6f, 0xe3, 0xc4,
	0x1b, 0xae, 0x13, 0x27, 0xeb, 0x4e, 0xfb, 0xeb, 0xa6, 0x6e, 0xd3, 0xa6, 0xd9, 0x6e, 0xdc, 0x5f,
	0x58, 0x68, 0xa8, 0xb4, 0x71, 0x93, 0xa5, 0x2b, 0xb6, 0x70, 0xa0, 0xe9, 0x1e, 0xd8, 0xac, 0xb2,
	0xad, 0x1c, 0xf5, 0x82, 0x90, 0x82, 0xe3, 0xcc, 0x3a, 0x56, 0x62, 0x8f, 0xf1, 0x4c, 0xda, 0xcd,
	0x0d, 0x71, 0x44, 0x1c, 0x90, 0xe0, 0xc4, 0x27, 0x40, 0xe2, 0x52, 0x21, 0xae, 0x5c, 0x38, 0xed,
	0x71, 0xc5, 0x69, 0x4f, 0x16, 0x6a, 0x0f, 0x95, 0xfc, 0x11, 0x38, 0x21, 0xdb, 0xe3, 0xfc, 0xb5,
	0xdb, 0x80, 0x16, 0x09, 0x71, 0x49, 0xec, 0x79, 0x9f, 0x79, 0x9e, 0x99, 0xf7, 0xcf, 0xcc, 0x6b,
	0xb0, 0x61, 0x22, 0xa5, 0x03, 0x89, 0xa8, 0x6b, 0xaa, 0x25, 0x13, 0x0d, 0x19, 0x22, 0x79, 0x51,
	0x34, 0x2d, 0x44, 0x10, 0x9f, 0xf2, 0x4d, 0xc5, 0x81, 0x29, 0xbb, 0x2c, 0xeb, 0x9a, 0x81, 0x44,
	0xef, 0xd7, 0x07, 0x65, 0xd7, 0x15, 0x84, 0x75, 0x84, 0x45, 0x1d, 0xab, 0xe2, 0x69, 0xc9, 0xfd,
	0xa3, 0x86, 0x0d, 0xdf, 0xd0, 0xf0, 0xde, 0x44, 0xff, 0x85, 0x9a, 0x56, 0x55, 0xa4, 0x22, 0x7f,
	0xdc, 0x7d, 0xa2, 0xa3, 0x77, 0xe8, 0x4a, 0x70, 0x5b, 0xb6, 0x60, 0x4b, 0xc4, 0xd0, 0x3a, 0xd5,
	0x14, 0x48, 0x8d, 0xf7, 0xa6, 0x96, 0xa9, 0x23, 0x0b, 0xc3, 0x06, 0x32, 0x94, 0xb6, 0xac, 0x19,
	0x14, 0x75, 0x77, 0x0a, 0x65, 0xca, 0x96, 0xac, 0x07, 0xba, 0x39, 0x6a, 0x96, 0x4d, 0xb3, 0xab,
	0x29, 0x74, 0xb7, 0x7d, 0x13, 0x06, 0xf6, 0xcd, 0x89, 0x15, 0xf4, 0x5c, 0x1c, 0xb4, 0x82, 0xd9,
	0x74, 0xa7, 0x4d, 0x19, 0x43, 0xf1, 0xb4, 0xd4, 0x84, 0x44, 0x2e, 0x89, 0x0a, 0x0a, 0xc4, 0xf3,
	0xbf, 0x30, 0xe0, 0x76, 0x0d, 0xab, 0x27, 0x66, 0x4b, 0x26, 0xf0, 0xd8, 0xd3, 0xe5, 0x1f, 0x82,
	0x79, 0xb9, 0x47, 0xda, 0xc8, 0xd2, 0x48, 0x3f, 0xc3, 0x6c, 0x31, 0x85, 0xf9, 0x4a, 0xe6, 0xb7,
	0x9f, 0xef, 0xaf, 0x52, 0x77, 0x1c, 0xb4, 0x5a, 0x16, 0xc4, 0xb8, 0x4e, 0x2c, 0xcd, 0x50, 0xa5,
	0x21, 0x94, 0xff, 0x00, 0x24, 0xfd, 0x95, 0x67, 0x62, 0x5b, 0x4c, 0x61, 0xa1, 0x9c, 0x29, 0x4e,
	0xc6, 0xa2, 0xe8, 0x2b, 0x54, 0xe6, 0x5f, 0xda, 0xc2, 0xdc, 0x0f, 0x57, 0xe7, 0x3b, 0x8c, 0x44,
	0xa7, 0xec, 0xef, 0x7d, 0x79, 0x75, 0xbe, 0x33, 0x24, 0xfb, 0xea, 0xea, 0x7c, 0x27, 0x4f, 0x77,
	0xf6, 0x62, 0xc4, 0x35, 0x13, 0x6b, 0xcd, 0x6f, 0x80, 0xf5, 0x89, 0x21, 0x09, 0x62, 0x13, 0x19,
	0x18, 0xe6, 0x7f, 0x8a, 0x01, 0xa1, 0x86, 0xd5, 0x27, 0xba, 0x89, 0x2c, 0x52, 0x73, 0x1d, 0x7f,
	0xd8, 0x95, 0x35, 0x5d, 0x6e, 0x76, 0xe1, 0x81, 0xa2, 0xa0, 0x9e, 0x41, 0xfe, 0xfe, 0x56, 0x4d,
	0xb0, 0xe2, 0x87, 0x52, 0xf6, 0x99, 0x1a, 0x98, 0xc8, 0x04, 0xd2, 0x7d, 0xbf, 0x35, 0xbd, 0x6f,
	0x4f, 0x9e, 0xaa, 0xd6, 0x5d, 0x68, 0xe5, 0x8e, 0xeb, 0x02, 0xc7, 0x16, 0xc2, 0x78, 0xa4, 0x65,
	0x7d, 0x12, 0xcf, 0x9f, 0x80, 0x4c, 0x08, 0xb2, 0xd1, 0x96, 0x71, 0x3b, 0x13, 0xdf, 0x62, 0x0a,
	0x8b, 0x95, 0x4d, 0xc7, 0x16, 0x22, 0x31, 0x52, 0x7a, 0x8a, 0xf2, 0x63, 0x19, 0xb7, 0xf7, 0x97,
	0xc6, 0xdd, 0x9e, 0xdf, 0x03, 0xdb, 0x37, 0xf8, 0x2c, 0xf0, 0x6f, 0x95, 0xe5, 0x98, 0x54, 0xac,
	0xca, 0x72, 0xb1, 0x54, 0x3c, 0xff, 0x63, 0x1c, 0xac, 0xd6, 0xb0, 0xea, 0x81, 0x47, 0xf7, 0xca,
	0x77, 0xc0, 0x3a, 0x6e, 0xcb, 0x86, 0x81, 0x8c, 0x06, 0xd6, 0x54, 0x43, 0x33, 0xd4, 0x86, 0xec,
	0x3b, 0x35, 0xc3, 0x7a, 0xee, 0x7e, 0xe0, 0xd8, 0x42, 0x14, 0x24, 0x32, 0x12, 0x69, 0x3a, 0xa1,
	0xee, 0xe3, 0xa9, 0x91, 0x6f, 0x82, 0xd5, 0x80, 0xa9, 0x05, 0x31, 0x19, 0x28, 0xf9, 0x81, 0xdd,
	0x75, 0x6c, 0x21, 0xd4, 0x1e, 0x29, 0xc3, 0x53, 0xf4, 0x63, 0x88, 0x49, 0xa0, 0xf1, 0x19, 0x48,
	0xf9, 0x3e, 0x36, 0x7b, 0xcd, 0xae, 0xa6, 0x34, 0x3a, 0xb0, 0x9f, 0x49, 0x78, 0xfe, 0x7f, 0xf8,
	0x87, 0x2d, 0x94, 0x55, 0x8d, 0xb4, 0x7b, 0xcd, 0xa2, 0x82, 0x74, 0x51, 0x41, 0x3a, 0x24, 0xcd,
	0xe7, 0x64, 0xe4, 0xc1, 0xea, 0x9b, 0x04, 0x89, 0xb0, 0x55, 0xde, 0xdb, 0x2b, 0x3d, 0x2a, 0x1e,
	0xf7, 0x9a, 0x4f, 0x61, 0x5f, 0x5a, 0xf2, 0xf8, 0x8e, 0x3d, 0xba, 0xa7, 0xb0, 0xcf, 0x7f, 0x08,
	0x6e, 0xfb, 0x0a, 0xae, 0x37, 0x64, 0xd2, 0xb3, 0x20, 0x0d, 0xf0, 0x8a, 0x63, 0x0b, 0x93, 0x26,
	0x3a, 0xbb, 0x1e, 0xbc, 0xef, 0x6f, 0xba, 0x01, 0x8d, 0x72, 0x28, 0x8d, 0xd6, 0x2e, 0xd8, 0x0c,
	0x0b, 0x56, 0x58, 0x64, 0xab, 0x2c, 0x17, 0x4f, 0xb1, 0xf9, 0x6f, 0x59, 0x90, 0x19, 0x9f, 0x32,
	0x3c, 0x8d, 0xae, 0x8b, 0x71, 0xe2, 0x3f, 0x13, 0xe3, 0xe4, 0xbf, 0x27, 0xc6, 0x7c, 0x13, 0x2c,
	0xd1, 0x8b, 0xa6, 0xa1, 0x20, 0xe3, 0xb9, 0xa6, 0x7a, 0xb5, 0xb4, 0x50, 0xde, 0x0e, 0x0e, 0x1e,
	0xff, 0x2e, 0x28, 0x8e, 0x04, 0xa9, 0xee, 0xe3, 0x0f, 0x3d, 0x78, 0x85, 0x77, 0x6c, 0x61, 0x82,
	0x42, 0xfa, 0x1f, 0x1e, 0x85, 0xcc, 0x94, 0x47, 0x1f, 0x81, 0xad, 0xa8, 0xa4, 0x88, 0xce, 0xa5,
	0x2a, 0xcb, 0xb1, 0xa9, 0x44, 0x95, 0xe5, 0x12, 0xa9, 0x64, 0xfe, 0xfb, 0x24, 0x48, 0x8f, 0x51,
	0xd4, 0xe9, 0xf5, 0x75, 0x5d, 0x52, 0x25, 0xdf, 0x78, 0x52, 0x41, 0x10, 0x18, 0x1a, 0xe8, 0xcc,
	0x80, 0xd6, 0x44, 0x56, 0x95, 0x1c, 0x5b, 0x08, 0x07, 0x44, 0x0a, 0xad, 0x50, 0xf8, 0x91, 0x8b,
	0x0e, 0x64, 0x0c, 0x90, 0x19, 0xb0, 0x98, 0xd0, 0x92, 0x09, 0x1a, 0x2a, 0xc5, 0x3c, 0xa5, 0xf7,
	0xdc, 0x33, 0x3c, 0x0a, 0x13, 0x29, 0xb6, 0x16, 0x88, 0xd1, 0x09, 0x81, 0xde, 0x63, 0xc0, 0xfb,
	0xa9, 0x64, 0xa0, 0x16, 0x1c, 0x28, 0xc5, 0x3d, 0xa5, 0x35, 0xc7, 0x16, 0x42, 0xac, 0x92, 0x9f,
	0xf9, 0xcf, 0x50, 0x0b, 0x06, 0x2c, 0x24, 0xa4, 0x1a, 0x6e, 0x79, 0xc9, 0x5a, 0x75, 0x6c, 0x61,
	0xca, 0xf6, 0xcf, 0x55, 0x08, 0x3b, 0x7b, 0x85, 0x9c, 0x80, 0x8c, 0x6b, 0x84, 0x56, 0x43, 0xc3,
	0x0d, 0xd4, 0x23, 0x66, 0x6f, 0x78, 0x52, 0x70, 0x5b, 0x4c, 0x81, 0xf3, 0x6f, 0xcb, 0x28, 0x8c,
	0x94, 0xf6, 0x2d, 0x4f, 0xf0, 0x91, 0x37, 0x1e, 0xb8, 0xe2, 0x19, 0xe0, 0x68, 0x95, 0xb8, 0x47,
	0x5b, 0xbc, 0xb0, 0x50, 0xbe, 0x37, 0x51, 0x72, 0x41, 0xfe, 0x8e, 0xd7, 0xdb, 0xa2, 0x63, 0x0b,
	0x83, 0x99, 0xd2, 0xe0, 0xe9, 0xfa, 0x22, 0xcb, 0x1f, 0x81, 0xbb, 0xa1, 0xb5, 0x31, 0x5b, 0x6d,
	0x55, 0x59, 0xee, 0x56, 0x8a, 0xab, 0xb2, 0x1c, 0x97, 0x9a, 0xaf, 0xb2, 0xdc, 0x7c, 0x0a, 0xe4,
	0xbf, 0x8b, 0x81, 0xb5, 0x1a, 0x56, 0x25, 0xa8, 0xa0, 0x53, 0x68, 0x8d, 0xdd, 0xd3, 0x87, 0xd3,
	0x8d, 0xd0, 0xdb, 0x8e, 0x2d, 0x0c, 0x07, 0x67, 0xe9, 0x8a, 0xa2, 0xce, 0xe6, 0xd8, 0x1b, 0x3c,
	0x9b, 0x0f, 0xc0, 0x32, 0x0d, 0xbe, 0xa5, 0x4c, 0xa4, 0x74, 0xda, 0xb1, 0x85, 0x69, 0xa3, 0xe4,
	0x27, 0x4b, 0xdd, 0x52, 0x28, 0xc5, 0x54, 0xcf, 0xf3, 0x3e, 0xc8, 0x85, 0x7b, 0xe5, 0x26, 0x47,
	0x97, 0x7f, 0x4d, 0x80, 0x78, 0x0d, 0xab, 0xfc, 0xa7, 0x60, 0x71, 0xac, 0x83, 0xfe, 0x7f, 0x48,
	0x07, 0x38, 0xde, 0xa5, 0x66, 0xdf, 0xbd, 0x11, 0x12, 0xa8, 0xf3, 0x5f, 0x33, 0x60, 0xf3, 0xda,
	0x2e, 0xb6, 0x14, 0xca, 0x75, 0xdd, 0x94, 0xec, 0xa3, 0xbf, 0x3c, 0x65, 0xb0, 0x9c, 0x0e, 0x58,
	0x9e, 0xee, 0xf3, 0xde, 0x09, 0xe5, 0x9b, 0xc2, 0x65, 0x8b, 0xb3, 0xe1, 0x06, 0x62, 0x67, 0x20,
	0x1d, 0xde, 0x74, 0xec, 0xdc, 0x44, 0x34, 0xc4, 0x66, 0xcb, 0xb3, 0x63, 0x07, 0xc2, 0x06, 0xe0,
	0x43, 0x6e, 0xa5, 0xed, 0x1b, 0x98, 0x02, 0x60, 0x56, 0x9c, 0x11, 0x38, 0xd0, 0xfb, 0x1c, 0xac,
	0x84, 0xd5, 0x65, 0x21, 0x94, 0x27, 0x04, 0x99, 0xdd, 0x9d, 0x15, 0x19, 0x48, 0x66, 0x13, 0x5f,
	0xb8, 0x5f, 0x60, 0x95, 0xe3, 0x97, 0x17, 0x39, 0xe6, 0xd5, 0x45, 0x8e, 0x79, 0x7d, 0x91, 0x63,
	0x7e, 0xbf, 0xc8, 0x31, 0xdf, 0x5c, 0xe6, 0xe6, 0x5e, 0x5d, 0xe6, 0xe6, 0x5e, 0x5f, 0xe6, 0xe6,
	0x3e, 0x19, 0x3d, 0xcb, 0x4d, 0xd4, 0x21, 0xf7, 0x0d, 0x48, 0xce, 0x90, 0xd5, 0xf1, 0x5e, 0x2c,
	0xd4, 0xed, 0x8e, 0x7d, 0x9e, 0x79, 0x1f, 0xa6, 0xcd, 0xa4, 0xf7, 0x6d, 0xf9, 0xe0, 0xcf, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x90, 0xac, 0x11, 0xc6, 0xa7, 0x0f, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// UpdateParams defines a (governance) operation for updating the module
	// parameters. The authority defaults to the x/gov module account.
	UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	ImportMorseClaimableAccounts(ctx context.Context, in *MsgImportMorseClaimableAccounts, opts ...grpc.CallOption) (*MsgImportMorseClaimableAccountsResponse, error)
	ClaimMorseAccount(ctx context.Context, in *MsgClaimMorseAccount, opts ...grpc.CallOption) (*MsgClaimMorseAccountResponse, error)
	ClaimMorseApplication(ctx context.Context, in *MsgClaimMorseApplication, opts ...grpc.CallOption) (*MsgClaimMorseApplicationResponse, error)
	ClaimMorseSupplier(ctx context.Context, in *MsgClaimMorseSupplier, opts ...grpc.CallOption) (*MsgClaimMorseSupplierResponse, error)
	RecoverMorseAccount(ctx context.Context, in *MsgRecoverMorseAccount, opts ...grpc.CallOption) (*MsgRecoverMorseAccountResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/pocket.migration.Msg/UpdateParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ImportMorseClaimableAccounts(ctx context.Context, in *MsgImportMorseClaimableAccounts, opts ...grpc.CallOption) (*MsgImportMorseClaimableAccountsResponse, error) {
	out := new(MsgImportMorseClaimableAccountsResponse)
	err := c.cc.Invoke(ctx, "/pocket.migration.Msg/ImportMorseClaimableAccounts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ClaimMorseAccount(ctx context.Context, in *MsgClaimMorseAccount, opts ...grpc.CallOption) (*MsgClaimMorseAccountResponse, error) {
	out := new(MsgClaimMorseAccountResponse)
	err := c.cc.Invoke(ctx, "/pocket.migration.Msg/ClaimMorseAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ClaimMorseApplication(ctx context.Context, in *MsgClaimMorseApplication, opts ...grpc.CallOption) (*MsgClaimMorseApplicationResponse, error) {
	out := new(MsgClaimMorseApplicationResponse)
	err := c.cc.Invoke(ctx, "/pocket.migration.Msg/ClaimMorseApplication", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ClaimMorseSupplier(ctx context.Context, in *MsgClaimMorseSupplier, opts ...grpc.CallOption) (*MsgClaimMorseSupplierResponse, error) {
	out := new(MsgClaimMorseSupplierResponse)
	err := c.cc.Invoke(ctx, "/pocket.migration.Msg/ClaimMorseSupplier", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RecoverMorseAccount(ctx context.Context, in *MsgRecoverMorseAccount, opts ...grpc.CallOption) (*MsgRecoverMorseAccountResponse, error) {
	out := new(MsgRecoverMorseAccountResponse)
	err := c.cc.Invoke(ctx, "/pocket.migration.Msg/RecoverMorseAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// UpdateParams defines a (governance) operation for updating the module
	// parameters. The authority defaults to the x/gov module account.
	UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)
	ImportMorseClaimableAccounts(context.Context, *MsgImportMorseClaimableAccounts) (*MsgImportMorseClaimableAccountsResponse, error)
	ClaimMorseAccount(context.Context, *MsgClaimMorseAccount) (*MsgClaimMorseAccountResponse, error)
	ClaimMorseApplication(context.Context, *MsgClaimMorseApplication) (*MsgClaimMorseApplicationResponse, error)
	ClaimMorseSupplier(context.Context, *MsgClaimMorseSupplier) (*MsgClaimMorseSupplierResponse, error)
	RecoverMorseAccount(context.Context, *MsgRecoverMorseAccount) (*MsgRecoverMorseAccountResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) UpdateParams(ctx context.Context, req *MsgUpdateParams) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateParams not implemented")
}
func (*UnimplementedMsgServer) ImportMorseClaimableAccounts(ctx context.Context, req *MsgImportMorseClaimableAccounts) (*MsgImportMorseClaimableAccountsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportMorseClaimableAccounts not implemented")
}
func (*UnimplementedMsgServer) ClaimMorseAccount(ctx context.Context, req *MsgClaimMorseAccount) (*MsgClaimMorseAccountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimMorseAccount not implemented")
}
func (*UnimplementedMsgServer) ClaimMorseApplication(ctx context.Context, req *MsgClaimMorseApplication) (*MsgClaimMorseApplicationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimMorseApplication not implemented")
}
func (*UnimplementedMsgServer) ClaimMorseSupplier(ctx context.Context, req *MsgClaimMorseSupplier) (*MsgClaimMorseSupplierResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimMorseSupplier not implemented")
}
func (*UnimplementedMsgServer) RecoverMorseAccount(ctx context.Context, req *MsgRecoverMorseAccount) (*MsgRecoverMorseAccountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecoverMorseAccount not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_UpdateParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pocket.migration.Msg/UpdateParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ImportMorseClaimableAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgImportMorseClaimableAccounts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ImportMorseClaimableAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pocket.migration.Msg/ImportMorseClaimableAccounts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ImportMorseClaimableAccounts(ctx, req.(*MsgImportMorseClaimableAccounts))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ClaimMorseAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgClaimMorseAccount)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ClaimMorseAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pocket.migration.Msg/ClaimMorseAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ClaimMorseAccount(ctx, req.(*MsgClaimMorseAccount))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ClaimMorseApplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgClaimMorseApplication)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ClaimMorseApplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pocket.migration.Msg/ClaimMorseApplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ClaimMorseApplication(ctx, req.(*MsgClaimMorseApplication))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ClaimMorseSupplier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgClaimMorseSupplier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ClaimMorseSupplier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pocket.migration.Msg/ClaimMorseSupplier",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ClaimMorseSupplier(ctx, req.(*MsgClaimMorseSupplier))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RecoverMorseAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRecoverMorseAccount)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RecoverMorseAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pocket.migration.Msg/RecoverMorseAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RecoverMorseAccount(ctx, req.(*MsgRecoverMorseAccount))
	}
	return interceptor(ctx, in, info, handler)
}

var Msg_serviceDesc = _Msg_serviceDesc
var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pocket.migration.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateParams",
			Handler:    _Msg_UpdateParams_Handler,
		},
		{
			MethodName: "ImportMorseClaimableAccounts",
			Handler:    _Msg_ImportMorseClaimableAccounts_Handler,
		},
		{
			MethodName: "ClaimMorseAccount",
			Handler:    _Msg_ClaimMorseAccount_Handler,
		},
		{
			MethodName: "ClaimMorseApplication",
			Handler:    _Msg_ClaimMorseApplication_Handler,
		},
		{
			MethodName: "ClaimMorseSupplier",
			Handler:    _Msg_ClaimMorseSupplier_Handler,
		},
		{
			MethodName: "RecoverMorseAccount",
			Handler:    _Msg_RecoverMorseAccount_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pocket/migration/tx.proto",
}

func (m *MsgUpdateParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgImportMorseClaimableAccounts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgImportMorseClaimableAccounts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgImportMorseClaimableAccounts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MorseAccountStateHash) > 0 {
		i -= len(m.MorseAccountStateHash)
		copy(dAtA[i:], m.MorseAccountStateHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MorseAccountStateHash)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.MorseAccountState.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgImportMorseClaimableAccountsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgImportMorseClaimableAccountsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgImportMorseClaimableAccountsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgClaimMorseAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaimMorseAccount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaimMorseAccount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MorsePublicKey) > 0 {
		i -= len(m.MorsePublicKey)
		copy(dAtA[i:], m.MorsePublicKey)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MorsePublicKey)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ShannonSigningAddress) > 0 {
		i -= len(m.ShannonSigningAddress)
		copy(dAtA[i:], m.ShannonSigningAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ShannonSigningAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MorseSignature) > 0 {
		i -= len(m.MorseSignature)
		copy(dAtA[i:], m.MorseSignature)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MorseSignature)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ShannonDestAddress) > 0 {
		i -= len(m.ShannonDestAddress)
		copy(dAtA[i:], m.ShannonDestAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ShannonDestAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgClaimMorseAccountResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaimMorseAccountResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaimMorseAccountResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgClaimMorseApplication) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaimMorseApplication) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaimMorseApplication) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MorsePublicKey) > 0 {
		i -= len(m.MorsePublicKey)
		copy(dAtA[i:], m.MorsePublicKey)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MorsePublicKey)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ShannonSigningAddress) > 0 {
		i -= len(m.ShannonSigningAddress)
		copy(dAtA[i:], m.ShannonSigningAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ShannonSigningAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ServiceConfig != nil {
		{
			size, err := m.ServiceConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.MorseSignature) > 0 {
		i -= len(m.MorseSignature)
		copy(dAtA[i:], m.MorseSignature)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MorseSignature)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ShannonDestAddress) > 0 {
		i -= len(m.ShannonDestAddress)
		copy(dAtA[i:], m.ShannonDestAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ShannonDestAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgClaimMorseApplicationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaimMorseApplicationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaimMorseApplicationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgClaimMorseSupplier) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaimMorseSupplier) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaimMorseSupplier) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SignerIsOutputAddress {
		i--
		if m.SignerIsOutputAddress {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.MorsePublicKey) > 0 {
		i -= len(m.MorsePublicKey)
		copy(dAtA[i:], m.MorsePublicKey)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MorsePublicKey)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ShannonSigningAddress) > 0 {
		i -= len(m.ShannonSigningAddress)
		copy(dAtA[i:], m.ShannonSigningAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ShannonSigningAddress)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Services) > 0 {
		for iNdEx := len(m.Services) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Services[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.MorseSignature) > 0 {
		i -= len(m.MorseSignature)
		copy(dAtA[i:], m.MorseSignature)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MorseSignature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MorseNodeAddress) > 0 {
		i -= len(m.MorseNodeAddress)
		copy(dAtA[i:], m.MorseNodeAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MorseNodeAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ShannonOperatorAddress) > 0 {
		i -= len(m.ShannonOperatorAddress)
		copy(dAtA[i:], m.ShannonOperatorAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ShannonOperatorAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ShannonOwnerAddress) > 0 {
		i -= len(m.ShannonOwnerAddress)
		copy(dAtA[i:], m.ShannonOwnerAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ShannonOwnerAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgClaimMorseSupplierResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaimMorseSupplierResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaimMorseSupplierResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgRecoverMorseAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRecoverMorseAccount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRecoverMorseAccount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MorseSrcAddress) > 0 {
		i -= len(m.MorseSrcAddress)
		copy(dAtA[i:], m.MorseSrcAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MorseSrcAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ShannonDestAddress) > 0 {
		i -= len(m.ShannonDestAddress)
		copy(dAtA[i:], m.ShannonDestAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ShannonDestAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRecoverMorseAccountResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRecoverMorseAccountResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRecoverMorseAccountResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgUpdateParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Params.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgImportMorseClaimableAccounts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.MorseAccountState.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.MorseAccountStateHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgImportMorseClaimableAccountsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgClaimMorseAccount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ShannonDestAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MorseSignature)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ShannonSigningAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MorsePublicKey)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgClaimMorseAccountResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgClaimMorseApplication) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ShannonDestAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MorseSignature)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ServiceConfig != nil {
		l = m.ServiceConfig.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ShannonSigningAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MorsePublicKey)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgClaimMorseApplicationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgClaimMorseSupplier) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ShannonOwnerAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ShannonOperatorAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MorseNodeAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MorseSignature)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Services) > 0 {
		for _, e := range m.Services {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = len(m.ShannonSigningAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MorsePublicKey)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.SignerIsOutputAddress {
		n += 2
	}
	return n
}

func (m *MsgClaimMorseSupplierResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgRecoverMorseAccount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ShannonDestAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MorseSrcAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRecoverMorseAccountResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgUpdateParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgImportMorseClaimableAccounts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgImportMorseClaimableAccounts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgImportMorseClaimableAccounts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MorseAccountState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MorseAccountState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MorseAccountStateHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MorseAccountStateHash = append(m.MorseAccountStateHash[:0], dAtA[iNdEx:postIndex]...)
			if m.MorseAccountStateHash == nil {
				m.MorseAccountStateHash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgImportMorseClaimableAccountsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgImportMorseClaimableAccountsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgImportMorseClaimableAccountsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgClaimMorseAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaimMorseAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaimMorseAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShannonDestAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShannonDestAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MorseSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MorseSignature = append(m.MorseSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.MorseSignature == nil {
				m.MorseSignature = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShannonSigningAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShannonSigningAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MorsePublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MorsePublicKey = append(m.MorsePublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.MorsePublicKey == nil {
				m.MorsePublicKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgClaimMorseAccountResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaimMorseAccountResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaimMorseAccountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgClaimMorseApplication) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaimMorseApplication: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaimMorseApplication: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShannonDestAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShannonDestAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MorseSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MorseSignature = append(m.MorseSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.MorseSignature == nil {
				m.MorseSignature = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceConfig == nil {
				m.ServiceConfig = &types.ApplicationServiceConfig{}
			}
			if err := m.ServiceConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShannonSigningAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShannonSigningAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MorsePublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MorsePublicKey = append(m.MorsePublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.MorsePublicKey == nil {
				m.MorsePublicKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgClaimMorseApplicationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaimMorseApplicationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaimMorseApplicationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgClaimMorseSupplier) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaimMorseSupplier: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaimMorseSupplier: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShannonOwnerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShannonOwnerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShannonOperatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShannonOperatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MorseNodeAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MorseNodeAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MorseSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MorseSignature = append(m.MorseSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.MorseSignature == nil {
				m.MorseSignature = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Services", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Services = append(m.Services, &types.SupplierServiceConfig{})
			if err := m.Services[len(m.Services)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShannonSigningAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShannonSigningAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MorsePublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MorsePublicKey = append(m.MorsePublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.MorsePublicKey == nil {
				m.MorsePublicKey = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignerIsOutputAddress", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SignerIsOutputAddress = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgClaimMorseSupplierResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaimMorseSupplierResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaimMorseSupplierResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRecoverMorseAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRecoverMorseAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRecoverMorseAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShannonDestAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShannonDestAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MorseSrcAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MorseSrcAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRecoverMorseAccountResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRecoverMorseAccountResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRecoverMorseAccountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
