// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pocket/migration/morse_onchain.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MorseSupplierClaimSignerType
// - Enum for Morse supplier claim signer type
type MorseSupplierClaimSignerType int32

const (
	// Unspecified signer type
	MorseSupplierClaimSignerType_MORSE_SUPPLIER_CLAIM_SIGNER_TYPE_UNSPECIFIED MorseSupplierClaimSignerType = 0
	// signer === addr === operator === owner
	// Custodial signer type
	// - The Morse node address is NOT EMPTY (i.e. operator)
	// - The Morse output address is EMPTY (i.e. owner)
	// - Implies that the operator and owner are THE SAME offchain identity
	MorseSupplierClaimSignerType_MORSE_SUPPLIER_CLAIM_SIGNER_TYPE_CUSTODIAL_SIGNED_BY_NODE_ADDR MorseSupplierClaimSignerType = 1
	// signer === operator === addr && owner !== operator
	// Non-custodial signer type
	// - The Morse node address is NOT EMPTY (i.e. operator)
	// - The Morse output address is NOT EMPTY (i.e. owner)
	// - Implies that the operator and owner are MOST LIKELY DIFFERENT offchain identities
	// - The operator is the one signing the supplier claim
	MorseSupplierClaimSignerType_MORSE_SUPPLIER_CLAIM_SIGNER_TYPE_NON_CUSTODIAL_SIGNED_BY_NODE_ADDR MorseSupplierClaimSignerType = 2
	// signer === owner && owner !== addr
	// Owner non-custodial signer type
	// - The Morse node address is EMPTY (i.e. operator)
	// - The Morse output address is NOT EMPTY (i.e. owner)
	// - Implies that the operator and owner are MOST LIKELY different offchain identities
	// - The owner is the one signing the supplier claim
	MorseSupplierClaimSignerType_MORSE_SUPPLIER_CLAIM_SIGNER_TYPE_NON_CUSTODIAL_SIGNED_BY_OWNER MorseSupplierClaimSignerType = 3
)

var MorseSupplierClaimSignerType_name = map[int32]string{
	0: "MORSE_SUPPLIER_CLAIM_SIGNER_TYPE_UNSPECIFIED",
	1: "MORSE_SUPPLIER_CLAIM_SIGNER_TYPE_CUSTODIAL_SIGNED_BY_NODE_ADDR",
	2: "MORSE_SUPPLIER_CLAIM_SIGNER_TYPE_NON_CUSTODIAL_SIGNED_BY_NODE_ADDR",
	3: "MORSE_SUPPLIER_CLAIM_SIGNER_TYPE_NON_CUSTODIAL_SIGNED_BY_OWNER",
}

var MorseSupplierClaimSignerType_value = map[string]int32{
	"MORSE_SUPPLIER_CLAIM_SIGNER_TYPE_UNSPECIFIED":                       0,
	"MORSE_SUPPLIER_CLAIM_SIGNER_TYPE_CUSTODIAL_SIGNED_BY_NODE_ADDR":     1,
	"MORSE_SUPPLIER_CLAIM_SIGNER_TYPE_NON_CUSTODIAL_SIGNED_BY_NODE_ADDR": 2,
	"MORSE_SUPPLIER_CLAIM_SIGNER_TYPE_NON_CUSTODIAL_SIGNED_BY_OWNER":     3,
}

func (x MorseSupplierClaimSignerType) String() string {
	return proto.EnumName(MorseSupplierClaimSignerType_name, int32(x))
}

func (MorseSupplierClaimSignerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dd3531b7be3acfaa, []int{0}
}

// MorseAccountState
// - Onchain representation of all account state to be migrated from Morse
// - NEVER persisted onchain
// - Dependency of the MsgImportMorseClaimableAccount handler
// - Main purpose: exposes #GetHash() for verifying integrity of all MorseClaimableAccounts
type MorseAccountState struct {
	Accounts []*MorseClaimableAccount `protobuf:"bytes,2,rep,name=accounts,proto3" json:"accounts" yaml:"accounts"`
}

func (m *MorseAccountState) Reset()         { *m = MorseAccountState{} }
func (m *MorseAccountState) String() string { return proto.CompactTextString(m) }
func (*MorseAccountState) ProtoMessage()    {}
func (*MorseAccountState) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd3531b7be3acfaa, []int{0}
}
func (m *MorseAccountState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MorseAccountState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MorseAccountState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MorseAccountState.Merge(m, src)
}
func (m *MorseAccountState) XXX_Size() int {
	return m.Size()
}
func (m *MorseAccountState) XXX_DiscardUnknown() {
	xxx_messageInfo_MorseAccountState.DiscardUnknown(m)
}

var xxx_messageInfo_MorseAccountState proto.InternalMessageInfo

func (m *MorseAccountState) GetAccounts() []*MorseClaimableAccount {
	if m != nil {
		return m.Accounts
	}
	return nil
}

// MorseClaimableAccount
//   - Onchain (persisted) representation of a Morse account claimable as part of Morse -> Shannon migration
//   - Created during MorseAccountState import (see: MsgImportMorseClaimableAccount)
//   - Created ONLY ONCE and NEVER deleted (per morse_src_address per network / re-genesis),
//     unless the allow_morse_account_import_overwrite migration param is enabled
//   - Updated ONLY ONCE, when claimed (per morse_src_address per network / re-genesis)
type MorseClaimableAccount struct {
	// bech32-encoded address of the Shannon account to mint claimed balance
	// Intended to remain empty until the account is claimed
	ShannonDestAddress string `protobuf:"bytes,1,opt,name=shannon_dest_address,json=shannonDestAddress,proto3" json:"shannon_dest_address"`
	// Hex-encoded address of the Morse account whose balance will be claimed.
	// If this MorseClaimableAccount represents a Morse node/supplier:
	//   - Morse non-custodial (i.e. operator) address.
	//   - If morse_output_address is not set, this is the custodial address.
	//   - See 'pocket nodes --help' for more information. Note that this refers to the Morse CLI.
	MorseSrcAddress string `protobuf:"bytes,2,opt,name=morse_src_address,json=morseSrcAddress,proto3" json:"morse_src_address"`
	// Unstaked upokt tokens (account balance) available for claiming
	UnstakedBalance types.Coin `protobuf:"bytes,5,opt,name=unstaked_balance,json=unstakedBalance,proto3" json:"unstaked_balance"`
	// Staked tokens for supplier actor corresponding to this account address
	// DEV_NOTE: Context for Morse:
	// - Supplier = Servicer or Node (not a full node) in Morse
	// - All Validators are Servicers; not all Servicers are Validators
	// - Top 100 staked Servicers are validators (automatic)
	// - Only accounts for servicer stake balance transition
	// TODO_MAINNET(@Olshansk): Develop strategy for bootstrapping validators in Shannon with cosmos ecosystem
	SupplierStake types.Coin `protobuf:"bytes,6,opt,name=supplier_stake,json=supplierStake,proto3" json:"supplier_stake"`
	// Staked tokens for application actor corresponding to this account address
	ApplicationStake types.Coin `protobuf:"bytes,7,opt,name=application_stake,json=applicationStake,proto3" json:"application_stake"`
	// Shannon height at which the account was claimed
	// Intended to remain empty until the account is claimed
	ClaimedAtHeight int64 `protobuf:"varint,8,opt,name=claimed_at_height,json=claimedAtHeight,proto3" json:"claimed_at_height" yaml:"claimed_at_height"`
	// ONLY applicable to Morse node/supplier accounts.
	// Hex-encoded address of the Morse output account/wallet associated with the Morse node/supplier.
	// - E.g.: 00f9900606fa3d5c9179fc0c8513078a53a2073e
	// - Morse custodial (i.e. owner) address, which owns the staked tokens of the operator.
	//   See 'pocket nodes --help' for more information. Note that this refers to the Morse CLI.
	MorseOutputAddress string `protobuf:"bytes,9,opt,name=morse_output_address,json=morseOutputAddress,proto3" json:"morse_output_address,omitempty" yaml:"morse_output_address"`
}

func (m *MorseClaimableAccount) Reset()         { *m = MorseClaimableAccount{} }
func (m *MorseClaimableAccount) String() string { return proto.CompactTextString(m) }
func (*MorseClaimableAccount) ProtoMessage()    {}
func (*MorseClaimableAccount) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd3531b7be3acfaa, []int{1}
}
func (m *MorseClaimableAccount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MorseClaimableAccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MorseClaimableAccount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MorseClaimableAccount.Merge(m, src)
}
func (m *MorseClaimableAccount) XXX_Size() int {
	return m.Size()
}
func (m *MorseClaimableAccount) XXX_DiscardUnknown() {
	xxx_messageInfo_MorseClaimableAccount.DiscardUnknown(m)
}

var xxx_messageInfo_MorseClaimableAccount proto.InternalMessageInfo

func (m *MorseClaimableAccount) GetShannonDestAddress() string {
	if m != nil {
		return m.ShannonDestAddress
	}
	return ""
}

func (m *MorseClaimableAccount) GetMorseSrcAddress() string {
	if m != nil {
		return m.MorseSrcAddress
	}
	return ""
}

func (m *MorseClaimableAccount) GetUnstakedBalance() types.Coin {
	if m != nil {
		return m.UnstakedBalance
	}
	return types.Coin{}
}

func (m *MorseClaimableAccount) GetSupplierStake() types.Coin {
	if m != nil {
		return m.SupplierStake
	}
	return types.Coin{}
}

func (m *MorseClaimableAccount) GetApplicationStake() types.Coin {
	if m != nil {
		return m.ApplicationStake
	}
	return types.Coin{}
}

func (m *MorseClaimableAccount) GetClaimedAtHeight() int64 {
	if m != nil {
		return m.ClaimedAtHeight
	}
	return 0
}

func (m *MorseClaimableAccount) GetMorseOutputAddress() string {
	if m != nil {
		return m.MorseOutputAddress
	}
	return ""
}

func init() {
	proto.RegisterEnum("pocket.migration.MorseSupplierClaimSignerType", MorseSupplierClaimSignerType_name, MorseSupplierClaimSignerType_value)
	proto.RegisterType((*MorseAccountState)(nil), "pocket.migration.MorseAccountState")
	proto.RegisterType((*MorseClaimableAccount)(nil), "pocket.migration.MorseClaimableAccount")
}

func init() {
	proto.RegisterFile("pocket/migration/morse_onchain.proto", fileDescriptor_dd3531b7be3acfaa)
}

var fileDescriptor_dd3531b7be3acfaa = []byte{
	// 682 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x54, 0xcd, 0x6e, 0xd3, 0x40,
	0x18, 0x8c, 0xd3, 0x1f, 0xda, 0xad, 0x20, 0xa9, 0x95, 0xa2, 0xb4, 0x20, 0x3b, 0x8a, 0x90, 0x88,
	0x50, 0x6b, 0xd3, 0x02, 0x17, 0x0e, 0x48, 0x76, 0xe2, 0x42, 0x50, 0x9b, 0x44, 0x76, 0x2b, 0x28,
	0x07, 0x56, 0x1b, 0x67, 0x71, 0xac, 0xd8, 0x5e, 0xcb, 0xbb, 0x01, 0xf2, 0x16, 0x3c, 0x02, 0x0f,
	0xc1, 0x95, 0x7b, 0x8f, 0x15, 0xa7, 0x9e, 0x2c, 0x94, 0xde, 0x72, 0xec, 0x13, 0xa0, 0xac, 0x9d,
	0x50, 0x35, 0x41, 0xe1, 0xe6, 0x6f, 0xbe, 0x99, 0xf9, 0x56, 0x3b, 0x9f, 0x17, 0x3c, 0x0a, 0x89,
	0xdd, 0xc3, 0x4c, 0xf5, 0x5d, 0x27, 0x42, 0xcc, 0x25, 0x81, 0xea, 0x93, 0x88, 0x62, 0x48, 0x02,
	0xbb, 0x8b, 0xdc, 0x40, 0x09, 0x23, 0xc2, 0x88, 0x98, 0x4f, 0x58, 0xca, 0x94, 0xb5, 0xb3, 0x6d,
	0x13, 0xea, 0x13, 0x0a, 0x79, 0x5f, 0x4d, 0x8a, 0x84, 0xbc, 0x23, 0x25, 0x95, 0xda, 0x46, 0x14,
	0xab, 0x9f, 0xf7, 0xdb, 0x98, 0xa1, 0x7d, 0xd5, 0x26, 0x13, 0xb3, 0x9d, 0x82, 0x43, 0x1c, 0x92,
	0xe8, 0xc6, 0x5f, 0x09, 0x5a, 0x1e, 0x80, 0xcd, 0xe3, 0xf1, 0x64, 0xcd, 0xb6, 0x49, 0x3f, 0x60,
	0x16, 0x43, 0x0c, 0x8b, 0x1d, 0xb0, 0x86, 0x92, 0x9a, 0x16, 0xb3, 0xa5, 0xa5, 0xca, 0xc6, 0xc1,
	0x63, 0xe5, 0xf6, 0x51, 0x14, 0x2e, 0xab, 0x7a, 0xc8, 0xf5, 0x51, 0xdb, 0x9b, 0xe8, 0x75, 0x79,
	0x14, 0xcb, 0x53, 0xf1, 0x75, 0x2c, 0xe7, 0x06, 0xc8, 0xf7, 0x5e, 0x96, 0x27, 0x48, 0xd9, 0x9c,
	0x36, 0xcb, 0x3f, 0x57, 0xc0, 0xd6, 0x5c, 0x13, 0xf1, 0x13, 0x28, 0xd0, 0x2e, 0x0a, 0x02, 0x12,
	0xc0, 0x0e, 0xa6, 0x0c, 0xa2, 0x4e, 0x27, 0xc2, 0x94, 0x16, 0x85, 0x92, 0x50, 0x59, 0xd7, 0x9f,
	0x9f, 0xc7, 0xb2, 0x30, 0x8a, 0xe5, 0xb9, 0x9c, 0x5f, 0x3f, 0xf6, 0x0a, 0xe9, 0xb5, 0x68, 0x09,
	0x62, 0xb1, 0xc8, 0x0d, 0x1c, 0x53, 0x4c, 0xd9, 0x35, 0x4c, 0x59, 0xda, 0x11, 0x35, 0xb0, 0x99,
	0x5c, 0x3b, 0x8d, 0xec, 0xe9, 0x90, 0x2c, 0x1f, 0xb2, 0x35, 0x8a, 0xe5, 0xd9, 0xa6, 0x99, 0xe3,
	0x90, 0x15, 0xd9, 0x13, 0x8b, 0x8f, 0x20, 0xdf, 0x0f, 0x28, 0x43, 0x3d, 0xdc, 0x81, 0x6d, 0xe4,
	0xa1, 0xc0, 0xc6, 0xc5, 0x95, 0x92, 0x50, 0xd9, 0x38, 0xd8, 0x56, 0xd2, 0x73, 0x8c, 0x03, 0x51,
	0xd2, 0x40, 0x94, 0x2a, 0x71, 0x03, 0xbd, 0x78, 0x1e, 0xcb, 0x99, 0x51, 0x2c, 0xcf, 0x48, 0xcd,
	0xdc, 0x04, 0xd1, 0x13, 0x40, 0x7c, 0x0f, 0xee, 0xd1, 0x7e, 0x18, 0x7a, 0x2e, 0x8e, 0x20, 0xef,
	0x14, 0x57, 0x17, 0xb9, 0xdf, 0x4f, 0xdd, 0x6f, 0x09, 0xcd, 0xbb, 0x93, 0xda, 0x1a, 0x97, 0x22,
	0x02, 0x9b, 0x68, 0x5c, 0xdb, 0x3c, 0xce, 0xd4, 0xfc, 0xce, 0x22, 0xf3, 0xed, 0xd4, 0x7c, 0x56,
	0x6b, 0xe6, 0x6f, 0x40, 0xd3, 0x11, 0xf6, 0x38, 0x5b, 0xdc, 0x81, 0x88, 0xc1, 0x2e, 0x76, 0x9d,
	0x2e, 0x2b, 0xae, 0x95, 0x84, 0xca, 0x92, 0xfe, 0x22, 0x0d, 0x71, 0x96, 0x70, 0x1d, 0xcb, 0xc5,
	0x64, 0x69, 0x66, 0x5a, 0x65, 0x33, 0x97, 0x62, 0x1a, 0x7b, 0xc3, 0x11, 0x91, 0x82, 0x42, 0xfa,
	0xe7, 0xf4, 0x59, 0xd8, 0xff, 0xbb, 0x2a, 0xeb, 0x3c, 0x45, 0x6d, 0x14, 0xcb, 0xd2, 0xbc, 0xfe,
	0x2e, 0xf1, 0x5d, 0x86, 0xfd, 0x90, 0x0d, 0xae, 0x63, 0xf9, 0x41, 0x32, 0x6e, 0x1e, 0xaf, 0x6c,
	0x8a, 0x1c, 0x6e, 0x72, 0x34, 0x0d, 0xfd, 0xed, 0xf2, 0xda, 0x72, 0x7e, 0xe5, 0xc9, 0xf7, 0x2c,
	0x78, 0xc8, 0xf7, 0xd7, 0x4a, 0xef, 0x95, 0xef, 0xb1, 0xe5, 0x3a, 0x01, 0x8e, 0x4e, 0x06, 0x21,
	0x16, 0x9f, 0x82, 0xdd, 0xe3, 0xa6, 0x69, 0x19, 0xd0, 0x3a, 0x6d, 0xb5, 0x8e, 0xea, 0x86, 0x09,
	0xab, 0x47, 0x5a, 0xfd, 0x18, 0x5a, 0xf5, 0xd7, 0x0d, 0xc3, 0x84, 0x27, 0x67, 0x2d, 0x03, 0x9e,
	0x36, 0xac, 0x96, 0x51, 0xad, 0x1f, 0xd6, 0x8d, 0x5a, 0x3e, 0x23, 0xea, 0xe0, 0xd5, 0x42, 0x45,
	0xf5, 0xd4, 0x3a, 0x69, 0xd6, 0xea, 0xda, 0x51, 0x82, 0xd6, 0xa0, 0x7e, 0x06, 0x1b, 0xcd, 0x9a,
	0x01, 0xb5, 0x5a, 0xcd, 0xcc, 0x0b, 0xe2, 0x21, 0xd0, 0x17, 0x7a, 0x34, 0x9a, 0x8d, 0x05, 0x3e,
	0xd9, 0xff, 0x3a, 0xcb, 0xbf, 0x7c, 0x9a, 0xef, 0x1a, 0x86, 0x99, 0x5f, 0xd2, 0x5b, 0xe7, 0x43,
	0x49, 0xb8, 0x18, 0x4a, 0xc2, 0xe5, 0x50, 0x12, 0x7e, 0x0f, 0x25, 0xe1, 0xdb, 0x95, 0x94, 0xb9,
	0xb8, 0x92, 0x32, 0x97, 0x57, 0x52, 0xe6, 0xc3, 0x81, 0xe3, 0xb2, 0x6e, 0xbf, 0xad, 0xd8, 0xc4,
	0x57, 0x43, 0xd2, 0x63, 0x7b, 0x01, 0x66, 0x5f, 0x48, 0xd4, 0xe3, 0x45, 0x44, 0x3c, 0x4f, 0xfd,
	0x7a, 0xe3, 0x81, 0x64, 0x83, 0x10, 0xd3, 0xf6, 0x2a, 0x7f, 0xb6, 0x9e, 0xfd, 0x09, 0x00, 0x00,
	0xff, 0xff, 0xb0, 0x4c, 0xe4, 0x6e, 0x41, 0x05, 0x00, 0x00,
}

func (m *MorseAccountState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MorseAccountState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MorseAccountState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Accounts) > 0 {
		for iNdEx := len(m.Accounts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Accounts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMorseOnchain(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *MorseClaimableAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MorseClaimableAccount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MorseClaimableAccount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MorseOutputAddress) > 0 {
		i -= len(m.MorseOutputAddress)
		copy(dAtA[i:], m.MorseOutputAddress)
		i = encodeVarintMorseOnchain(dAtA, i, uint64(len(m.MorseOutputAddress)))
		i--
		dAtA[i] = 0x4a
	}
	if m.ClaimedAtHeight != 0 {
		i = encodeVarintMorseOnchain(dAtA, i, uint64(m.ClaimedAtHeight))
		i--
		dAtA[i] = 0x40
	}
	{
		size, err := m.ApplicationStake.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMorseOnchain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.SupplierStake.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMorseOnchain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.UnstakedBalance.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMorseOnchain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.MorseSrcAddress) > 0 {
		i -= len(m.MorseSrcAddress)
		copy(dAtA[i:], m.MorseSrcAddress)
		i = encodeVarintMorseOnchain(dAtA, i, uint64(len(m.MorseSrcAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ShannonDestAddress) > 0 {
		i -= len(m.ShannonDestAddress)
		copy(dAtA[i:], m.ShannonDestAddress)
		i = encodeVarintMorseOnchain(dAtA, i, uint64(len(m.ShannonDestAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMorseOnchain(dAtA []byte, offset int, v uint64) int {
	offset -= sovMorseOnchain(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MorseAccountState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Accounts) > 0 {
		for _, e := range m.Accounts {
			l = e.Size()
			n += 1 + l + sovMorseOnchain(uint64(l))
		}
	}
	return n
}

func (m *MorseClaimableAccount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ShannonDestAddress)
	if l > 0 {
		n += 1 + l + sovMorseOnchain(uint64(l))
	}
	l = len(m.MorseSrcAddress)
	if l > 0 {
		n += 1 + l + sovMorseOnchain(uint64(l))
	}
	l = m.UnstakedBalance.Size()
	n += 1 + l + sovMorseOnchain(uint64(l))
	l = m.SupplierStake.Size()
	n += 1 + l + sovMorseOnchain(uint64(l))
	l = m.ApplicationStake.Size()
	n += 1 + l + sovMorseOnchain(uint64(l))
	if m.ClaimedAtHeight != 0 {
		n += 1 + sovMorseOnchain(uint64(m.ClaimedAtHeight))
	}
	l = len(m.MorseOutputAddress)
	if l > 0 {
		n += 1 + l + sovMorseOnchain(uint64(l))
	}
	return n
}

func sovMorseOnchain(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMorseOnchain(x uint64) (n int) {
	return sovMorseOnchain(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MorseAccountState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMorseOnchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MorseAccountState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MorseAccountState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOnchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMorseOnchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOnchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Accounts = append(m.Accounts, &MorseClaimableAccount{})
			if err := m.Accounts[len(m.Accounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMorseOnchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMorseOnchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MorseClaimableAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMorseOnchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MorseClaimableAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MorseClaimableAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShannonDestAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOnchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMorseOnchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOnchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShannonDestAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MorseSrcAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOnchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMorseOnchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOnchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MorseSrcAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnstakedBalance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOnchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMorseOnchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOnchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UnstakedBalance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplierStake", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOnchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMorseOnchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOnchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SupplierStake.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationStake", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOnchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMorseOnchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOnchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ApplicationStake.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimedAtHeight", wireType)
			}
			m.ClaimedAtHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOnchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClaimedAtHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MorseOutputAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOnchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMorseOnchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOnchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MorseOutputAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMorseOnchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMorseOnchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMorseOnchain(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMorseOnchain
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMorseOnchain
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMorseOnchain
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMorseOnchain
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMorseOnchain
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMorseOnchain
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMorseOnchain        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMorseOnchain          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMorseOnchain = fmt.Errorf("proto: unexpected end of group")
)
