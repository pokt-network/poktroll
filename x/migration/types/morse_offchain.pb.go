// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pocket/migration/morse_offchain.proto

// Types in this file are ONLY present to facilitate the verifiability of the
// migration state from Morse to Shannon.
//
// These types reproduce a 1:1 de/serialization for the corresponding Morse data structures
// but are not completely identical to their Morse counterparts, not all of which are defined
// as protobuf types in the Morse codebase.
//
// Morse leverages pb.Any types, as well as the gogoproto.casttype option in several places.
// All usages of pb.Any have been replaced with equivalent protobuf types
// (i.e. an interstitial type with `type` and/or `value` field(s)).
// All usages of gogoproto.casttype which previously referenced Morse data structures have been removed.
// A few specific fields have retained this option where the type is changed to the underlying
// external lib type that the Morse type was wrapping (e.g. address and public key fields).
//
// These types are used by the migration subcommand to transform
// the Morse state export into the Shannon state import like so:
//  $ pocketd tx migration collect-morse-accounts ...
//
// CRITICAL: These types are offchain and ARE NOT persisted onchain (Shannon) at any point.

package types

import (
	bytes "bytes"
	crypto_ed25519 "crypto/ed25519"
	fmt "fmt"
	github_com_cometbft_cometbft_crypto "github.com/cometbft/cometbft/crypto"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MorseStateExport is the data structure that is serialized and output when running:
//
//	$ pocket utils export-genesis-for-reset ...
//
// Ref: https://editor.swagger.io/?url=https://raw.githubusercontent.com/pokt-network/pocket-core/staging/doc/specs/rpc-spec.yaml#operations-query-post_query_state
type MorseStateExport struct {
	// app_hash is the Morse tendermint state hash.
	AppHash string `protobuf:"bytes,1,opt,name=app_hash,json=appHash,proto3" json:"app_hash"`
	// app_state is the entire Morse tendermint application state.
	AppState *MorseTendermintAppState `protobuf:"bytes,2,opt,name=app_state,json=appState,proto3" json:"app_state"`
}

func (m *MorseStateExport) Reset()         { *m = MorseStateExport{} }
func (m *MorseStateExport) String() string { return proto.CompactTextString(m) }
func (*MorseStateExport) ProtoMessage()    {}
func (*MorseStateExport) Descriptor() ([]byte, []int) {
	return fileDescriptor_d432b9bbab37e9d7, []int{0}
}
func (m *MorseStateExport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MorseStateExport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MorseStateExport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MorseStateExport.Merge(m, src)
}
func (m *MorseStateExport) XXX_Size() int {
	return m.Size()
}
func (m *MorseStateExport) XXX_DiscardUnknown() {
	xxx_messageInfo_MorseStateExport.DiscardUnknown(m)
}

var xxx_messageInfo_MorseStateExport proto.InternalMessageInfo

func (m *MorseStateExport) GetAppHash() string {
	if m != nil {
		return m.AppHash
	}
	return ""
}

func (m *MorseStateExport) GetAppState() *MorseTendermintAppState {
	if m != nil {
		return m.AppState
	}
	return nil
}

// MorseTendermintAppState is the tendermint application state for the Morse tendermint
// application; not to be confused with the pokt protocol actor.
// It is constructed in Morse via `PocketCoreApp#ExportAppState()`.
//
// See: https://github.com/pokt-network/pocket-core/blob/5fa61920aa9d45ca6bf9e01e863134e242c95fa7/app/pocket.go#L142
type MorseTendermintAppState struct {
	Application *MorseApplications `protobuf:"bytes,1,opt,name=application,proto3" json:"application"`
	Auth        *MorseAuth         `protobuf:"bytes,2,opt,name=auth,proto3" json:"auth"`
	Pos         *MorsePos          `protobuf:"bytes,3,opt,name=pos,proto3" json:"pos"`
}

func (m *MorseTendermintAppState) Reset()         { *m = MorseTendermintAppState{} }
func (m *MorseTendermintAppState) String() string { return proto.CompactTextString(m) }
func (*MorseTendermintAppState) ProtoMessage()    {}
func (*MorseTendermintAppState) Descriptor() ([]byte, []int) {
	return fileDescriptor_d432b9bbab37e9d7, []int{1}
}
func (m *MorseTendermintAppState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MorseTendermintAppState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MorseTendermintAppState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MorseTendermintAppState.Merge(m, src)
}
func (m *MorseTendermintAppState) XXX_Size() int {
	return m.Size()
}
func (m *MorseTendermintAppState) XXX_DiscardUnknown() {
	xxx_messageInfo_MorseTendermintAppState.DiscardUnknown(m)
}

var xxx_messageInfo_MorseTendermintAppState proto.InternalMessageInfo

func (m *MorseTendermintAppState) GetApplication() *MorseApplications {
	if m != nil {
		return m.Application
	}
	return nil
}

func (m *MorseTendermintAppState) GetAuth() *MorseAuth {
	if m != nil {
		return m.Auth
	}
	return nil
}

func (m *MorseTendermintAppState) GetPos() *MorsePos {
	if m != nil {
		return m.Pos
	}
	return nil
}

// A wrapper around the list of MorseApplications, necessary in order to conform to the Morse genesis structure.
// It encapsulates the minimum information required to import Morse applications.
//
// See: https://github.com/pokt-network/pocket-core/blob/staging/x/apps/types/genesis.go#L4
type MorseApplications struct {
	Applications []*MorseApplication `protobuf:"bytes,1,rep,name=applications,proto3" json:"applications"`
}

func (m *MorseApplications) Reset()         { *m = MorseApplications{} }
func (m *MorseApplications) String() string { return proto.CompactTextString(m) }
func (*MorseApplications) ProtoMessage()    {}
func (*MorseApplications) Descriptor() ([]byte, []int) {
	return fileDescriptor_d432b9bbab37e9d7, []int{2}
}
func (m *MorseApplications) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MorseApplications) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MorseApplications) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MorseApplications.Merge(m, src)
}
func (m *MorseApplications) XXX_Size() int {
	return m.Size()
}
func (m *MorseApplications) XXX_DiscardUnknown() {
	xxx_messageInfo_MorseApplications.DiscardUnknown(m)
}

var xxx_messageInfo_MorseApplications proto.InternalMessageInfo

func (m *MorseApplications) GetApplications() []*MorseApplication {
	if m != nil {
		return m.Applications
	}
	return nil
}

// A wrapper around a list of MorseAuthAccount.
// It encapsulates the minimum information required to import Morse accounts.
//
// See: https://github.com/pokt-network/pocket-core/blob/staging/x/auth/types/genesis.go#L9
type MorseAuth struct {
	Accounts []*MorseAuthAccount `protobuf:"bytes,1,rep,name=accounts,proto3" json:"accounts"`
}

func (m *MorseAuth) Reset()         { *m = MorseAuth{} }
func (m *MorseAuth) String() string { return proto.CompactTextString(m) }
func (*MorseAuth) ProtoMessage()    {}
func (*MorseAuth) Descriptor() ([]byte, []int) {
	return fileDescriptor_d432b9bbab37e9d7, []int{3}
}
func (m *MorseAuth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MorseAuth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MorseAuth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MorseAuth.Merge(m, src)
}
func (m *MorseAuth) XXX_Size() int {
	return m.Size()
}
func (m *MorseAuth) XXX_DiscardUnknown() {
	xxx_messageInfo_MorseAuth.DiscardUnknown(m)
}

var xxx_messageInfo_MorseAuth proto.InternalMessageInfo

func (m *MorseAuth) GetAccounts() []*MorseAuthAccount {
	if m != nil {
		return m.Accounts
	}
	return nil
}

// MorseAccount:
// * Wraps MorseAuthAccount information to conform to Morse genesis structure
// * Represents only externally owned accounts (not module accounts)
// * Avoids pb.Any serialization since only external accounts needed for migration
type MorseAuthAccount struct {
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type"`
	// Types that are valid to be assigned to Value:
	//	*MorseAuthAccount_MorseAccount
	//	*MorseAuthAccount_MorseModuleAccount
	Value isMorseAuthAccount_Value `protobuf_oneof:"value"`
}

func (m *MorseAuthAccount) Reset()         { *m = MorseAuthAccount{} }
func (m *MorseAuthAccount) String() string { return proto.CompactTextString(m) }
func (*MorseAuthAccount) ProtoMessage()    {}
func (*MorseAuthAccount) Descriptor() ([]byte, []int) {
	return fileDescriptor_d432b9bbab37e9d7, []int{4}
}
func (m *MorseAuthAccount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MorseAuthAccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MorseAuthAccount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MorseAuthAccount.Merge(m, src)
}
func (m *MorseAuthAccount) XXX_Size() int {
	return m.Size()
}
func (m *MorseAuthAccount) XXX_DiscardUnknown() {
	xxx_messageInfo_MorseAuthAccount.DiscardUnknown(m)
}

var xxx_messageInfo_MorseAuthAccount proto.InternalMessageInfo

type isMorseAuthAccount_Value interface {
	isMorseAuthAccount_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MorseAuthAccount_MorseAccount struct {
	MorseAccount *MorseAccount `protobuf:"bytes,3,opt,name=morse_account,json=morseAccount,proto3,oneof" json:"morse_account"`
}
type MorseAuthAccount_MorseModuleAccount struct {
	MorseModuleAccount *MorseModuleAccount `protobuf:"bytes,4,opt,name=morse_module_account,json=morseModuleAccount,proto3,oneof" json:"morse_module_account"`
}

func (*MorseAuthAccount_MorseAccount) isMorseAuthAccount_Value()       {}
func (*MorseAuthAccount_MorseModuleAccount) isMorseAuthAccount_Value() {}

func (m *MorseAuthAccount) GetValue() isMorseAuthAccount_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *MorseAuthAccount) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *MorseAuthAccount) GetMorseAccount() *MorseAccount {
	if x, ok := m.GetValue().(*MorseAuthAccount_MorseAccount); ok {
		return x.MorseAccount
	}
	return nil
}

func (m *MorseAuthAccount) GetMorseModuleAccount() *MorseModuleAccount {
	if x, ok := m.GetValue().(*MorseAuthAccount_MorseModuleAccount); ok {
		return x.MorseModuleAccount
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MorseAuthAccount) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MorseAuthAccount_MorseAccount)(nil),
		(*MorseAuthAccount_MorseModuleAccount)(nil),
	}
}

// A wrapper around the list of Morse suppliers (aka "validators", "nodes", of "servicers").
// It is necessary to conform to the Morse genesis structure.
//
// See: https://github.com/pokt-network/pocket-core/blob/staging/x/nodes/types/genesis.go#L8
type MorsePos struct {
	Validators []*MorseValidator `protobuf:"bytes,1,rep,name=validators,proto3" json:"validators"`
}

func (m *MorsePos) Reset()         { *m = MorsePos{} }
func (m *MorsePos) String() string { return proto.CompactTextString(m) }
func (*MorsePos) ProtoMessage()    {}
func (*MorsePos) Descriptor() ([]byte, []int) {
	return fileDescriptor_d432b9bbab37e9d7, []int{5}
}
func (m *MorsePos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MorsePos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MorsePos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MorsePos.Merge(m, src)
}
func (m *MorsePos) XXX_Size() int {
	return m.Size()
}
func (m *MorsePos) XXX_DiscardUnknown() {
	xxx_messageInfo_MorsePos.DiscardUnknown(m)
}

var xxx_messageInfo_MorsePos proto.InternalMessageInfo

func (m *MorsePos) GetValidators() []*MorseValidator {
	if m != nil {
		return m.Validators
	}
	return nil
}

// MorseApplication is a subset of the Morse ProtoApplication type.
// It encapsulates the minimum information required to import Morse applications.
//
// See: https://github.com/pokt-network/pocket-core/blob/staging/proto/x/apps/apps.proto#L16
type MorseApplication struct {
	// Address is a binary representation of the address corresponding
	// to a Morse application's ed25519 public key.
	Address github_com_cometbft_cometbft_crypto.Address `protobuf:"bytes,1,opt,name=address,proto3,casttype=github.com/cometbft/cometbft/crypto.Address" json:"address" yaml:"address"`
	// PublicKey is the binary representation of a Morse application's ed25519 public key.
	PublicKey []byte `protobuf:"bytes,2,opt,name=public_key,json=publicKey,proto3" json:"public_key" yaml:"public_key"`
	// TODO_MAINNET_MIGRATION(@Olshansk):  Should status and/or jailed be considered during the migration, and if so, how?
	Jailed bool  `protobuf:"varint,3,opt,name=jailed,proto3" json:"jailed" yaml:"jailed"`
	Status int32 `protobuf:"varint,4,opt,name=status,proto3" json:"status" yaml:"status"`
	// The string representation of the BigInt amount of upokt.
	StakedTokens string `protobuf:"bytes,6,opt,name=staked_tokens,json=stakedTokens,proto3" json:"staked_tokens"`
}

func (m *MorseApplication) Reset()         { *m = MorseApplication{} }
func (m *MorseApplication) String() string { return proto.CompactTextString(m) }
func (*MorseApplication) ProtoMessage()    {}
func (*MorseApplication) Descriptor() ([]byte, []int) {
	return fileDescriptor_d432b9bbab37e9d7, []int{6}
}
func (m *MorseApplication) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MorseApplication) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MorseApplication) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MorseApplication.Merge(m, src)
}
func (m *MorseApplication) XXX_Size() int {
	return m.Size()
}
func (m *MorseApplication) XXX_DiscardUnknown() {
	xxx_messageInfo_MorseApplication.DiscardUnknown(m)
}

var xxx_messageInfo_MorseApplication proto.InternalMessageInfo

// MorseValidator is a subset of the Morse ProtoValidator type.
// It encapsulates the minimum information required to import Morse suppliers (aka "servicers" or "validators").
//
// See: https://github.com/pokt-network/pocket-core/blob/staging/proto/x/pos/types.proto#L16
type MorseValidator struct {
	// A binary representation of the address corresponding to a Morse application's ed25519 public key.
	Address github_com_cometbft_cometbft_crypto.Address `protobuf:"bytes,1,opt,name=address,proto3,casttype=github.com/cometbft/cometbft/crypto.Address" json:"address" yaml:"address"`
	// The binary representation of a Morse application's ed25519 public key.
	PublicKey []byte `protobuf:"bytes,2,opt,name=public_key,json=publicKey,proto3" json:"public_key" yaml:"public_key"`
	// TODO_MAINNET_MIGRATION(@Olshansk):  Should status and/or jailed be considered during the migration, and if so, how?
	Jailed bool  `protobuf:"varint,3,opt,name=jailed,proto3" json:"jailed"`
	Status int32 `protobuf:"varint,4,opt,name=status,proto3" json:"status"`
	// The string representation of the BigInt amount of upokt.
	StakedTokens string `protobuf:"bytes,7,opt,name=staked_tokens,json=stakedTokens,proto3" json:"tokens"`
}

func (m *MorseValidator) Reset()         { *m = MorseValidator{} }
func (m *MorseValidator) String() string { return proto.CompactTextString(m) }
func (*MorseValidator) ProtoMessage()    {}
func (*MorseValidator) Descriptor() ([]byte, []int) {
	return fileDescriptor_d432b9bbab37e9d7, []int{7}
}
func (m *MorseValidator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MorseValidator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MorseValidator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MorseValidator.Merge(m, src)
}
func (m *MorseValidator) XXX_Size() int {
	return m.Size()
}
func (m *MorseValidator) XXX_DiscardUnknown() {
	xxx_messageInfo_MorseValidator.DiscardUnknown(m)
}

var xxx_messageInfo_MorseValidator proto.InternalMessageInfo

// MorseAccount is an analog of the Morse ProtoBaseAccount type.
// It encapsulates the minimum information required to import accounts.
//
// See: https://github.com/pokt-network/pocket-core/blob/staging/proto/x/auth/auth.proto#L14.
type MorseAccount struct {
	// A hex-encoded representation of the address corresponding to a Morse application's ed25519 public key.
	Address github_com_cometbft_cometbft_crypto.Address `protobuf:"bytes,1,opt,name=address,proto3,casttype=github.com/cometbft/cometbft/crypto.Address" json:"address"`
	// The ed25519 public key of the account.
	PubKey *MorsePublicKey `protobuf:"bytes,2,opt,name=pub_key,json=pubKey,proto3" json:"public_key" yaml:"public_key"`
	// The account balance; this does not include any actor stakes.
	Coins []types.Coin `protobuf:"bytes,3,rep,name=coins,proto3" json:"coins"`
}

func (m *MorseAccount) Reset()         { *m = MorseAccount{} }
func (m *MorseAccount) String() string { return proto.CompactTextString(m) }
func (*MorseAccount) ProtoMessage()    {}
func (*MorseAccount) Descriptor() ([]byte, []int) {
	return fileDescriptor_d432b9bbab37e9d7, []int{8}
}
func (m *MorseAccount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MorseAccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MorseAccount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MorseAccount.Merge(m, src)
}
func (m *MorseAccount) XXX_Size() int {
	return m.Size()
}
func (m *MorseAccount) XXX_DiscardUnknown() {
	xxx_messageInfo_MorseAccount.DiscardUnknown(m)
}

var xxx_messageInfo_MorseAccount proto.InternalMessageInfo

func (*MorseAccount) XXX_MessageName() string {
	return "pocket.migration.MorseAccount"
}

// MorsePublicKey is required to conform to the encoding of the Morse state export.
// NB: All Morse account public keys will be ed25519 keys by definition.
type MorsePublicKey struct {
	Value crypto_ed25519.PublicKey `protobuf:"bytes,2,opt,name=value,proto3,casttype=crypto/ed25519.PublicKey" json:"value,omitempty"`
}

func (m *MorsePublicKey) Reset()         { *m = MorsePublicKey{} }
func (m *MorsePublicKey) String() string { return proto.CompactTextString(m) }
func (*MorsePublicKey) ProtoMessage()    {}
func (*MorsePublicKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_d432b9bbab37e9d7, []int{9}
}
func (m *MorsePublicKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MorsePublicKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MorsePublicKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MorsePublicKey.Merge(m, src)
}
func (m *MorsePublicKey) XXX_Size() int {
	return m.Size()
}
func (m *MorsePublicKey) XXX_DiscardUnknown() {
	xxx_messageInfo_MorsePublicKey.DiscardUnknown(m)
}

var xxx_messageInfo_MorsePublicKey proto.InternalMessageInfo

func (m *MorsePublicKey) GetValue() crypto_ed25519.PublicKey {
	if m != nil {
		return m.Value
	}
	return nil
}

// MorseModuleAccount is the module account type for Morse, it:
// - Wraps a MorseAccount which NEVER has an address
// - Has a unique name as an identifier instead
type MorseModuleAccount struct {
	MorseAccount `protobuf:"bytes,1,opt,name=base_account,json=baseAccount,proto3,embedded=base_account" json:"base_account" yaml:"base_account"`
	Name         string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name" yaml:"name"`
	Permissions  []string `protobuf:"bytes,3,rep,name=permissions,proto3" json:"permissions" yaml:"permissions"`
}

func (m *MorseModuleAccount) Reset()         { *m = MorseModuleAccount{} }
func (m *MorseModuleAccount) String() string { return proto.CompactTextString(m) }
func (*MorseModuleAccount) ProtoMessage()    {}
func (*MorseModuleAccount) Descriptor() ([]byte, []int) {
	return fileDescriptor_d432b9bbab37e9d7, []int{10}
}
func (m *MorseModuleAccount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MorseModuleAccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MorseModuleAccount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MorseModuleAccount.Merge(m, src)
}
func (m *MorseModuleAccount) XXX_Size() int {
	return m.Size()
}
func (m *MorseModuleAccount) XXX_DiscardUnknown() {
	xxx_messageInfo_MorseModuleAccount.DiscardUnknown(m)
}

var xxx_messageInfo_MorseModuleAccount proto.InternalMessageInfo

func (m *MorseModuleAccount) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MorseModuleAccount) GetPermissions() []string {
	if m != nil {
		return m.Permissions
	}
	return nil
}

func init() {
	proto.RegisterType((*MorseStateExport)(nil), "pocket.migration.MorseStateExport")
	proto.RegisterType((*MorseTendermintAppState)(nil), "pocket.migration.MorseTendermintAppState")
	proto.RegisterType((*MorseApplications)(nil), "pocket.migration.MorseApplications")
	proto.RegisterType((*MorseAuth)(nil), "pocket.migration.MorseAuth")
	proto.RegisterType((*MorseAuthAccount)(nil), "pocket.migration.MorseAuthAccount")
	proto.RegisterType((*MorsePos)(nil), "pocket.migration.MorsePos")
	proto.RegisterType((*MorseApplication)(nil), "pocket.migration.MorseApplication")
	proto.RegisterType((*MorseValidator)(nil), "pocket.migration.MorseValidator")
	proto.RegisterType((*MorseAccount)(nil), "pocket.migration.MorseAccount")
	proto.RegisterType((*MorsePublicKey)(nil), "pocket.migration.MorsePublicKey")
	proto.RegisterType((*MorseModuleAccount)(nil), "pocket.migration.MorseModuleAccount")
}

func init() {
	proto.RegisterFile("pocket/migration/morse_offchain.proto", fileDescriptor_d432b9bbab37e9d7)
}

var fileDescriptor_d432b9bbab37e9d7 = []byte{
	// 1032 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x56, 0xcf, 0x6b, 0x1b, 0xc7,
	0x17, 0xd7, 0xfa, 0x97, 0xa4, 0x91, 0xec, 0xaf, 0x3d, 0xdf, 0x80, 0x15, 0x27, 0x68, 0xcc, 0x24,
	0xa1, 0x2e, 0x21, 0x5a, 0xac, 0xe0, 0x42, 0x7c, 0x28, 0x78, 0xdb, 0x52, 0xd3, 0x26, 0x60, 0xa6,
	0x6e, 0x48, 0x4b, 0xa9, 0x19, 0xad, 0xd6, 0xd6, 0x56, 0xda, 0x9d, 0x65, 0x77, 0xd6, 0x8d, 0xff,
	0x83, 0x5c, 0x0a, 0xa5, 0xa7, 0x5e, 0x0a, 0xa6, 0x7f, 0x43, 0xff, 0x83, 0x5e, 0x42, 0x4f, 0x3e,
	0xe6, 0x34, 0x14, 0xfb, 0x52, 0xf6, 0xa8, 0x63, 0x0e, 0xa5, 0xcc, 0x8f, 0x5d, 0xad, 0xed, 0x88,
	0x84, 0xde, 0x7a, 0x59, 0xcd, 0x7b, 0xf3, 0xf9, 0xcc, 0x7b, 0xf3, 0x99, 0x37, 0xf3, 0x04, 0xee,
	0x45, 0xcc, 0x1d, 0x7a, 0xdc, 0x0e, 0xfc, 0xa3, 0x98, 0x72, 0x9f, 0x85, 0x76, 0xc0, 0xe2, 0xc4,
	0x3b, 0x60, 0x87, 0x87, 0xee, 0x80, 0xfa, 0x61, 0x27, 0x8a, 0x19, 0x67, 0x70, 0x59, 0xc3, 0x3a,
	0x05, 0x6c, 0xed, 0xc6, 0x11, 0x3b, 0x62, 0x6a, 0xd2, 0x96, 0x23, 0x8d, 0x5b, 0xbb, 0xe9, 0xb2,
	0x24, 0x60, 0xc9, 0x81, 0x9e, 0xd0, 0x86, 0x99, 0x6a, 0x6b, 0xcb, 0xee, 0xd1, 0xc4, 0xb3, 0x8f,
	0x37, 0x7b, 0x1e, 0xa7, 0x9b, 0xb6, 0xcb, 0xf2, 0x10, 0x6b, 0x77, 0xa7, 0x65, 0x12, 0x96, 0x12,
	0xc1, 0x3f, 0x59, 0x60, 0xf9, 0x89, 0xf4, 0x7f, 0xc1, 0x29, 0xf7, 0x3e, 0x79, 0x1e, 0xb1, 0x98,
	0xc3, 0xf7, 0x40, 0x8d, 0x46, 0xd1, 0xc1, 0x80, 0x26, 0x83, 0x96, 0xb5, 0x6e, 0x6d, 0xd4, 0x9d,
	0x66, 0x26, 0x50, 0xe1, 0x23, 0x55, 0x1a, 0x45, 0xbb, 0x34, 0x19, 0xc0, 0x2f, 0x41, 0x5d, 0x3a,
	0x13, 0xc9, 0x6d, 0xcd, 0xac, 0x5b, 0x1b, 0x8d, 0xee, 0xfb, 0x9d, 0xab, 0x5b, 0xeb, 0xa8, 0xf5,
	0xf7, 0xbd, 0xb0, 0xef, 0xc5, 0x81, 0x1f, 0xf2, 0x9d, 0x28, 0x52, 0xc1, 0x9c, 0xc5, 0x4c, 0xa0,
	0x09, 0x9f, 0xc8, 0xf5, 0xd5, 0x04, 0xbe, 0xb0, 0xc0, 0xea, 0x14, 0x12, 0x7c, 0x0a, 0x1a, 0x34,
	0x8a, 0x46, 0xbe, 0xab, 0xd6, 0x56, 0xe9, 0x35, 0xba, 0x77, 0xa6, 0x04, 0xdd, 0x99, 0x20, 0x13,
	0xe7, 0x7f, 0x99, 0x40, 0x65, 0x2e, 0x29, 0x1b, 0xf0, 0x11, 0x98, 0xa3, 0x29, 0x1f, 0x98, 0x5d,
	0xdc, 0x9a, 0xb6, 0x60, 0xca, 0x07, 0x4e, 0x2d, 0x13, 0x48, 0x81, 0x89, 0xfa, 0xc2, 0x2d, 0x30,
	0x1b, 0xb1, 0xa4, 0x35, 0xab, 0x98, 0x6b, 0x53, 0x98, 0x7b, 0x2c, 0x71, 0xaa, 0x99, 0x40, 0x12,
	0x4a, 0xe4, 0x07, 0x07, 0x60, 0xe5, 0x5a, 0x92, 0xf0, 0x19, 0x68, 0x96, 0xb2, 0x4a, 0x5a, 0xd6,
	0xfa, 0xec, 0x46, 0xa3, 0x8b, 0xdf, 0xbe, 0x3f, 0x67, 0x39, 0x13, 0xe8, 0x12, 0x97, 0x5c, 0xb2,
	0xf0, 0x57, 0xa0, 0x5e, 0x6c, 0x01, 0x3e, 0x06, 0x35, 0xea, 0xba, 0x2c, 0x0d, 0xf9, 0x5b, 0x43,
	0xa4, 0x7c, 0xb0, 0xa3, 0xa1, 0xa6, 0x0a, 0x0c, 0x8f, 0x14, 0x23, 0xfc, 0xc3, 0x8c, 0x29, 0xa2,
	0x12, 0x18, 0xde, 0x06, 0x73, 0xfc, 0x24, 0xf2, 0x4c, 0x01, 0x29, 0xcd, 0xa4, 0x4d, 0xd4, 0x17,
	0x3e, 0x03, 0x8b, 0xba, 0x1c, 0xcd, 0x22, 0x46, 0xbd, 0xf6, 0xb4, 0x2c, 0x4c, 0x06, 0x2b, 0x99,
	0x40, 0x97, 0x89, 0xbb, 0x15, 0xd2, 0x0c, 0x4a, 0x10, 0x18, 0x83, 0x1b, 0x1a, 0x10, 0xb0, 0x7e,
	0x3a, 0x9a, 0x04, 0x98, 0x53, 0x01, 0xee, 0x4e, 0x09, 0xf0, 0x44, 0x81, 0xf3, 0x30, 0xad, 0x4c,
	0xa0, 0x37, 0xae, 0xb2, 0x5b, 0x21, 0x30, 0xb8, 0x8e, 0xaf, 0x82, 0xf9, 0x63, 0x3a, 0x4a, 0xbd,
	0xcf, 0xe6, 0x6a, 0x33, 0xcb, 0xb3, 0xf8, 0x1b, 0x50, 0xcb, 0xcf, 0x1c, 0xee, 0x01, 0x70, 0x4c,
	0x47, 0x7e, 0x9f, 0x72, 0x16, 0xe7, 0x5a, 0xaf, 0x4f, 0x49, 0xe2, 0x69, 0x0e, 0x74, 0x96, 0x32,
	0x81, 0x4a, 0x3c, 0x52, 0x1a, 0xe3, 0xac, 0x50, 0xbb, 0x54, 0xbe, 0x87, 0xa0, 0x4a, 0xfb, 0xfd,
	0xd8, 0x4b, 0x12, 0x25, 0x78, 0xd3, 0x79, 0x9c, 0x09, 0x94, 0xbb, 0xc6, 0x02, 0x2d, 0x9d, 0xd0,
	0x60, 0xb4, 0x8d, 0x8d, 0x03, 0xbf, 0x16, 0xe8, 0xfe, 0x91, 0xcf, 0x07, 0x69, 0xaf, 0xe3, 0xb2,
	0xc0, 0x76, 0x59, 0xe0, 0xf1, 0xde, 0x21, 0x2f, 0x0d, 0xe2, 0x93, 0x88, 0xb3, 0xce, 0x8e, 0xc6,
	0x93, 0x7c, 0x25, 0xe8, 0x00, 0x10, 0xa5, 0xbd, 0x91, 0xef, 0x1e, 0x0c, 0xbd, 0x13, 0x75, 0x59,
	0x9a, 0xce, 0x1d, 0x99, 0xec, 0xc4, 0x3b, 0x16, 0x68, 0x45, 0x47, 0x9b, 0xf8, 0x30, 0xa9, 0x6b,
	0xe3, 0x73, 0xef, 0x04, 0x3e, 0x04, 0x0b, 0xdf, 0x51, 0x7f, 0xe4, 0xf5, 0xd5, 0xa1, 0xd7, 0x9c,
	0x5b, 0x99, 0x40, 0xc6, 0x33, 0x16, 0x68, 0x51, 0x73, 0xb5, 0x8d, 0x89, 0x99, 0x90, 0x24, 0xf9,
	0x4c, 0xa4, 0x89, 0x3a, 0xc8, 0x79, 0x4d, 0xd2, 0x9e, 0x09, 0x49, 0xdb, 0x98, 0x98, 0x09, 0xf8,
	0x01, 0x58, 0x4c, 0x38, 0x1d, 0x7a, 0xfd, 0x03, 0xce, 0x86, 0x5e, 0x98, 0xb4, 0x16, 0x54, 0x31,
	0xaa, 0x2a, 0xba, 0x34, 0x41, 0x9a, 0xda, 0xdc, 0x57, 0xd6, 0x76, 0xed, 0xc5, 0x29, 0xaa, 0xfc,
	0x75, 0x8a, 0x2c, 0xfc, 0xfb, 0x0c, 0x58, 0xba, 0x7c, 0x36, 0xff, 0x29, 0xa9, 0xf1, 0x15, 0xa9,
	0xc1, 0x44, 0xea, 0x42, 0x59, 0x7c, 0x45, 0x59, 0x30, 0x51, 0xb6, 0x10, 0xd2, 0xbe, 0x2a, 0x64,
	0x55, 0x09, 0xa9, 0xa0, 0x6f, 0x54, 0xb0, 0x29, 0x15, 0xfc, 0xf9, 0x14, 0x59, 0x4a, 0xc5, 0x5f,
	0x66, 0x40, 0xb3, 0x7c, 0x8f, 0xe1, 0xfe, 0x55, 0x0d, 0xb7, 0x4b, 0x1a, 0xfe, 0x6b, 0xc5, 0xbe,
	0x05, 0xd5, 0x28, 0xed, 0x15, 0x72, 0x4d, 0xbf, 0x68, 0x7b, 0xb9, 0x40, 0xef, 0x26, 0xe8, 0x42,
	0x94, 0xf6, 0xa4, 0x9a, 0x1f, 0x82, 0x79, 0xd9, 0x60, 0xe5, 0x53, 0x2f, 0xaf, 0xf1, 0xcd, 0x8e,
	0x69, 0xc8, 0xb2, 0x05, 0x77, 0x4c, 0x0b, 0xee, 0x7c, 0xc4, 0xfc, 0xd0, 0x59, 0x7c, 0x29, 0x50,
	0x25, 0x13, 0x48, 0xe3, 0x89, 0xfe, 0xd9, 0x5e, 0xcd, 0x45, 0x79, 0xf1, 0x2b, 0xb2, 0xfe, 0xf8,
	0xed, 0x41, 0xd5, 0xc8, 0x81, 0x3f, 0x36, 0x45, 0x56, 0xe4, 0x05, 0xbb, 0xe6, 0x45, 0x31, 0xe7,
	0x7e, 0xfb, 0xb5, 0x40, 0x2d, 0xbd, 0x6d, 0xdb, 0xeb, 0x77, 0xb7, 0xb6, 0x36, 0x1f, 0x75, 0x0a,
	0x30, 0xd1, 0x50, 0xfc, 0xb7, 0x05, 0xe0, 0xf5, 0xc7, 0x0c, 0xc6, 0xa0, 0x29, 0x13, 0x2c, 0x1e,
	0x42, 0xeb, 0x9d, 0x5e, 0x5a, 0x5b, 0xee, 0xe0, 0x4c, 0x20, 0x4b, 0xb6, 0x95, 0x32, 0x7f, 0x2c,
	0xd0, 0xff, 0xb5, 0x44, 0x65, 0x2f, 0x26, 0x0d, 0x69, 0xe6, 0x31, 0xef, 0x83, 0xb9, 0x90, 0x06,
	0x3a, 0xfb, 0xba, 0xb3, 0x2a, 0x1f, 0x7f, 0x69, 0x8f, 0x05, 0x6a, 0x68, 0xae, 0xb4, 0x30, 0x51,
	0x4e, 0xf8, 0x29, 0x68, 0x44, 0xb2, 0xcb, 0x27, 0x89, 0x6a, 0x79, 0x52, 0xdc, 0xba, 0x73, 0x4f,
	0x76, 0xeb, 0x92, 0x7b, 0x2c, 0x10, 0x34, 0x27, 0x33, 0x71, 0x62, 0x52, 0x86, 0x38, 0x7b, 0x2f,
	0xcf, 0xdb, 0xd6, 0xd9, 0x79, 0xdb, 0x7a, 0x75, 0xde, 0xb6, 0xfe, 0x3c, 0x6f, 0x5b, 0x3f, 0x5e,
	0xb4, 0x2b, 0x67, 0x17, 0xed, 0xca, 0xab, 0x8b, 0x76, 0xe5, 0xeb, 0x6e, 0xa9, 0xa6, 0x22, 0x36,
	0xe4, 0x0f, 0x42, 0x8f, 0x7f, 0xcf, 0xe2, 0xa1, 0x32, 0x62, 0x36, 0x1a, 0xd9, 0xcf, 0x4b, 0x7f,
	0x96, 0x64, 0x97, 0x4a, 0x7a, 0x0b, 0xea, 0x5f, 0xd2, 0xc3, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff,
	0x9e, 0x09, 0xce, 0xaf, 0xd7, 0x09, 0x00, 0x00,
}

func (this *MorseApplication) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MorseApplication)
	if !ok {
		that2, ok := that.(MorseApplication)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Address, that1.Address) {
		return false
	}
	if !bytes.Equal(this.PublicKey, that1.PublicKey) {
		return false
	}
	if this.Jailed != that1.Jailed {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.StakedTokens != that1.StakedTokens {
		return false
	}
	return true
}
func (this *MorseValidator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MorseValidator)
	if !ok {
		that2, ok := that.(MorseValidator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Address, that1.Address) {
		return false
	}
	if !bytes.Equal(this.PublicKey, that1.PublicKey) {
		return false
	}
	if this.Jailed != that1.Jailed {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.StakedTokens != that1.StakedTokens {
		return false
	}
	return true
}
func (m *MorseStateExport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MorseStateExport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MorseStateExport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AppState != nil {
		{
			size, err := m.AppState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMorseOffchain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.AppHash) > 0 {
		i -= len(m.AppHash)
		copy(dAtA[i:], m.AppHash)
		i = encodeVarintMorseOffchain(dAtA, i, uint64(len(m.AppHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MorseTendermintAppState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MorseTendermintAppState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MorseTendermintAppState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pos != nil {
		{
			size, err := m.Pos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMorseOffchain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Auth != nil {
		{
			size, err := m.Auth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMorseOffchain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Application != nil {
		{
			size, err := m.Application.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMorseOffchain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MorseApplications) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MorseApplications) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MorseApplications) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Applications) > 0 {
		for iNdEx := len(m.Applications) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Applications[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMorseOffchain(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MorseAuth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MorseAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MorseAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Accounts) > 0 {
		for iNdEx := len(m.Accounts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Accounts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMorseOffchain(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MorseAuthAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MorseAuthAccount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MorseAuthAccount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintMorseOffchain(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MorseAuthAccount_MorseAccount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MorseAuthAccount_MorseAccount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MorseAccount != nil {
		{
			size, err := m.MorseAccount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMorseOffchain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *MorseAuthAccount_MorseModuleAccount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MorseAuthAccount_MorseModuleAccount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MorseModuleAccount != nil {
		{
			size, err := m.MorseModuleAccount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMorseOffchain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *MorsePos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MorsePos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MorsePos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Validators) > 0 {
		for iNdEx := len(m.Validators) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Validators[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMorseOffchain(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MorseApplication) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MorseApplication) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MorseApplication) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StakedTokens) > 0 {
		i -= len(m.StakedTokens)
		copy(dAtA[i:], m.StakedTokens)
		i = encodeVarintMorseOffchain(dAtA, i, uint64(len(m.StakedTokens)))
		i--
		dAtA[i] = 0x32
	}
	if m.Status != 0 {
		i = encodeVarintMorseOffchain(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if m.Jailed {
		i--
		if m.Jailed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintMorseOffchain(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintMorseOffchain(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MorseValidator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MorseValidator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MorseValidator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StakedTokens) > 0 {
		i -= len(m.StakedTokens)
		copy(dAtA[i:], m.StakedTokens)
		i = encodeVarintMorseOffchain(dAtA, i, uint64(len(m.StakedTokens)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Status != 0 {
		i = encodeVarintMorseOffchain(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if m.Jailed {
		i--
		if m.Jailed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintMorseOffchain(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintMorseOffchain(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MorseAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MorseAccount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MorseAccount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Coins) > 0 {
		for iNdEx := len(m.Coins) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Coins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMorseOffchain(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.PubKey != nil {
		{
			size, err := m.PubKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMorseOffchain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintMorseOffchain(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MorsePublicKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MorsePublicKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MorsePublicKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintMorseOffchain(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *MorseModuleAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MorseModuleAccount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MorseModuleAccount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Permissions) > 0 {
		for iNdEx := len(m.Permissions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Permissions[iNdEx])
			copy(dAtA[i:], m.Permissions[iNdEx])
			i = encodeVarintMorseOffchain(dAtA, i, uint64(len(m.Permissions[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMorseOffchain(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.MorseAccount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMorseOffchain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintMorseOffchain(dAtA []byte, offset int, v uint64) int {
	offset -= sovMorseOffchain(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MorseStateExport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppHash)
	if l > 0 {
		n += 1 + l + sovMorseOffchain(uint64(l))
	}
	if m.AppState != nil {
		l = m.AppState.Size()
		n += 1 + l + sovMorseOffchain(uint64(l))
	}
	return n
}

func (m *MorseTendermintAppState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Application != nil {
		l = m.Application.Size()
		n += 1 + l + sovMorseOffchain(uint64(l))
	}
	if m.Auth != nil {
		l = m.Auth.Size()
		n += 1 + l + sovMorseOffchain(uint64(l))
	}
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovMorseOffchain(uint64(l))
	}
	return n
}

func (m *MorseApplications) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Applications) > 0 {
		for _, e := range m.Applications {
			l = e.Size()
			n += 1 + l + sovMorseOffchain(uint64(l))
		}
	}
	return n
}

func (m *MorseAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Accounts) > 0 {
		for _, e := range m.Accounts {
			l = e.Size()
			n += 1 + l + sovMorseOffchain(uint64(l))
		}
	}
	return n
}

func (m *MorseAuthAccount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovMorseOffchain(uint64(l))
	}
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *MorseAuthAccount_MorseAccount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MorseAccount != nil {
		l = m.MorseAccount.Size()
		n += 1 + l + sovMorseOffchain(uint64(l))
	}
	return n
}
func (m *MorseAuthAccount_MorseModuleAccount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MorseModuleAccount != nil {
		l = m.MorseModuleAccount.Size()
		n += 1 + l + sovMorseOffchain(uint64(l))
	}
	return n
}
func (m *MorsePos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Validators) > 0 {
		for _, e := range m.Validators {
			l = e.Size()
			n += 1 + l + sovMorseOffchain(uint64(l))
		}
	}
	return n
}

func (m *MorseApplication) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovMorseOffchain(uint64(l))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovMorseOffchain(uint64(l))
	}
	if m.Jailed {
		n += 2
	}
	if m.Status != 0 {
		n += 1 + sovMorseOffchain(uint64(m.Status))
	}
	l = len(m.StakedTokens)
	if l > 0 {
		n += 1 + l + sovMorseOffchain(uint64(l))
	}
	return n
}

func (m *MorseValidator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovMorseOffchain(uint64(l))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovMorseOffchain(uint64(l))
	}
	if m.Jailed {
		n += 2
	}
	if m.Status != 0 {
		n += 1 + sovMorseOffchain(uint64(m.Status))
	}
	l = len(m.StakedTokens)
	if l > 0 {
		n += 1 + l + sovMorseOffchain(uint64(l))
	}
	return n
}

func (m *MorseAccount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovMorseOffchain(uint64(l))
	}
	if m.PubKey != nil {
		l = m.PubKey.Size()
		n += 1 + l + sovMorseOffchain(uint64(l))
	}
	if len(m.Coins) > 0 {
		for _, e := range m.Coins {
			l = e.Size()
			n += 1 + l + sovMorseOffchain(uint64(l))
		}
	}
	return n
}

func (m *MorsePublicKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMorseOffchain(uint64(l))
	}
	return n
}

func (m *MorseModuleAccount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.MorseAccount.Size()
	n += 1 + l + sovMorseOffchain(uint64(l))
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMorseOffchain(uint64(l))
	}
	if len(m.Permissions) > 0 {
		for _, s := range m.Permissions {
			l = len(s)
			n += 1 + l + sovMorseOffchain(uint64(l))
		}
	}
	return n
}

func sovMorseOffchain(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMorseOffchain(x uint64) (n int) {
	return sovMorseOffchain(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MorseStateExport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMorseOffchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MorseStateExport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MorseStateExport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AppState == nil {
				m.AppState = &MorseTendermintAppState{}
			}
			if err := m.AppState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMorseOffchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MorseTendermintAppState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMorseOffchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MorseTendermintAppState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MorseTendermintAppState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Application", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Application == nil {
				m.Application = &MorseApplications{}
			}
			if err := m.Application.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Auth == nil {
				m.Auth = &MorseAuth{}
			}
			if err := m.Auth.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &MorsePos{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMorseOffchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MorseApplications) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMorseOffchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MorseApplications: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MorseApplications: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Applications", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Applications = append(m.Applications, &MorseApplication{})
			if err := m.Applications[len(m.Applications)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMorseOffchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MorseAuth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMorseOffchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MorseAuth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MorseAuth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Accounts = append(m.Accounts, &MorseAuthAccount{})
			if err := m.Accounts[len(m.Accounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMorseOffchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MorseAuthAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMorseOffchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MorseAuthAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MorseAuthAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MorseAccount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MorseAccount{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &MorseAuthAccount_MorseAccount{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MorseModuleAccount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MorseModuleAccount{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &MorseAuthAccount_MorseModuleAccount{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMorseOffchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MorsePos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMorseOffchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MorsePos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MorsePos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validators = append(m.Validators, &MorseValidator{})
			if err := m.Validators[len(m.Validators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMorseOffchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MorseApplication) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMorseOffchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MorseApplication: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MorseApplication: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jailed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Jailed = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakedTokens", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakedTokens = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMorseOffchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MorseValidator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMorseOffchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MorseValidator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MorseValidator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jailed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Jailed = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakedTokens", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakedTokens = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMorseOffchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MorseAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMorseOffchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MorseAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MorseAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PubKey == nil {
				m.PubKey = &MorsePublicKey{}
			}
			if err := m.PubKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coins", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coins = append(m.Coins, types.Coin{})
			if err := m.Coins[len(m.Coins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMorseOffchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MorsePublicKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMorseOffchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MorsePublicKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MorsePublicKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMorseOffchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MorseModuleAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMorseOffchain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MorseModuleAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MorseModuleAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MorseAccount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MorseAccount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Permissions = append(m.Permissions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMorseOffchain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMorseOffchain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMorseOffchain(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMorseOffchain
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMorseOffchain
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMorseOffchain
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMorseOffchain
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMorseOffchain
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMorseOffchain        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMorseOffchain          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMorseOffchain = fmt.Errorf("proto: unexpected end of group")
)
