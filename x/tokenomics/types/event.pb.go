// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pocket/tokenomics/event.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	types "github.com/pokt-network/poktroll/x/proof/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// TODO_CONSIDERATION: Consider prefixing these enums with CLAIM_EXPIRATION_REASON_
type ClaimExpirationReason int32

const (
	// Default value, means may be valid
	ClaimExpirationReason_EXPIRATION_REASON_UNSPECIFIED ClaimExpirationReason = 0
	// A proof was required but not submitted
	ClaimExpirationReason_PROOF_MISSING ClaimExpirationReason = 1
	// A proof was submitted but was invalid
	ClaimExpirationReason_PROOF_INVALID ClaimExpirationReason = 2
)

var ClaimExpirationReason_name = map[int32]string{
	0: "EXPIRATION_REASON_UNSPECIFIED",
	1: "PROOF_MISSING",
	2: "PROOF_INVALID",
}

var ClaimExpirationReason_value = map[string]int32{
	"EXPIRATION_REASON_UNSPECIFIED": 0,
	"PROOF_MISSING":                 1,
	"PROOF_INVALID":                 2,
}

func (x ClaimExpirationReason) String() string {
	return proto.EnumName(ClaimExpirationReason_name, int32(x))
}

func (ClaimExpirationReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_146818b9f891ddf6, []int{0}
}

// EventClaimExpired is emitted during settlement when a claim expires.
// This is likely the result of a claim requiring an onchain proof not being submitted.
// The claim cannot be settled, leading to that work never being rewarded.
type EventClaimExpired struct {
	// The reason why the claim expired, leading to a Supplier being penalized (i.e. burn).
	ExpirationReason ClaimExpirationReason `protobuf:"varint,2,opt,name=expiration_reason,json=expirationReason,proto3,enum=pocket.tokenomics.ClaimExpirationReason" json:"expiration_reason"`
	// Number of relays claimed to be in the session tree.
	NumRelays uint64 `protobuf:"varint,3,opt,name=num_relays,json=numRelays,proto3" json:"num_relays"`
	// Number of compute units claimed in the session tree.
	// It is a function of the number of relays in the session tree and onchain parameters.
	NumClaimedComputeUnits uint64 `protobuf:"varint,4,opt,name=num_claimed_compute_units,json=numClaimedComputeUnits,proto3" json:"num_claimed_compute_units"`
	// Number of total estimated compute units of work done.
	// It is a function of the number of claimed compute units and the relay difficulty multiplier.
	NumEstimatedComputeUnits uint64 `protobuf:"varint,5,opt,name=num_estimated_compute_units,json=numEstimatedComputeUnits,proto3" json:"num_estimated_compute_units"`
	// The amount of uPOKT claimed for the work done.
	// It is a function of the number of estimated compute units and the compute units to token multiplier.
	ClaimedUpokt string `protobuf:"bytes,7,opt,name=claimed_upokt,json=claimedUpokt,proto3" json:"claimed_upokt"`
	// The Service ID to which the claim corresponds.
	ServiceId string `protobuf:"bytes,8,opt,name=service_id,json=serviceId,proto3" json:"service_id,omitempty"`
	// The address of the application which participated in the claimed session.
	ApplicationAddress string `protobuf:"bytes,9,opt,name=application_address,json=applicationAddress,proto3" json:"application_address,omitempty"`
	// The end block height of the session to which the claim corresponds.
	SessionEndBlockHeight int64 `protobuf:"varint,10,opt,name=session_end_block_height,json=sessionEndBlockHeight,proto3" json:"session_end_block_height,omitempty"`
	// The validation status of the claim.
	// DEV_NOTE: This field uses the integer representation of the ClaimProofStatus
	// enum to minimize onchain disk utilization. This is necessary because event
	// data is not always protobuf-encoded in the various places and formats that it
	// appears in onchain leveldb databases.
	// Enum values:
	//   PENDING_VALIDATION = 0;
	//   VALIDATED = 1;
	//   INVALID = 2;
	ClaimProofStatusInt int32 `protobuf:"varint,11,opt,name=claim_proof_status_int,json=claimProofStatusInt,proto3" json:"claim_proof_status_int,omitempty"`
}

func (m *EventClaimExpired) Reset()         { *m = EventClaimExpired{} }
func (m *EventClaimExpired) String() string { return proto.CompactTextString(m) }
func (*EventClaimExpired) ProtoMessage()    {}
func (*EventClaimExpired) Descriptor() ([]byte, []int) {
	return fileDescriptor_146818b9f891ddf6, []int{0}
}
func (m *EventClaimExpired) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventClaimExpired) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EventClaimExpired) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventClaimExpired.Merge(m, src)
}
func (m *EventClaimExpired) XXX_Size() int {
	return m.Size()
}
func (m *EventClaimExpired) XXX_DiscardUnknown() {
	xxx_messageInfo_EventClaimExpired.DiscardUnknown(m)
}

var xxx_messageInfo_EventClaimExpired proto.InternalMessageInfo

func (m *EventClaimExpired) GetExpirationReason() ClaimExpirationReason {
	if m != nil {
		return m.ExpirationReason
	}
	return ClaimExpirationReason_EXPIRATION_REASON_UNSPECIFIED
}

func (m *EventClaimExpired) GetNumRelays() uint64 {
	if m != nil {
		return m.NumRelays
	}
	return 0
}

func (m *EventClaimExpired) GetNumClaimedComputeUnits() uint64 {
	if m != nil {
		return m.NumClaimedComputeUnits
	}
	return 0
}

func (m *EventClaimExpired) GetNumEstimatedComputeUnits() uint64 {
	if m != nil {
		return m.NumEstimatedComputeUnits
	}
	return 0
}

func (m *EventClaimExpired) GetClaimedUpokt() string {
	if m != nil {
		return m.ClaimedUpokt
	}
	return ""
}

func (m *EventClaimExpired) GetServiceId() string {
	if m != nil {
		return m.ServiceId
	}
	return ""
}

func (m *EventClaimExpired) GetApplicationAddress() string {
	if m != nil {
		return m.ApplicationAddress
	}
	return ""
}

func (m *EventClaimExpired) GetSessionEndBlockHeight() int64 {
	if m != nil {
		return m.SessionEndBlockHeight
	}
	return 0
}

func (m *EventClaimExpired) GetClaimProofStatusInt() int32 {
	if m != nil {
		return m.ClaimProofStatusInt
	}
	return 0
}

// EventClaimSettled is emitted during settlement whenever a claim is successfully settled.
// It may or may not require a proof depending on various on-chain parameters and other factors.
type EventClaimSettled struct {
	// Whether a proof was required for the claim to be settled.
	ProofRequirement types.ProofRequirementReason `protobuf:"varint,2,opt,name=proof_requirement,json=proofRequirement,proto3,enum=pocket.proof.ProofRequirementReason" json:"proof_requirement"`
	// Number of relays claimed to be in the session tree.
	NumRelays uint64 `protobuf:"varint,3,opt,name=num_relays,json=numRelays,proto3" json:"num_relays"`
	// Number of compute units claimed in the session tree.
	// It is a function of the number of relays in the session tree and onchain parameters.
	NumClaimedComputeUnits uint64 `protobuf:"varint,4,opt,name=num_claimed_compute_units,json=numClaimedComputeUnits,proto3" json:"num_claimed_compute_units"`
	// Number of estimated compute units claimed in the session tree.
	// It is a function of the number of claimed compute units and the relay difficulty multiplier for the particular service.
	NumEstimatedComputeUnits uint64 `protobuf:"varint,5,opt,name=num_estimated_compute_units,json=numEstimatedComputeUnits,proto3" json:"num_estimated_compute_units"`
	// The uPOKT coin claimed to be rewarded for the work done as a function of
	// the number of estimated compute units and the compute units to token multiplier.
	ClaimedUpokt string `protobuf:"bytes,8,opt,name=claimed_upokt,json=claimedUpokt,proto3" json:"claimed_upokt"`
	// The Service ID to which the claim corresponds.
	ServiceId string `protobuf:"bytes,9,opt,name=service_id,json=serviceId,proto3" json:"service_id,omitempty"`
	// The address of the application which participated in the claimed session.
	ApplicationAddress string `protobuf:"bytes,10,opt,name=application_address,json=applicationAddress,proto3" json:"application_address,omitempty"`
	// The end block height of the session to which the claim corresponds.
	SessionEndBlockHeight int64 `protobuf:"varint,11,opt,name=session_end_block_height,json=sessionEndBlockHeight,proto3" json:"session_end_block_height,omitempty"`
	// The validation status of the claim.
	// DEV_NOTE: This field uses the integer representation of the ClaimProofStatus
	// enum to minimize onchain disk utilization. This is necessary because event
	// data is not always protobuf-encoded in the various places and formats that it
	// appears in onchain leveldb databases.
	// Enum values:
	//   PENDING_VALIDATION = 0;
	//   VALIDATED = 1;
	//   INVALID = 2;
	ClaimProofStatusInt int32 `protobuf:"varint,12,opt,name=claim_proof_status_int,json=claimProofStatusInt,proto3" json:"claim_proof_status_int,omitempty"`
}

func (m *EventClaimSettled) Reset()         { *m = EventClaimSettled{} }
func (m *EventClaimSettled) String() string { return proto.CompactTextString(m) }
func (*EventClaimSettled) ProtoMessage()    {}
func (*EventClaimSettled) Descriptor() ([]byte, []int) {
	return fileDescriptor_146818b9f891ddf6, []int{1}
}
func (m *EventClaimSettled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventClaimSettled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EventClaimSettled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventClaimSettled.Merge(m, src)
}
func (m *EventClaimSettled) XXX_Size() int {
	return m.Size()
}
func (m *EventClaimSettled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventClaimSettled.DiscardUnknown(m)
}

var xxx_messageInfo_EventClaimSettled proto.InternalMessageInfo

func (m *EventClaimSettled) GetProofRequirement() types.ProofRequirementReason {
	if m != nil {
		return m.ProofRequirement
	}
	return types.ProofRequirementReason_NOT_REQUIRED
}

func (m *EventClaimSettled) GetNumRelays() uint64 {
	if m != nil {
		return m.NumRelays
	}
	return 0
}

func (m *EventClaimSettled) GetNumClaimedComputeUnits() uint64 {
	if m != nil {
		return m.NumClaimedComputeUnits
	}
	return 0
}

func (m *EventClaimSettled) GetNumEstimatedComputeUnits() uint64 {
	if m != nil {
		return m.NumEstimatedComputeUnits
	}
	return 0
}

func (m *EventClaimSettled) GetClaimedUpokt() string {
	if m != nil {
		return m.ClaimedUpokt
	}
	return ""
}

func (m *EventClaimSettled) GetServiceId() string {
	if m != nil {
		return m.ServiceId
	}
	return ""
}

func (m *EventClaimSettled) GetApplicationAddress() string {
	if m != nil {
		return m.ApplicationAddress
	}
	return ""
}

func (m *EventClaimSettled) GetSessionEndBlockHeight() int64 {
	if m != nil {
		return m.SessionEndBlockHeight
	}
	return 0
}

func (m *EventClaimSettled) GetClaimProofStatusInt() int32 {
	if m != nil {
		return m.ClaimProofStatusInt
	}
	return 0
}

// EventApplicationOverserviced is emitted when an Application's stake cannot cover the Supplier's claim.
// This means the following will ALWAYS be strictly true:  effective_burn < expected_burn
// - Number of tokens burnt from app stake < Number of tokens burnt from supplier stake
type EventApplicationOverserviced struct {
	// The application address consuming onchain services
	ApplicationAddr string `protobuf:"bytes,1,opt,name=application_addr,json=applicationAddr,proto3" json:"application_addr,omitempty"`
	// The supplier operator address providing onchain services
	SupplierOperatorAddr string `protobuf:"bytes,2,opt,name=supplier_operator_addr,json=supplierOperatorAddr,proto3" json:"supplier_operator_addr,omitempty"`
	// Expected number of tokens to be burnt from the application's stake.
	// A function of the actual amount of work claimed to be done.
	ExpectedBurn string `protobuf:"bytes,5,opt,name=expected_burn,json=expectedBurn,proto3" json:"expected_burn,omitempty"`
	// Actual number of tokens burnt from the application's stake.
	// A function of the amount that could be covered (less than) relative to the amount of work claimed to be done.
	EffectiveBurn string `protobuf:"bytes,6,opt,name=effective_burn,json=effectiveBurn,proto3" json:"effective_burn,omitempty"`
}

func (m *EventApplicationOverserviced) Reset()         { *m = EventApplicationOverserviced{} }
func (m *EventApplicationOverserviced) String() string { return proto.CompactTextString(m) }
func (*EventApplicationOverserviced) ProtoMessage()    {}
func (*EventApplicationOverserviced) Descriptor() ([]byte, []int) {
	return fileDescriptor_146818b9f891ddf6, []int{2}
}
func (m *EventApplicationOverserviced) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventApplicationOverserviced) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EventApplicationOverserviced) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventApplicationOverserviced.Merge(m, src)
}
func (m *EventApplicationOverserviced) XXX_Size() int {
	return m.Size()
}
func (m *EventApplicationOverserviced) XXX_DiscardUnknown() {
	xxx_messageInfo_EventApplicationOverserviced.DiscardUnknown(m)
}

var xxx_messageInfo_EventApplicationOverserviced proto.InternalMessageInfo

func (m *EventApplicationOverserviced) GetApplicationAddr() string {
	if m != nil {
		return m.ApplicationAddr
	}
	return ""
}

func (m *EventApplicationOverserviced) GetSupplierOperatorAddr() string {
	if m != nil {
		return m.SupplierOperatorAddr
	}
	return ""
}

func (m *EventApplicationOverserviced) GetExpectedBurn() string {
	if m != nil {
		return m.ExpectedBurn
	}
	return ""
}

func (m *EventApplicationOverserviced) GetEffectiveBurn() string {
	if m != nil {
		return m.EffectiveBurn
	}
	return ""
}

// EventSupplierSlashed is emitted when a supplier is slashed.
// This can happen for in cases such as missing or invalid proofs for submitted claims.
type EventSupplierSlashed struct {
	// Amount slashed from the supplier's stake.
	// A function of the claim size, supplier stake, and various onchain parameters.
	ProofMissingPenalty string `protobuf:"bytes,3,opt,name=proof_missing_penalty,json=proofMissingPenalty,proto3" json:"proof_missing_penalty,omitempty"`
	// The Service ID to which the claim corresponds.
	ServiceId string `protobuf:"bytes,4,opt,name=service_id,json=serviceId,proto3" json:"service_id,omitempty"`
	// The address of the application which participated in the claimed session.
	ApplicationAddress string `protobuf:"bytes,5,opt,name=application_address,json=applicationAddress,proto3" json:"application_address,omitempty"`
	// The end block height of the session to which the claim corresponds.
	SessionEndBlockHeight int64 `protobuf:"varint,6,opt,name=session_end_block_height,json=sessionEndBlockHeight,proto3" json:"session_end_block_height,omitempty"`
	// The validation status of the claim.
	// DEV_NOTE: This field uses the integer representation of the ClaimProofStatus
	// enum to minimize onchain disk utilization. This is necessary because event
	// data is not always protobuf-encoded in the various places and formats that it
	// appears in onchain leveldb databases.
	// Enum values:
	//
	//	PENDING_VALIDATION = 0;
	//	VALIDATED = 1;
	//	INVALID = 2;
	ClaimProofStatusInt int32 `protobuf:"varint,7,opt,name=claim_proof_status_int,json=claimProofStatusInt,proto3" json:"claim_proof_status_int,omitempty"`
}

func (m *EventSupplierSlashed) Reset()         { *m = EventSupplierSlashed{} }
func (m *EventSupplierSlashed) String() string { return proto.CompactTextString(m) }
func (*EventSupplierSlashed) ProtoMessage()    {}
func (*EventSupplierSlashed) Descriptor() ([]byte, []int) {
	return fileDescriptor_146818b9f891ddf6, []int{3}
}
func (m *EventSupplierSlashed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSupplierSlashed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EventSupplierSlashed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSupplierSlashed.Merge(m, src)
}
func (m *EventSupplierSlashed) XXX_Size() int {
	return m.Size()
}
func (m *EventSupplierSlashed) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSupplierSlashed.DiscardUnknown(m)
}

var xxx_messageInfo_EventSupplierSlashed proto.InternalMessageInfo

func (m *EventSupplierSlashed) GetProofMissingPenalty() string {
	if m != nil {
		return m.ProofMissingPenalty
	}
	return ""
}

func (m *EventSupplierSlashed) GetServiceId() string {
	if m != nil {
		return m.ServiceId
	}
	return ""
}

func (m *EventSupplierSlashed) GetApplicationAddress() string {
	if m != nil {
		return m.ApplicationAddress
	}
	return ""
}

func (m *EventSupplierSlashed) GetSessionEndBlockHeight() int64 {
	if m != nil {
		return m.SessionEndBlockHeight
	}
	return 0
}

func (m *EventSupplierSlashed) GetClaimProofStatusInt() int32 {
	if m != nil {
		return m.ClaimProofStatusInt
	}
	return 0
}

// EventClaimDiscarded is emitted when a claim is discarded due to unexpected situations.
// It is used to prevent chain halts in favor of some missing claims.
type EventClaimDiscarded struct {
	// The error that caused the claim to be discarded.
	Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// The Service ID to which the claim corresponds.
	ServiceId string `protobuf:"bytes,3,opt,name=service_id,json=serviceId,proto3" json:"service_id,omitempty"`
	// The address of the application which participated in the claimed session.
	ApplicationAddress string `protobuf:"bytes,4,opt,name=application_address,json=applicationAddress,proto3" json:"application_address,omitempty"`
	// The end block height of the session to which the claim corresponds.
	SessionEndBlockHeight int64 `protobuf:"varint,5,opt,name=session_end_block_height,json=sessionEndBlockHeight,proto3" json:"session_end_block_height,omitempty"`
	// The validation status of the claim.
	// DEV_NOTE: This field uses the integer representation of the ClaimProofStatus
	// enum to minimize onchain disk utilization. This is necessary because event
	// data is not always protobuf-encoded in the various places and formats that it
	// appears in onchain leveldb databases.
	// Enum values:
	//
	//	PENDING_VALIDATION = 0;
	//	VALIDATED = 1;
	//	INVALID = 2;
	ClaimProofStatusInt int32 `protobuf:"varint,6,opt,name=claim_proof_status_int,json=claimProofStatusInt,proto3" json:"claim_proof_status_int,omitempty"`
}

func (m *EventClaimDiscarded) Reset()         { *m = EventClaimDiscarded{} }
func (m *EventClaimDiscarded) String() string { return proto.CompactTextString(m) }
func (*EventClaimDiscarded) ProtoMessage()    {}
func (*EventClaimDiscarded) Descriptor() ([]byte, []int) {
	return fileDescriptor_146818b9f891ddf6, []int{4}
}
func (m *EventClaimDiscarded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventClaimDiscarded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EventClaimDiscarded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventClaimDiscarded.Merge(m, src)
}
func (m *EventClaimDiscarded) XXX_Size() int {
	return m.Size()
}
func (m *EventClaimDiscarded) XXX_DiscardUnknown() {
	xxx_messageInfo_EventClaimDiscarded.DiscardUnknown(m)
}

var xxx_messageInfo_EventClaimDiscarded proto.InternalMessageInfo

func (m *EventClaimDiscarded) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *EventClaimDiscarded) GetServiceId() string {
	if m != nil {
		return m.ServiceId
	}
	return ""
}

func (m *EventClaimDiscarded) GetApplicationAddress() string {
	if m != nil {
		return m.ApplicationAddress
	}
	return ""
}

func (m *EventClaimDiscarded) GetSessionEndBlockHeight() int64 {
	if m != nil {
		return m.SessionEndBlockHeight
	}
	return 0
}

func (m *EventClaimDiscarded) GetClaimProofStatusInt() int32 {
	if m != nil {
		return m.ClaimProofStatusInt
	}
	return 0
}

// EventApplicationReimbursementRequest is emitted when an application requests a reimbursement from the DAO.
// It is intended to prevent self dealing attacks when global inflation is enabled.
// TODO_DISTANT_FUTURE: Remove this once global inflation is disabled in perpetuity.
type EventApplicationReimbursementRequest struct {
	// The application address consuming onchain services requesting reimbursement.
	ApplicationAddr string `protobuf:"bytes,1,opt,name=application_addr,json=applicationAddr,proto3" json:"application_addr,omitempty"`
	// The supplier operator address providing onchain services
	SupplierOperatorAddr string `protobuf:"bytes,2,opt,name=supplier_operator_addr,json=supplierOperatorAddr,proto3" json:"supplier_operator_addr,omitempty"`
	// The supplier owner address providing onchain services
	SupplierOwnerAddr string `protobuf:"bytes,3,opt,name=supplier_owner_addr,json=supplierOwnerAddr,proto3" json:"supplier_owner_addr,omitempty"`
	// The service ID associated with the session where a claim was submitted.
	ServiceId string `protobuf:"bytes,4,opt,name=service_id,json=serviceId,proto3" json:"service_id,omitempty"`
	// The session ID associated with the session where a claim was submitted.
	SessionId string `protobuf:"bytes,5,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	// The amount of uPOKT to be reimbursed to the application.
	Amount string `protobuf:"bytes,7,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *EventApplicationReimbursementRequest) Reset()         { *m = EventApplicationReimbursementRequest{} }
func (m *EventApplicationReimbursementRequest) String() string { return proto.CompactTextString(m) }
func (*EventApplicationReimbursementRequest) ProtoMessage()    {}
func (*EventApplicationReimbursementRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_146818b9f891ddf6, []int{5}
}
func (m *EventApplicationReimbursementRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventApplicationReimbursementRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EventApplicationReimbursementRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventApplicationReimbursementRequest.Merge(m, src)
}
func (m *EventApplicationReimbursementRequest) XXX_Size() int {
	return m.Size()
}
func (m *EventApplicationReimbursementRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EventApplicationReimbursementRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EventApplicationReimbursementRequest proto.InternalMessageInfo

func (m *EventApplicationReimbursementRequest) GetApplicationAddr() string {
	if m != nil {
		return m.ApplicationAddr
	}
	return ""
}

func (m *EventApplicationReimbursementRequest) GetSupplierOperatorAddr() string {
	if m != nil {
		return m.SupplierOperatorAddr
	}
	return ""
}

func (m *EventApplicationReimbursementRequest) GetSupplierOwnerAddr() string {
	if m != nil {
		return m.SupplierOwnerAddr
	}
	return ""
}

func (m *EventApplicationReimbursementRequest) GetServiceId() string {
	if m != nil {
		return m.ServiceId
	}
	return ""
}

func (m *EventApplicationReimbursementRequest) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *EventApplicationReimbursementRequest) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func init() {
	proto.RegisterEnum("pocket.tokenomics.ClaimExpirationReason", ClaimExpirationReason_name, ClaimExpirationReason_value)
	proto.RegisterType((*EventClaimExpired)(nil), "pocket.tokenomics.EventClaimExpired")
	proto.RegisterType((*EventClaimSettled)(nil), "pocket.tokenomics.EventClaimSettled")
	proto.RegisterType((*EventApplicationOverserviced)(nil), "pocket.tokenomics.EventApplicationOverserviced")
	proto.RegisterType((*EventSupplierSlashed)(nil), "pocket.tokenomics.EventSupplierSlashed")
	proto.RegisterType((*EventClaimDiscarded)(nil), "pocket.tokenomics.EventClaimDiscarded")
	proto.RegisterType((*EventApplicationReimbursementRequest)(nil), "pocket.tokenomics.EventApplicationReimbursementRequest")
}

func init() { proto.RegisterFile("pocket/tokenomics/event.proto", fileDescriptor_146818b9f891ddf6) }

var fileDescriptor_146818b9f891ddf6 = []byte{
	// 957 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x56, 0x4f, 0x6f, 0xe3, 0x44,
	0x14, 0xaf, 0x53, 0x27, 0x4d, 0x66, 0xdb, 0xe2, 0xb8, 0x7f, 0xe4, 0x5d, 0x68, 0x52, 0xc2, 0x22,
	0x05, 0xa4, 0x26, 0xd2, 0x16, 0xc1, 0xb9, 0x69, 0xb3, 0xe0, 0x8a, 0x6d, 0xca, 0x84, 0xa2, 0x15,
	0x07, 0x8c, 0x6b, 0xbf, 0x26, 0xa3, 0xd8, 0x33, 0xde, 0x99, 0x71, 0xb7, 0xfd, 0x02, 0x08, 0x6e,
	0x48, 0x7c, 0x0f, 0x4e, 0x7c, 0x08, 0x8e, 0x2b, 0x2e, 0xec, 0x29, 0x42, 0xed, 0x2d, 0x9f, 0x02,
	0x79, 0xec, 0x6c, 0xda, 0x64, 0xa1, 0x55, 0x55, 0x4e, 0xdc, 0xe6, 0xbd, 0xdf, 0xef, 0xf7, 0x66,
	0xe6, 0xcd, 0x6f, 0x46, 0x83, 0x36, 0x22, 0xe6, 0x0d, 0x40, 0x36, 0x25, 0x1b, 0x00, 0x65, 0x21,
	0xf1, 0x44, 0x13, 0x4e, 0x81, 0xca, 0x46, 0xc4, 0x99, 0x64, 0x66, 0x39, 0x85, 0x1b, 0x13, 0xf8,
	0xd1, 0x43, 0x8f, 0x89, 0x90, 0x09, 0x47, 0x11, 0x9a, 0x69, 0x90, 0xb2, 0x1f, 0xad, 0xf6, 0x58,
	0x8f, 0xa5, 0xf9, 0x64, 0x94, 0x65, 0xad, 0x6c, 0x8a, 0x88, 0x33, 0x76, 0xd2, 0x94, 0xe7, 0x11,
	0x8c, 0xf9, 0x6f, 0x99, 0xfc, 0x0a, 0x5c, 0xfb, 0x21, 0x8f, 0xca, 0xed, 0x64, 0x31, 0xbb, 0x81,
	0x4b, 0xc2, 0xf6, 0x59, 0x44, 0x38, 0xf8, 0x66, 0x80, 0xca, 0x90, 0x0c, 0x5d, 0x49, 0x18, 0x75,
	0x38, 0xb8, 0x82, 0x51, 0x2b, 0xb7, 0xa9, 0xd5, 0x97, 0x9f, 0xd4, 0x1b, 0x33, 0xcb, 0x6d, 0x4c,
	0xb4, 0x4a, 0x80, 0x15, 0xbf, 0xb5, 0x36, 0x1a, 0x56, 0x67, 0xcb, 0x60, 0x03, 0xa6, 0x88, 0xe6,
	0x16, 0x42, 0x34, 0x0e, 0x1d, 0x0e, 0x81, 0x7b, 0x2e, 0xac, 0xf9, 0x4d, 0xad, 0xae, 0xb7, 0x96,
	0x47, 0xc3, 0xea, 0x95, 0x2c, 0x2e, 0xd1, 0x38, 0xc4, 0x6a, 0x68, 0x3e, 0x47, 0x0f, 0x13, 0xc0,
	0x4b, 0x26, 0x05, 0xdf, 0xf1, 0x58, 0x18, 0xc5, 0x12, 0x9c, 0x98, 0x12, 0x29, 0x2c, 0x5d, 0xa9,
	0x37, 0x46, 0xc3, 0xea, 0x3f, 0x93, 0xf0, 0x3a, 0x8d, 0xc3, 0xdd, 0x14, 0xd9, 0x4d, 0x81, 0xa3,
	0x24, 0x6f, 0x7e, 0x87, 0xde, 0x4d, 0x44, 0x20, 0x24, 0x09, 0x5d, 0x39, 0x53, 0x3b, 0xaf, 0x6a,
	0x57, 0x47, 0xc3, 0xea, 0xbf, 0xd1, 0xb0, 0x45, 0xe3, 0xb0, 0x3d, 0xc6, 0xae, 0xd5, 0xff, 0x14,
	0x2d, 0x8d, 0x17, 0x14, 0x47, 0x6c, 0x20, 0xad, 0x85, 0x4d, 0xad, 0x5e, 0x6a, 0x95, 0x47, 0xc3,
	0xea, 0x75, 0x00, 0x2f, 0x66, 0xe1, 0x51, 0x12, 0x99, 0x1b, 0x08, 0x09, 0xe0, 0xa7, 0xc4, 0x03,
	0x87, 0xf8, 0x56, 0x31, 0x11, 0xe1, 0x52, 0x96, 0xb1, 0x7d, 0xd3, 0x46, 0x2b, 0x6e, 0x14, 0x05,
	0xc4, 0x4b, 0xfb, 0xec, 0xfa, 0x3e, 0x07, 0x21, 0xac, 0x92, 0x2a, 0x6e, 0xfd, 0xf1, 0xdb, 0xd6,
	0x6a, 0xe6, 0xa0, 0x9d, 0x14, 0xe9, 0x4a, 0x4e, 0x68, 0x0f, 0x9b, 0x57, 0x44, 0x19, 0x62, 0x7e,
	0x86, 0x2c, 0x01, 0x42, 0x24, 0x65, 0x80, 0xfa, 0xce, 0x71, 0xc0, 0xbc, 0x81, 0xd3, 0x07, 0xd2,
	0xeb, 0x4b, 0x0b, 0x6d, 0x6a, 0xf5, 0x79, 0xbc, 0x96, 0xe1, 0x6d, 0xea, 0xb7, 0x12, 0xf4, 0x0b,
	0x05, 0x9a, 0xdb, 0x68, 0x5d, 0x2d, 0xd9, 0x51, 0x0e, 0x74, 0x84, 0x74, 0x65, 0x2c, 0x1c, 0x42,
	0xa5, 0xf5, 0x60, 0x53, 0xab, 0xe7, 0xf1, 0x8a, 0x42, 0x0f, 0x13, 0xb0, 0xab, 0x30, 0x9b, 0xca,
	0x7d, 0xbd, 0xa8, 0x19, 0xb9, 0x7d, 0xbd, 0x58, 0x30, 0x16, 0x6a, 0x3f, 0x5e, 0x33, 0x62, 0x17,
	0xa4, 0x0c, 0xc0, 0x37, 0xfb, 0xa8, 0x9c, 0x16, 0xe4, 0xf0, 0x22, 0x26, 0x1c, 0x42, 0xa0, 0x32,
	0x33, 0xe2, 0xe3, 0xb1, 0x11, 0x15, 0xa1, 0xa1, 0x4a, 0xe3, 0x09, 0xeb, 0xaa, 0x09, 0x67, 0x4a,
	0x60, 0x23, 0x9a, 0xa2, 0xff, 0x8f, 0x4d, 0x58, 0xbc, 0x8b, 0x09, 0x4b, 0xb7, 0x34, 0x21, 0xba,
	0x67, 0x13, 0x3e, 0xb8, 0x9b, 0x09, 0x17, 0x6f, 0x65, 0xc2, 0x7d, 0xbd, 0xb8, 0x60, 0x14, 0x6b,
	0x7f, 0x6a, 0xe8, 0x3d, 0x65, 0xc5, 0x9d, 0xc9, 0xda, 0x3a, 0xa7, 0xc0, 0xb3, 0xcd, 0xfa, 0xe6,
	0x47, 0xc8, 0x98, 0xde, 0xab, 0xa5, 0xa9, 0x86, 0xbc, 0x33, 0xb5, 0x1d, 0xf3, 0x13, 0xb4, 0x2e,
	0xe2, 0x24, 0x07, 0xdc, 0x61, 0x11, 0x70, 0x57, 0x32, 0x9e, 0x0a, 0x72, 0x4a, 0xb0, 0x3a, 0x46,
	0x3b, 0x19, 0xa8, 0x54, 0x1f, 0xa0, 0x25, 0x38, 0x8b, 0xc0, 0x4b, 0xce, 0xf5, 0x38, 0xe6, 0x54,
	0x9d, 0x7a, 0x09, 0x2f, 0x8e, 0x93, 0xad, 0x98, 0x53, 0xf3, 0x43, 0xb4, 0x0c, 0x27, 0x27, 0xe0,
	0x49, 0x72, 0x0a, 0x29, 0xab, 0xa0, 0x58, 0x4b, 0x6f, 0xb2, 0x09, 0x6d, 0x5f, 0x2f, 0xce, 0x1b,
	0xfa, 0xbe, 0x5e, 0xd4, 0x8d, 0x7c, 0xed, 0xd7, 0x1c, 0x5a, 0x55, 0x3b, 0xeb, 0x66, 0xb3, 0x76,
	0x03, 0x57, 0xf4, 0xc1, 0x37, 0x9f, 0xa0, 0xb5, 0xb4, 0x67, 0x21, 0x11, 0x82, 0xd0, 0x9e, 0x13,
	0x01, 0x75, 0x03, 0x79, 0xae, 0x2e, 0x42, 0x09, 0xaf, 0x28, 0xf0, 0x59, 0x8a, 0x1d, 0xa6, 0xd0,
	0x94, 0x21, 0xf4, 0x5b, 0x1a, 0x22, 0x7f, 0xcf, 0x86, 0x28, 0xdc, 0xcd, 0x10, 0x0b, 0x37, 0x1b,
	0x22, 0x67, 0xcc, 0xd7, 0x7e, 0xca, 0xa1, 0x95, 0xc9, 0xab, 0xb4, 0x47, 0x84, 0xe7, 0x72, 0x1f,
	0x7c, 0x73, 0x15, 0xe5, 0x81, 0x73, 0x36, 0x3e, 0xc5, 0x34, 0x98, 0xea, 0xc8, 0xfc, 0x2d, 0x3b,
	0xa2, 0xdf, 0x73, 0x47, 0xf2, 0x77, 0xeb, 0x48, 0xe1, 0x86, 0x8e, 0xd4, 0x7e, 0xc9, 0xa1, 0xc7,
	0xd3, 0xd7, 0x02, 0x03, 0x09, 0x8f, 0x63, 0x2e, 0xb2, 0x27, 0xf7, 0x45, 0x0c, 0x42, 0xfe, 0xf7,
	0xd7, 0xa3, 0x81, 0x56, 0x26, 0xaa, 0x97, 0x14, 0x32, 0x49, 0xda, 0xf0, 0xf2, 0x1b, 0x49, 0x82,
	0x28, 0xfe, 0x0d, 0x4e, 0x55, 0x70, 0xda, 0x4c, 0xe2, 0x67, 0x57, 0xad, 0x94, 0x65, 0x6c, 0xdf,
	0x5c, 0x47, 0x05, 0x37, 0x64, 0x71, 0x66, 0x9a, 0x12, 0xce, 0xa2, 0xf4, 0xc9, 0xf8, 0xf8, 0x7b,
	0xb4, 0xf6, 0xd6, 0xef, 0x8f, 0xf9, 0x3e, 0xda, 0x68, 0x3f, 0x3f, 0xb4, 0xf1, 0xce, 0xd7, 0x76,
	0xe7, 0xc0, 0xc1, 0xed, 0x9d, 0x6e, 0xe7, 0xc0, 0x39, 0x3a, 0xe8, 0x1e, 0xb6, 0x77, 0xed, 0xa7,
	0x76, 0x7b, 0xcf, 0x98, 0x33, 0xcb, 0x68, 0xe9, 0x10, 0x77, 0x3a, 0x4f, 0x9d, 0x67, 0x76, 0xb7,
	0x6b, 0x1f, 0x7c, 0x6e, 0x68, 0x93, 0x94, 0x7d, 0xf0, 0xcd, 0xce, 0x97, 0xf6, 0x9e, 0x91, 0x6b,
	0x7d, 0xf5, 0xfb, 0x45, 0x45, 0x7b, 0x75, 0x51, 0xd1, 0x5e, 0x5f, 0x54, 0xb4, 0xbf, 0x2e, 0x2a,
	0xda, 0xcf, 0x97, 0x95, 0xb9, 0x57, 0x97, 0x95, 0xb9, 0xd7, 0x97, 0x95, 0xb9, 0x6f, 0xb7, 0x7b,
	0x44, 0xf6, 0xe3, 0xe3, 0x86, 0xc7, 0xc2, 0x66, 0xf2, 0x4e, 0x6f, 0x51, 0x90, 0x2f, 0x19, 0x1f,
	0xa8, 0x80, 0xb3, 0x20, 0x68, 0x9e, 0xcd, 0xfc, 0xfd, 0x8e, 0x0b, 0xea, 0xf3, 0xb7, 0xfd, 0x77,
	0x00, 0x00, 0x00, 0xff, 0xff, 0xd5, 0x74, 0x8d, 0x5f, 0x9a, 0x0a, 0x00, 0x00,
}

func (m *EventClaimExpired) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventClaimExpired) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventClaimExpired) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClaimProofStatusInt != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.ClaimProofStatusInt))
		i--
		dAtA[i] = 0x58
	}
	if m.SessionEndBlockHeight != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.SessionEndBlockHeight))
		i--
		dAtA[i] = 0x50
	}
	if len(m.ApplicationAddress) > 0 {
		i -= len(m.ApplicationAddress)
		copy(dAtA[i:], m.ApplicationAddress)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ApplicationAddress)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ServiceId) > 0 {
		i -= len(m.ServiceId)
		copy(dAtA[i:], m.ServiceId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ServiceId)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ClaimedUpokt) > 0 {
		i -= len(m.ClaimedUpokt)
		copy(dAtA[i:], m.ClaimedUpokt)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ClaimedUpokt)))
		i--
		dAtA[i] = 0x3a
	}
	if m.NumEstimatedComputeUnits != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.NumEstimatedComputeUnits))
		i--
		dAtA[i] = 0x28
	}
	if m.NumClaimedComputeUnits != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.NumClaimedComputeUnits))
		i--
		dAtA[i] = 0x20
	}
	if m.NumRelays != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.NumRelays))
		i--
		dAtA[i] = 0x18
	}
	if m.ExpirationReason != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.ExpirationReason))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *EventClaimSettled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventClaimSettled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventClaimSettled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClaimProofStatusInt != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.ClaimProofStatusInt))
		i--
		dAtA[i] = 0x60
	}
	if m.SessionEndBlockHeight != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.SessionEndBlockHeight))
		i--
		dAtA[i] = 0x58
	}
	if len(m.ApplicationAddress) > 0 {
		i -= len(m.ApplicationAddress)
		copy(dAtA[i:], m.ApplicationAddress)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ApplicationAddress)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.ServiceId) > 0 {
		i -= len(m.ServiceId)
		copy(dAtA[i:], m.ServiceId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ServiceId)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ClaimedUpokt) > 0 {
		i -= len(m.ClaimedUpokt)
		copy(dAtA[i:], m.ClaimedUpokt)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ClaimedUpokt)))
		i--
		dAtA[i] = 0x42
	}
	if m.NumEstimatedComputeUnits != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.NumEstimatedComputeUnits))
		i--
		dAtA[i] = 0x28
	}
	if m.NumClaimedComputeUnits != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.NumClaimedComputeUnits))
		i--
		dAtA[i] = 0x20
	}
	if m.NumRelays != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.NumRelays))
		i--
		dAtA[i] = 0x18
	}
	if m.ProofRequirement != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.ProofRequirement))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *EventApplicationOverserviced) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventApplicationOverserviced) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventApplicationOverserviced) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EffectiveBurn) > 0 {
		i -= len(m.EffectiveBurn)
		copy(dAtA[i:], m.EffectiveBurn)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.EffectiveBurn)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ExpectedBurn) > 0 {
		i -= len(m.ExpectedBurn)
		copy(dAtA[i:], m.ExpectedBurn)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ExpectedBurn)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SupplierOperatorAddr) > 0 {
		i -= len(m.SupplierOperatorAddr)
		copy(dAtA[i:], m.SupplierOperatorAddr)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.SupplierOperatorAddr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ApplicationAddr) > 0 {
		i -= len(m.ApplicationAddr)
		copy(dAtA[i:], m.ApplicationAddr)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ApplicationAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSupplierSlashed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSupplierSlashed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSupplierSlashed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClaimProofStatusInt != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.ClaimProofStatusInt))
		i--
		dAtA[i] = 0x38
	}
	if m.SessionEndBlockHeight != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.SessionEndBlockHeight))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ApplicationAddress) > 0 {
		i -= len(m.ApplicationAddress)
		copy(dAtA[i:], m.ApplicationAddress)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ApplicationAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ServiceId) > 0 {
		i -= len(m.ServiceId)
		copy(dAtA[i:], m.ServiceId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ServiceId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ProofMissingPenalty) > 0 {
		i -= len(m.ProofMissingPenalty)
		copy(dAtA[i:], m.ProofMissingPenalty)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ProofMissingPenalty)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *EventClaimDiscarded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventClaimDiscarded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventClaimDiscarded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClaimProofStatusInt != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.ClaimProofStatusInt))
		i--
		dAtA[i] = 0x30
	}
	if m.SessionEndBlockHeight != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.SessionEndBlockHeight))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ApplicationAddress) > 0 {
		i -= len(m.ApplicationAddress)
		copy(dAtA[i:], m.ApplicationAddress)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ApplicationAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ServiceId) > 0 {
		i -= len(m.ServiceId)
		copy(dAtA[i:], m.ServiceId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ServiceId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *EventApplicationReimbursementRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventApplicationReimbursementRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventApplicationReimbursementRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SessionId) > 0 {
		i -= len(m.SessionId)
		copy(dAtA[i:], m.SessionId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.SessionId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ServiceId) > 0 {
		i -= len(m.ServiceId)
		copy(dAtA[i:], m.ServiceId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ServiceId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SupplierOwnerAddr) > 0 {
		i -= len(m.SupplierOwnerAddr)
		copy(dAtA[i:], m.SupplierOwnerAddr)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.SupplierOwnerAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SupplierOperatorAddr) > 0 {
		i -= len(m.SupplierOperatorAddr)
		copy(dAtA[i:], m.SupplierOperatorAddr)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.SupplierOperatorAddr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ApplicationAddr) > 0 {
		i -= len(m.ApplicationAddr)
		copy(dAtA[i:], m.ApplicationAddr)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ApplicationAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvent(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvent(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventClaimExpired) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExpirationReason != 0 {
		n += 1 + sovEvent(uint64(m.ExpirationReason))
	}
	if m.NumRelays != 0 {
		n += 1 + sovEvent(uint64(m.NumRelays))
	}
	if m.NumClaimedComputeUnits != 0 {
		n += 1 + sovEvent(uint64(m.NumClaimedComputeUnits))
	}
	if m.NumEstimatedComputeUnits != 0 {
		n += 1 + sovEvent(uint64(m.NumEstimatedComputeUnits))
	}
	l = len(m.ClaimedUpokt)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.ServiceId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.ApplicationAddress)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if m.SessionEndBlockHeight != 0 {
		n += 1 + sovEvent(uint64(m.SessionEndBlockHeight))
	}
	if m.ClaimProofStatusInt != 0 {
		n += 1 + sovEvent(uint64(m.ClaimProofStatusInt))
	}
	return n
}

func (m *EventClaimSettled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProofRequirement != 0 {
		n += 1 + sovEvent(uint64(m.ProofRequirement))
	}
	if m.NumRelays != 0 {
		n += 1 + sovEvent(uint64(m.NumRelays))
	}
	if m.NumClaimedComputeUnits != 0 {
		n += 1 + sovEvent(uint64(m.NumClaimedComputeUnits))
	}
	if m.NumEstimatedComputeUnits != 0 {
		n += 1 + sovEvent(uint64(m.NumEstimatedComputeUnits))
	}
	l = len(m.ClaimedUpokt)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.ServiceId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.ApplicationAddress)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if m.SessionEndBlockHeight != 0 {
		n += 1 + sovEvent(uint64(m.SessionEndBlockHeight))
	}
	if m.ClaimProofStatusInt != 0 {
		n += 1 + sovEvent(uint64(m.ClaimProofStatusInt))
	}
	return n
}

func (m *EventApplicationOverserviced) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ApplicationAddr)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.SupplierOperatorAddr)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.ExpectedBurn)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.EffectiveBurn)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *EventSupplierSlashed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProofMissingPenalty)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.ServiceId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.ApplicationAddress)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if m.SessionEndBlockHeight != 0 {
		n += 1 + sovEvent(uint64(m.SessionEndBlockHeight))
	}
	if m.ClaimProofStatusInt != 0 {
		n += 1 + sovEvent(uint64(m.ClaimProofStatusInt))
	}
	return n
}

func (m *EventClaimDiscarded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.ServiceId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.ApplicationAddress)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if m.SessionEndBlockHeight != 0 {
		n += 1 + sovEvent(uint64(m.SessionEndBlockHeight))
	}
	if m.ClaimProofStatusInt != 0 {
		n += 1 + sovEvent(uint64(m.ClaimProofStatusInt))
	}
	return n
}

func (m *EventApplicationReimbursementRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ApplicationAddr)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.SupplierOperatorAddr)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.SupplierOwnerAddr)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.ServiceId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.SessionId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func sovEvent(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvent(x uint64) (n int) {
	return sovEvent(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventClaimExpired) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventClaimExpired: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventClaimExpired: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationReason", wireType)
			}
			m.ExpirationReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationReason |= ClaimExpirationReason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRelays", wireType)
			}
			m.NumRelays = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRelays |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumClaimedComputeUnits", wireType)
			}
			m.NumClaimedComputeUnits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumClaimedComputeUnits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumEstimatedComputeUnits", wireType)
			}
			m.NumEstimatedComputeUnits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumEstimatedComputeUnits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimedUpokt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClaimedUpokt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicationAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionEndBlockHeight", wireType)
			}
			m.SessionEndBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionEndBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimProofStatusInt", wireType)
			}
			m.ClaimProofStatusInt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClaimProofStatusInt |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventClaimSettled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventClaimSettled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventClaimSettled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofRequirement", wireType)
			}
			m.ProofRequirement = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProofRequirement |= types.ProofRequirementReason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRelays", wireType)
			}
			m.NumRelays = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRelays |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumClaimedComputeUnits", wireType)
			}
			m.NumClaimedComputeUnits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumClaimedComputeUnits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumEstimatedComputeUnits", wireType)
			}
			m.NumEstimatedComputeUnits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumEstimatedComputeUnits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimedUpokt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClaimedUpokt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicationAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionEndBlockHeight", wireType)
			}
			m.SessionEndBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionEndBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimProofStatusInt", wireType)
			}
			m.ClaimProofStatusInt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClaimProofStatusInt |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventApplicationOverserviced) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventApplicationOverserviced: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventApplicationOverserviced: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicationAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplierOperatorAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupplierOperatorAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedBurn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpectedBurn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectiveBurn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EffectiveBurn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSupplierSlashed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSupplierSlashed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSupplierSlashed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofMissingPenalty", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofMissingPenalty = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicationAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionEndBlockHeight", wireType)
			}
			m.SessionEndBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionEndBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimProofStatusInt", wireType)
			}
			m.ClaimProofStatusInt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClaimProofStatusInt |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventClaimDiscarded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventClaimDiscarded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventClaimDiscarded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicationAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionEndBlockHeight", wireType)
			}
			m.SessionEndBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionEndBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimProofStatusInt", wireType)
			}
			m.ClaimProofStatusInt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClaimProofStatusInt |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventApplicationReimbursementRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventApplicationReimbursementRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventApplicationReimbursementRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicationAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplierOperatorAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupplierOperatorAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplierOwnerAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupplierOwnerAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvent(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvent
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvent
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvent
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvent        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvent          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvent = fmt.Errorf("proto: unexpected end of group")
)
