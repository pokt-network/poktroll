// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pocket/tokenomics/event.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_sortkeys "github.com/cosmos/gogoproto/sortkeys"
	_ "github.com/pokt-network/poktroll/x/proof/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// TODO_CONSIDERATION: Consider prefixing these enums with CLAIM_EXPIRATION_REASON_
type ClaimExpirationReason int32

const (
	// Default value, means may be valid
	ClaimExpirationReason_EXPIRATION_REASON_UNSPECIFIED ClaimExpirationReason = 0
	// A proof was required but not submitted
	ClaimExpirationReason_PROOF_MISSING ClaimExpirationReason = 1
	// A proof was submitted but was invalid
	ClaimExpirationReason_PROOF_INVALID ClaimExpirationReason = 2
)

var ClaimExpirationReason_name = map[int32]string{
	0: "EXPIRATION_REASON_UNSPECIFIED",
	1: "PROOF_MISSING",
	2: "PROOF_INVALID",
}

var ClaimExpirationReason_value = map[string]int32{
	"EXPIRATION_REASON_UNSPECIFIED": 0,
	"PROOF_MISSING":                 1,
	"PROOF_INVALID":                 2,
}

func (x ClaimExpirationReason) String() string {
	return proto.EnumName(ClaimExpirationReason_name, int32(x))
}

func (ClaimExpirationReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_146818b9f891ddf6, []int{0}
}

// EventClaimExpired is emitted during settlement when a claim expires.
// This is likely the result of a claim requiring an onchain proof not being submitted.
// The claim cannot be settled, leading to that work never being rewarded.
type EventClaimExpired struct {
	// The reason why the claim expired, leading to a Supplier being penalized (i.e. burn).
	ExpirationReason ClaimExpirationReason `protobuf:"varint,2,opt,name=expiration_reason,json=expirationReason,proto3,enum=pocket.tokenomics.ClaimExpirationReason" json:"expiration_reason"`
	// Number of relays claimed to be in the session tree.
	NumRelays uint64 `protobuf:"varint,3,opt,name=num_relays,json=numRelays,proto3" json:"num_relays"`
	// Number of compute units claimed in the session tree.
	// It is a function of the number of relays in the session tree and onchain parameters.
	NumClaimedComputeUnits uint64 `protobuf:"varint,4,opt,name=num_claimed_compute_units,json=numClaimedComputeUnits,proto3" json:"num_claimed_compute_units"`
	// Number of total estimated compute units of work done.
	// It is a function of the number of claimed compute units and the relay difficulty multiplier.
	NumEstimatedComputeUnits uint64 `protobuf:"varint,5,opt,name=num_estimated_compute_units,json=numEstimatedComputeUnits,proto3" json:"num_estimated_compute_units"`
	// The amount of uPOKT claimed for the work done.
	// It is a function of the number of estimated compute units and the compute units to token multiplier.
	ClaimedUpokt string `protobuf:"bytes,7,opt,name=claimed_upokt,json=claimedUpokt,proto3" json:"claimed_upokt"`
	// The Service ID to which the claim corresponds.
	ServiceId string `protobuf:"bytes,8,opt,name=service_id,json=serviceId,proto3" json:"service_id,omitempty"`
	// The address of the application which participated in the claimed session.
	ApplicationAddress string `protobuf:"bytes,9,opt,name=application_address,json=applicationAddress,proto3" json:"application_address,omitempty"`
	// The end block height of the session to which the claim corresponds.
	SessionEndBlockHeight int64 `protobuf:"varint,10,opt,name=session_end_block_height,json=sessionEndBlockHeight,proto3" json:"session_end_block_height,omitempty"`
	// The validation status of the claim.
	// DEV_NOTE: This field uses the integer representation of the ClaimProofStatus
	// enum to minimize onchain disk utilization. This is necessary because event
	// data is not always protobuf-encoded in the various places and formats that it
	// appears in onchain leveldb databases.
	// Enum values:
	//   PENDING_VALIDATION = 0;
	//   VALIDATED = 1;
	//   INVALID = 2;
	ClaimProofStatusInt int32 `protobuf:"varint,11,opt,name=claim_proof_status_int,json=claimProofStatusInt,proto3" json:"claim_proof_status_int,omitempty"`
	// The operator address of the supplier whose claim expired.
	SupplierOperatorAddress string `protobuf:"bytes,12,opt,name=supplier_operator_address,json=supplierOperatorAddress,proto3" json:"supplier_operator_address,omitempty"`
}

func (m *EventClaimExpired) Reset()         { *m = EventClaimExpired{} }
func (m *EventClaimExpired) String() string { return proto.CompactTextString(m) }
func (*EventClaimExpired) ProtoMessage()    {}
func (*EventClaimExpired) Descriptor() ([]byte, []int) {
	return fileDescriptor_146818b9f891ddf6, []int{0}
}
func (m *EventClaimExpired) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventClaimExpired) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EventClaimExpired) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventClaimExpired.Merge(m, src)
}
func (m *EventClaimExpired) XXX_Size() int {
	return m.Size()
}
func (m *EventClaimExpired) XXX_DiscardUnknown() {
	xxx_messageInfo_EventClaimExpired.DiscardUnknown(m)
}

var xxx_messageInfo_EventClaimExpired proto.InternalMessageInfo

func (m *EventClaimExpired) GetExpirationReason() ClaimExpirationReason {
	if m != nil {
		return m.ExpirationReason
	}
	return ClaimExpirationReason_EXPIRATION_REASON_UNSPECIFIED
}

func (m *EventClaimExpired) GetNumRelays() uint64 {
	if m != nil {
		return m.NumRelays
	}
	return 0
}

func (m *EventClaimExpired) GetNumClaimedComputeUnits() uint64 {
	if m != nil {
		return m.NumClaimedComputeUnits
	}
	return 0
}

func (m *EventClaimExpired) GetNumEstimatedComputeUnits() uint64 {
	if m != nil {
		return m.NumEstimatedComputeUnits
	}
	return 0
}

func (m *EventClaimExpired) GetClaimedUpokt() string {
	if m != nil {
		return m.ClaimedUpokt
	}
	return ""
}

func (m *EventClaimExpired) GetServiceId() string {
	if m != nil {
		return m.ServiceId
	}
	return ""
}

func (m *EventClaimExpired) GetApplicationAddress() string {
	if m != nil {
		return m.ApplicationAddress
	}
	return ""
}

func (m *EventClaimExpired) GetSessionEndBlockHeight() int64 {
	if m != nil {
		return m.SessionEndBlockHeight
	}
	return 0
}

func (m *EventClaimExpired) GetClaimProofStatusInt() int32 {
	if m != nil {
		return m.ClaimProofStatusInt
	}
	return 0
}

func (m *EventClaimExpired) GetSupplierOperatorAddress() string {
	if m != nil {
		return m.SupplierOperatorAddress
	}
	return ""
}

// EventClaimSettled is emitted during settlement whenever a claim is successfully settled.
// It may or may not require a proof depending on various on-chain parameters and other factors.
type EventClaimSettled struct {
	// Whether a proof was required for the claim to be settled.
	// DEV_NOTE: This field uses the integer representation of the ProofRequirementReason
	// enum to minimize onchain disk utilization. This is necessary because event
	// data is not always protobuf-encoded in the various places and formats that it
	// appears in onchain leveldb databases.
	// Enum values:
	//   NOT_REQUIRED = 0;
	//   PROBABILISTIC = 1;
	//   THRESHOLD = 2;
	ProofRequirementInt int32 `protobuf:"varint,2,opt,name=proof_requirement_int,json=proofRequirementInt,proto3" json:"proof_requirement_int,omitempty"`
	// Number of relays claimed to be in the session tree.
	NumRelays uint64 `protobuf:"varint,3,opt,name=num_relays,json=numRelays,proto3" json:"num_relays"`
	// Number of compute units claimed in the session tree.
	// It is a function of the number of relays in the session tree and onchain parameters.
	NumClaimedComputeUnits uint64 `protobuf:"varint,4,opt,name=num_claimed_compute_units,json=numClaimedComputeUnits,proto3" json:"num_claimed_compute_units"`
	// Number of estimated compute units claimed in the session tree.
	// It is a function of the number of claimed compute units and the relay difficulty multiplier for the particular service.
	NumEstimatedComputeUnits uint64 `protobuf:"varint,5,opt,name=num_estimated_compute_units,json=numEstimatedComputeUnits,proto3" json:"num_estimated_compute_units"`
	// The uPOKT coin claimed to be rewarded for the work done as a function of
	// the number of estimated compute units and the compute units to token multiplier.
	ClaimedUpokt string `protobuf:"bytes,8,opt,name=claimed_upokt,json=claimedUpokt,proto3" json:"claimed_upokt"`
	// The Service ID to which the claim corresponds.
	ServiceId string `protobuf:"bytes,9,opt,name=service_id,json=serviceId,proto3" json:"service_id,omitempty"`
	// The address of the application which participated in the claimed session.
	ApplicationAddress string `protobuf:"bytes,10,opt,name=application_address,json=applicationAddress,proto3" json:"application_address,omitempty"`
	// The end block height of the session to which the claim corresponds.
	SessionEndBlockHeight int64 `protobuf:"varint,11,opt,name=session_end_block_height,json=sessionEndBlockHeight,proto3" json:"session_end_block_height,omitempty"`
	// The validation status of the claim.
	// DEV_NOTE: This field uses the integer representation of the ClaimProofStatus
	// enum to minimize onchain disk utilization. This is necessary because event
	// data is not always protobuf-encoded in the various places and formats that it
	// appears in onchain leveldb databases.
	// Enum values:
	//   PENDING_VALIDATION = 0;
	//   VALIDATED = 1;
	//   INVALID = 2;
	ClaimProofStatusInt int32 `protobuf:"varint,12,opt,name=claim_proof_status_int,json=claimProofStatusInt,proto3" json:"claim_proof_status_int,omitempty"`
	// The operator address of the supplier who submitted the claim.
	SupplierOperatorAddress string `protobuf:"bytes,13,opt,name=supplier_operator_address,json=supplierOperatorAddress,proto3" json:"supplier_operator_address,omitempty"`
	// A map of addresses to token amounts corresponding to the distribution of the reward tokens.
	// Deprecated: Use reward_distribution_detailed which preserves OpReason per entry.
	RewardDistribution map[string]string `protobuf:"bytes,14,rep,name=reward_distribution,json=rewardDistribution,proto3" json:"mint_distribution" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Detailed per-reason reward breakdown. Unlike reward_distribution (field 14)
	// which merges all reasons per address, this preserves the OpReason for each entry.
	RewardDistributionDetailed []RewardDistributionDetail `protobuf:"bytes,15,rep,name=reward_distribution_detailed,json=rewardDistributionDetailed,proto3" json:"reward_distribution_detailed"`
	// The actual settlement amount after overservicing cap, before mint_ratio.
	// Indexers can compute: overservicing_loss = claimed_upokt - settled_upokt
	SettledUpokt string `protobuf:"bytes,16,opt,name=settled_upokt,json=settledUpokt,proto3" json:"settled_upokt"`
	// The mint_ratio applied during settlement (from tokenomics params).
	// Indexers can compute: deflation_loss = settled_upokt * (1 - mint_ratio)
	MintRatio string `protobuf:"bytes,17,opt,name=mint_ratio,json=mintRatio,proto3" json:"mint_ratio"`
}

func (m *EventClaimSettled) Reset()         { *m = EventClaimSettled{} }
func (m *EventClaimSettled) String() string { return proto.CompactTextString(m) }
func (*EventClaimSettled) ProtoMessage()    {}
func (*EventClaimSettled) Descriptor() ([]byte, []int) {
	return fileDescriptor_146818b9f891ddf6, []int{1}
}
func (m *EventClaimSettled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventClaimSettled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EventClaimSettled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventClaimSettled.Merge(m, src)
}
func (m *EventClaimSettled) XXX_Size() int {
	return m.Size()
}
func (m *EventClaimSettled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventClaimSettled.DiscardUnknown(m)
}

var xxx_messageInfo_EventClaimSettled proto.InternalMessageInfo

func (m *EventClaimSettled) GetProofRequirementInt() int32 {
	if m != nil {
		return m.ProofRequirementInt
	}
	return 0
}

func (m *EventClaimSettled) GetNumRelays() uint64 {
	if m != nil {
		return m.NumRelays
	}
	return 0
}

func (m *EventClaimSettled) GetNumClaimedComputeUnits() uint64 {
	if m != nil {
		return m.NumClaimedComputeUnits
	}
	return 0
}

func (m *EventClaimSettled) GetNumEstimatedComputeUnits() uint64 {
	if m != nil {
		return m.NumEstimatedComputeUnits
	}
	return 0
}

func (m *EventClaimSettled) GetClaimedUpokt() string {
	if m != nil {
		return m.ClaimedUpokt
	}
	return ""
}

func (m *EventClaimSettled) GetServiceId() string {
	if m != nil {
		return m.ServiceId
	}
	return ""
}

func (m *EventClaimSettled) GetApplicationAddress() string {
	if m != nil {
		return m.ApplicationAddress
	}
	return ""
}

func (m *EventClaimSettled) GetSessionEndBlockHeight() int64 {
	if m != nil {
		return m.SessionEndBlockHeight
	}
	return 0
}

func (m *EventClaimSettled) GetClaimProofStatusInt() int32 {
	if m != nil {
		return m.ClaimProofStatusInt
	}
	return 0
}

func (m *EventClaimSettled) GetSupplierOperatorAddress() string {
	if m != nil {
		return m.SupplierOperatorAddress
	}
	return ""
}

func (m *EventClaimSettled) GetRewardDistribution() map[string]string {
	if m != nil {
		return m.RewardDistribution
	}
	return nil
}

func (m *EventClaimSettled) GetRewardDistributionDetailed() []RewardDistributionDetail {
	if m != nil {
		return m.RewardDistributionDetailed
	}
	return nil
}

func (m *EventClaimSettled) GetSettledUpokt() string {
	if m != nil {
		return m.SettledUpokt
	}
	return ""
}

func (m *EventClaimSettled) GetMintRatio() string {
	if m != nil {
		return m.MintRatio
	}
	return ""
}

// EventApplicationOverserviced is emitted when an Application's stake cannot cover the Supplier's claim.
// This means the following will ALWAYS be strictly true:  effective_burn < expected_burn
// - Number of tokens burnt from app stake < Number of tokens burnt from supplier stake
type EventApplicationOverserviced struct {
	// The application address consuming onchain services
	ApplicationAddr string `protobuf:"bytes,1,opt,name=application_addr,json=applicationAddr,proto3" json:"application_addr,omitempty"`
	// The supplier operator address providing onchain services
	SupplierOperatorAddr string `protobuf:"bytes,2,opt,name=supplier_operator_addr,json=supplierOperatorAddr,proto3" json:"supplier_operator_addr,omitempty"`
	// Expected number of tokens to be burnt from the application's stake.
	// A function of the actual amount of work claimed to be done.
	ExpectedBurn string `protobuf:"bytes,5,opt,name=expected_burn,json=expectedBurn,proto3" json:"expected_burn,omitempty"`
	// Actual number of tokens burnt from the application's stake.
	// A function of the amount that could be covered (less than) relative to the amount of work claimed to be done.
	EffectiveBurn string `protobuf:"bytes,6,opt,name=effective_burn,json=effectiveBurn,proto3" json:"effective_burn,omitempty"`
}

func (m *EventApplicationOverserviced) Reset()         { *m = EventApplicationOverserviced{} }
func (m *EventApplicationOverserviced) String() string { return proto.CompactTextString(m) }
func (*EventApplicationOverserviced) ProtoMessage()    {}
func (*EventApplicationOverserviced) Descriptor() ([]byte, []int) {
	return fileDescriptor_146818b9f891ddf6, []int{2}
}
func (m *EventApplicationOverserviced) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventApplicationOverserviced) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EventApplicationOverserviced) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventApplicationOverserviced.Merge(m, src)
}
func (m *EventApplicationOverserviced) XXX_Size() int {
	return m.Size()
}
func (m *EventApplicationOverserviced) XXX_DiscardUnknown() {
	xxx_messageInfo_EventApplicationOverserviced.DiscardUnknown(m)
}

var xxx_messageInfo_EventApplicationOverserviced proto.InternalMessageInfo

func (m *EventApplicationOverserviced) GetApplicationAddr() string {
	if m != nil {
		return m.ApplicationAddr
	}
	return ""
}

func (m *EventApplicationOverserviced) GetSupplierOperatorAddr() string {
	if m != nil {
		return m.SupplierOperatorAddr
	}
	return ""
}

func (m *EventApplicationOverserviced) GetExpectedBurn() string {
	if m != nil {
		return m.ExpectedBurn
	}
	return ""
}

func (m *EventApplicationOverserviced) GetEffectiveBurn() string {
	if m != nil {
		return m.EffectiveBurn
	}
	return ""
}

// EventSupplierSlashed is emitted when a supplier is slashed.
// This can happen for in cases such as missing or invalid proofs for submitted claims.
type EventSupplierSlashed struct {
	// Amount slashed from the supplier's stake.
	// A function of the claim size, supplier stake, and various onchain parameters.
	ProofMissingPenalty string `protobuf:"bytes,3,opt,name=proof_missing_penalty,json=proofMissingPenalty,proto3" json:"proof_missing_penalty,omitempty"`
	// The Service ID to which the claim corresponds.
	ServiceId string `protobuf:"bytes,4,opt,name=service_id,json=serviceId,proto3" json:"service_id,omitempty"`
	// The address of the application which participated in the claimed session.
	ApplicationAddress string `protobuf:"bytes,5,opt,name=application_address,json=applicationAddress,proto3" json:"application_address,omitempty"`
	// The end block height of the session to which the claim corresponds.
	SessionEndBlockHeight int64 `protobuf:"varint,6,opt,name=session_end_block_height,json=sessionEndBlockHeight,proto3" json:"session_end_block_height,omitempty"`
	// The validation status of the claim.
	// DEV_NOTE: This field uses the integer representation of the ClaimProofStatus
	// enum to minimize onchain disk utilization. This is necessary because event
	// data is not always protobuf-encoded in the various places and formats that it
	// appears in onchain leveldb databases.
	// Enum values:
	//
	//	PENDING_VALIDATION = 0;
	//	VALIDATED = 1;
	//	INVALID = 2;
	ClaimProofStatusInt int32 `protobuf:"varint,7,opt,name=claim_proof_status_int,json=claimProofStatusInt,proto3" json:"claim_proof_status_int,omitempty"`
	// The operator address of the supplier that was slashed.
	SupplierOperatorAddress string `protobuf:"bytes,8,opt,name=supplier_operator_address,json=supplierOperatorAddress,proto3" json:"supplier_operator_address,omitempty"`
}

func (m *EventSupplierSlashed) Reset()         { *m = EventSupplierSlashed{} }
func (m *EventSupplierSlashed) String() string { return proto.CompactTextString(m) }
func (*EventSupplierSlashed) ProtoMessage()    {}
func (*EventSupplierSlashed) Descriptor() ([]byte, []int) {
	return fileDescriptor_146818b9f891ddf6, []int{3}
}
func (m *EventSupplierSlashed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSupplierSlashed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EventSupplierSlashed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSupplierSlashed.Merge(m, src)
}
func (m *EventSupplierSlashed) XXX_Size() int {
	return m.Size()
}
func (m *EventSupplierSlashed) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSupplierSlashed.DiscardUnknown(m)
}

var xxx_messageInfo_EventSupplierSlashed proto.InternalMessageInfo

func (m *EventSupplierSlashed) GetProofMissingPenalty() string {
	if m != nil {
		return m.ProofMissingPenalty
	}
	return ""
}

func (m *EventSupplierSlashed) GetServiceId() string {
	if m != nil {
		return m.ServiceId
	}
	return ""
}

func (m *EventSupplierSlashed) GetApplicationAddress() string {
	if m != nil {
		return m.ApplicationAddress
	}
	return ""
}

func (m *EventSupplierSlashed) GetSessionEndBlockHeight() int64 {
	if m != nil {
		return m.SessionEndBlockHeight
	}
	return 0
}

func (m *EventSupplierSlashed) GetClaimProofStatusInt() int32 {
	if m != nil {
		return m.ClaimProofStatusInt
	}
	return 0
}

func (m *EventSupplierSlashed) GetSupplierOperatorAddress() string {
	if m != nil {
		return m.SupplierOperatorAddress
	}
	return ""
}

// EventClaimDiscarded is emitted when a claim is discarded due to unexpected situations.
// It is used to prevent chain halts in favor of some missing claims.
type EventClaimDiscarded struct {
	// The error that caused the claim to be discarded.
	Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// The Service ID to which the claim corresponds.
	ServiceId string `protobuf:"bytes,3,opt,name=service_id,json=serviceId,proto3" json:"service_id,omitempty"`
	// The address of the application which participated in the claimed session.
	ApplicationAddress string `protobuf:"bytes,4,opt,name=application_address,json=applicationAddress,proto3" json:"application_address,omitempty"`
	// The end block height of the session to which the claim corresponds.
	SessionEndBlockHeight int64 `protobuf:"varint,5,opt,name=session_end_block_height,json=sessionEndBlockHeight,proto3" json:"session_end_block_height,omitempty"`
	// The validation status of the claim.
	// DEV_NOTE: This field uses the integer representation of the ClaimProofStatus
	// enum to minimize onchain disk utilization. This is necessary because event
	// data is not always protobuf-encoded in the various places and formats that it
	// appears in onchain leveldb databases.
	// Enum values:
	//
	//	PENDING_VALIDATION = 0;
	//	VALIDATED = 1;
	//	INVALID = 2;
	ClaimProofStatusInt int32 `protobuf:"varint,6,opt,name=claim_proof_status_int,json=claimProofStatusInt,proto3" json:"claim_proof_status_int,omitempty"`
	// The operator address of the supplier whose claim was discarded.
	SupplierOperatorAddress string `protobuf:"bytes,7,opt,name=supplier_operator_address,json=supplierOperatorAddress,proto3" json:"supplier_operator_address,omitempty"`
}

func (m *EventClaimDiscarded) Reset()         { *m = EventClaimDiscarded{} }
func (m *EventClaimDiscarded) String() string { return proto.CompactTextString(m) }
func (*EventClaimDiscarded) ProtoMessage()    {}
func (*EventClaimDiscarded) Descriptor() ([]byte, []int) {
	return fileDescriptor_146818b9f891ddf6, []int{4}
}
func (m *EventClaimDiscarded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventClaimDiscarded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EventClaimDiscarded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventClaimDiscarded.Merge(m, src)
}
func (m *EventClaimDiscarded) XXX_Size() int {
	return m.Size()
}
func (m *EventClaimDiscarded) XXX_DiscardUnknown() {
	xxx_messageInfo_EventClaimDiscarded.DiscardUnknown(m)
}

var xxx_messageInfo_EventClaimDiscarded proto.InternalMessageInfo

func (m *EventClaimDiscarded) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *EventClaimDiscarded) GetServiceId() string {
	if m != nil {
		return m.ServiceId
	}
	return ""
}

func (m *EventClaimDiscarded) GetApplicationAddress() string {
	if m != nil {
		return m.ApplicationAddress
	}
	return ""
}

func (m *EventClaimDiscarded) GetSessionEndBlockHeight() int64 {
	if m != nil {
		return m.SessionEndBlockHeight
	}
	return 0
}

func (m *EventClaimDiscarded) GetClaimProofStatusInt() int32 {
	if m != nil {
		return m.ClaimProofStatusInt
	}
	return 0
}

func (m *EventClaimDiscarded) GetSupplierOperatorAddress() string {
	if m != nil {
		return m.SupplierOperatorAddress
	}
	return ""
}

// RewardDistributionDetail is a per-recipient, per-reason reward breakdown for a single claim.
// Unlike the reward_distribution map (which merges all OpReasons per address),
// this preserves the OpReason for each entry.
type RewardDistributionDetail struct {
	// The recipient address (bech32).
	RecipientAddress string `protobuf:"bytes,1,opt,name=recipient_address,json=recipientAddress,proto3" json:"recipient_address,omitempty"`
	// The settlement operation reason from the TLM.
	OpReason SettlementOpReason `protobuf:"varint,2,opt,name=op_reason,json=opReason,proto3,enum=pocket.tokenomics.SettlementOpReason" json:"op_reason,omitempty"`
	// The reward amount as a coin string (e.g. "1000upokt").
	Amount string `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *RewardDistributionDetail) Reset()         { *m = RewardDistributionDetail{} }
func (m *RewardDistributionDetail) String() string { return proto.CompactTextString(m) }
func (*RewardDistributionDetail) ProtoMessage()    {}
func (*RewardDistributionDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_146818b9f891ddf6, []int{5}
}
func (m *RewardDistributionDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardDistributionDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RewardDistributionDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardDistributionDetail.Merge(m, src)
}
func (m *RewardDistributionDetail) XXX_Size() int {
	return m.Size()
}
func (m *RewardDistributionDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardDistributionDetail.DiscardUnknown(m)
}

var xxx_messageInfo_RewardDistributionDetail proto.InternalMessageInfo

func (m *RewardDistributionDetail) GetRecipientAddress() string {
	if m != nil {
		return m.RecipientAddress
	}
	return ""
}

func (m *RewardDistributionDetail) GetOpReason() SettlementOpReason {
	if m != nil {
		return m.OpReason
	}
	return SettlementOpReason_UNSPECIFIED
}

func (m *RewardDistributionDetail) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

// EventSettlementBatch is emitted once per unique aggregated bank operation during settlement.
// It provides the link between batched bank transfers and the settlement context.
type EventSettlementBatch struct {
	// The session end block height for the batch of settlements.
	SessionEndBlockHeight int64 `protobuf:"varint,1,opt,name=session_end_block_height,json=sessionEndBlockHeight,proto3" json:"session_end_block_height,omitempty"`
	// The sender module account (or destination module for mints/burns).
	SenderModule string `protobuf:"bytes,2,opt,name=sender_module,json=senderModule,proto3" json:"sender_module,omitempty"`
	// The recipient (bech32 address for mod-to-acct, module name for mod-to-mod, empty for mints/burns).
	Recipient string `protobuf:"bytes,3,opt,name=recipient,proto3" json:"recipient,omitempty"`
	// The settlement operation reason from the TLM.
	OpReason SettlementOpReason `protobuf:"varint,4,opt,name=op_reason,json=opReason,proto3,enum=pocket.tokenomics.SettlementOpReason" json:"op_reason,omitempty"`
	// The total aggregated amount as a coin string.
	TotalAmount string `protobuf:"bytes,5,opt,name=total_amount,json=totalAmount,proto3" json:"total_amount,omitempty"`
	// Number of individual claims that contributed to this batch.
	NumClaims uint32 `protobuf:"varint,6,opt,name=num_claims,json=numClaims,proto3" json:"num_claims,omitempty"`
	// The type of bank operation: "mint", "burn", "mod_to_mod", "mod_to_acct".
	OpType string `protobuf:"bytes,7,opt,name=op_type,json=opType,proto3" json:"op_type,omitempty"`
}

func (m *EventSettlementBatch) Reset()         { *m = EventSettlementBatch{} }
func (m *EventSettlementBatch) String() string { return proto.CompactTextString(m) }
func (*EventSettlementBatch) ProtoMessage()    {}
func (*EventSettlementBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_146818b9f891ddf6, []int{6}
}
func (m *EventSettlementBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSettlementBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EventSettlementBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSettlementBatch.Merge(m, src)
}
func (m *EventSettlementBatch) XXX_Size() int {
	return m.Size()
}
func (m *EventSettlementBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSettlementBatch.DiscardUnknown(m)
}

var xxx_messageInfo_EventSettlementBatch proto.InternalMessageInfo

func (m *EventSettlementBatch) GetSessionEndBlockHeight() int64 {
	if m != nil {
		return m.SessionEndBlockHeight
	}
	return 0
}

func (m *EventSettlementBatch) GetSenderModule() string {
	if m != nil {
		return m.SenderModule
	}
	return ""
}

func (m *EventSettlementBatch) GetRecipient() string {
	if m != nil {
		return m.Recipient
	}
	return ""
}

func (m *EventSettlementBatch) GetOpReason() SettlementOpReason {
	if m != nil {
		return m.OpReason
	}
	return SettlementOpReason_UNSPECIFIED
}

func (m *EventSettlementBatch) GetTotalAmount() string {
	if m != nil {
		return m.TotalAmount
	}
	return ""
}

func (m *EventSettlementBatch) GetNumClaims() uint32 {
	if m != nil {
		return m.NumClaims
	}
	return 0
}

func (m *EventSettlementBatch) GetOpType() string {
	if m != nil {
		return m.OpType
	}
	return ""
}

// EventApplicationReimbursementRequest is emitted when an application requests a reimbursement from the DAO.
// It is intended to prevent self dealing attacks when global inflation is enabled.
// TODO_DISTANT_FUTURE: Remove this once global inflation is disabled in perpetuity.
type EventApplicationReimbursementRequest struct {
	// The application address consuming onchain services requesting reimbursement.
	ApplicationAddr string `protobuf:"bytes,1,opt,name=application_addr,json=applicationAddr,proto3" json:"application_addr,omitempty"`
	// The supplier operator address providing onchain services
	SupplierOperatorAddr string `protobuf:"bytes,2,opt,name=supplier_operator_addr,json=supplierOperatorAddr,proto3" json:"supplier_operator_addr,omitempty"`
	// The supplier owner address providing onchain services
	SupplierOwnerAddr string `protobuf:"bytes,3,opt,name=supplier_owner_addr,json=supplierOwnerAddr,proto3" json:"supplier_owner_addr,omitempty"`
	// The service ID associated with the session where a claim was submitted.
	ServiceId string `protobuf:"bytes,4,opt,name=service_id,json=serviceId,proto3" json:"service_id,omitempty"`
	// The session ID associated with the session where a claim was submitted.
	SessionId string `protobuf:"bytes,5,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	// The amount of uPOKT to be reimbursed to the application.
	Amount string `protobuf:"bytes,7,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *EventApplicationReimbursementRequest) Reset()         { *m = EventApplicationReimbursementRequest{} }
func (m *EventApplicationReimbursementRequest) String() string { return proto.CompactTextString(m) }
func (*EventApplicationReimbursementRequest) ProtoMessage()    {}
func (*EventApplicationReimbursementRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_146818b9f891ddf6, []int{7}
}
func (m *EventApplicationReimbursementRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventApplicationReimbursementRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EventApplicationReimbursementRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventApplicationReimbursementRequest.Merge(m, src)
}
func (m *EventApplicationReimbursementRequest) XXX_Size() int {
	return m.Size()
}
func (m *EventApplicationReimbursementRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EventApplicationReimbursementRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EventApplicationReimbursementRequest proto.InternalMessageInfo

func (m *EventApplicationReimbursementRequest) GetApplicationAddr() string {
	if m != nil {
		return m.ApplicationAddr
	}
	return ""
}

func (m *EventApplicationReimbursementRequest) GetSupplierOperatorAddr() string {
	if m != nil {
		return m.SupplierOperatorAddr
	}
	return ""
}

func (m *EventApplicationReimbursementRequest) GetSupplierOwnerAddr() string {
	if m != nil {
		return m.SupplierOwnerAddr
	}
	return ""
}

func (m *EventApplicationReimbursementRequest) GetServiceId() string {
	if m != nil {
		return m.ServiceId
	}
	return ""
}

func (m *EventApplicationReimbursementRequest) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *EventApplicationReimbursementRequest) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func init() {
	proto.RegisterEnum("pocket.tokenomics.ClaimExpirationReason", ClaimExpirationReason_name, ClaimExpirationReason_value)
	proto.RegisterType((*EventClaimExpired)(nil), "pocket.tokenomics.EventClaimExpired")
	proto.RegisterType((*EventClaimSettled)(nil), "pocket.tokenomics.EventClaimSettled")
	proto.RegisterMapType((map[string]string)(nil), "pocket.tokenomics.EventClaimSettled.RewardDistributionEntry")
	proto.RegisterType((*EventApplicationOverserviced)(nil), "pocket.tokenomics.EventApplicationOverserviced")
	proto.RegisterType((*EventSupplierSlashed)(nil), "pocket.tokenomics.EventSupplierSlashed")
	proto.RegisterType((*EventClaimDiscarded)(nil), "pocket.tokenomics.EventClaimDiscarded")
	proto.RegisterType((*RewardDistributionDetail)(nil), "pocket.tokenomics.RewardDistributionDetail")
	proto.RegisterType((*EventSettlementBatch)(nil), "pocket.tokenomics.EventSettlementBatch")
	proto.RegisterType((*EventApplicationReimbursementRequest)(nil), "pocket.tokenomics.EventApplicationReimbursementRequest")
}

func init() { proto.RegisterFile("pocket/tokenomics/event.proto", fileDescriptor_146818b9f891ddf6) }

var fileDescriptor_146818b9f891ddf6 = []byte{
	// 1299 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x57, 0xcf, 0x6f, 0xdb, 0x36,
	0x1b, 0x8e, 0xfc, 0xdb, 0x8c, 0x93, 0xca, 0xcc, 0x8f, 0x2a, 0xf9, 0x1a, 0x3b, 0x75, 0x5b, 0xc0,
	0xdf, 0xf7, 0x21, 0x0e, 0xd0, 0x0e, 0xdb, 0x30, 0xec, 0x12, 0x27, 0xee, 0xe6, 0x60, 0x8d, 0x33,
	0xba, 0x1d, 0x8a, 0x1d, 0xa6, 0x29, 0x12, 0x9b, 0x10, 0x91, 0x44, 0x8d, 0xa4, 0xd2, 0xe6, 0xbe,
	0xc3, 0x8e, 0x03, 0xfa, 0x97, 0x0c, 0xd8, 0x75, 0xf7, 0x1e, 0x8b, 0x5d, 0xd6, 0xc3, 0x90, 0x0d,
	0xe9, 0x2d, 0xff, 0xc0, 0xae, 0x03, 0x49, 0xf9, 0x47, 0x62, 0x27, 0x2d, 0xdc, 0xee, 0xb4, 0x1b,
	0xf9, 0x3e, 0xef, 0x43, 0xbe, 0x7c, 0xf5, 0xe8, 0x11, 0x05, 0x56, 0x22, 0xea, 0x1e, 0x62, 0xb1,
	0x2e, 0xe8, 0x21, 0x0e, 0x69, 0x40, 0x5c, 0xbe, 0x8e, 0x8f, 0x70, 0x28, 0x1a, 0x11, 0xa3, 0x82,
	0xc2, 0xb2, 0x86, 0x1b, 0x03, 0x78, 0x79, 0xc9, 0xa5, 0x3c, 0xa0, 0xdc, 0x56, 0x09, 0xeb, 0x7a,
	0xa2, 0xb3, 0x97, 0xe7, 0xf7, 0xe9, 0x3e, 0xd5, 0x71, 0x39, 0x4a, 0xa2, 0x56, 0xb2, 0x45, 0xc4,
	0x28, 0x7d, 0xb2, 0x2e, 0x8e, 0x23, 0xdc, 0xcb, 0x1f, 0xb3, 0xf9, 0x10, 0x5c, 0xfb, 0x3d, 0x0b,
	0xca, 0x2d, 0x59, 0xcc, 0xa6, 0xef, 0x90, 0xa0, 0xf5, 0x2c, 0x22, 0x0c, 0x7b, 0xd0, 0x07, 0x65,
	0x2c, 0x87, 0x8e, 0x20, 0x34, 0xb4, 0x19, 0x76, 0x38, 0x0d, 0xad, 0xd4, 0xaa, 0x51, 0x9f, 0xbd,
	0x5b, 0x6f, 0x8c, 0x94, 0xdb, 0x18, 0x70, 0x15, 0x01, 0xa9, 0xfc, 0xe6, 0xc2, 0xd9, 0x49, 0x75,
	0x74, 0x19, 0x64, 0xe2, 0x0b, 0x89, 0x70, 0x0d, 0x80, 0x30, 0x0e, 0x6c, 0x86, 0x7d, 0xe7, 0x98,
	0x5b, 0xe9, 0x55, 0xa3, 0x9e, 0x69, 0xce, 0x9e, 0x9d, 0x54, 0x87, 0xa2, 0xa8, 0x18, 0xc6, 0x01,
	0x52, 0x43, 0xf8, 0x18, 0x2c, 0x49, 0xc0, 0x95, 0x9b, 0x62, 0xcf, 0x76, 0x69, 0x10, 0xc5, 0x02,
	0xdb, 0x71, 0x48, 0x04, 0xb7, 0x32, 0x8a, 0xbd, 0x72, 0x76, 0x52, 0xbd, 0x3c, 0x09, 0x2d, 0x86,
	0x71, 0xb0, 0xa9, 0x91, 0x4d, 0x0d, 0x3c, 0x92, 0x71, 0xf8, 0x0d, 0xf8, 0x8f, 0x24, 0x61, 0x2e,
	0x48, 0xe0, 0x88, 0x91, 0xb5, 0xb3, 0x6a, 0xed, 0xea, 0xd9, 0x49, 0xf5, 0xaa, 0x34, 0x64, 0x85,
	0x71, 0xd0, 0xea, 0x61, 0xe7, 0xd6, 0xff, 0x10, 0xcc, 0xf4, 0x0a, 0x8a, 0x23, 0x7a, 0x28, 0xac,
	0xfc, 0xaa, 0x51, 0x2f, 0x36, 0xcb, 0x67, 0x27, 0xd5, 0xf3, 0x00, 0x2a, 0x25, 0xd3, 0x47, 0x72,
	0x06, 0x57, 0x00, 0xe0, 0x98, 0x1d, 0x11, 0x17, 0xdb, 0xc4, 0xb3, 0x0a, 0x92, 0x84, 0x8a, 0x49,
	0xa4, 0xed, 0xc1, 0x36, 0x98, 0x73, 0xa2, 0xc8, 0x27, 0xae, 0xee, 0xb3, 0xe3, 0x79, 0x0c, 0x73,
	0x6e, 0x15, 0xd5, 0xe2, 0xd6, 0xaf, 0x3f, 0xaf, 0xcd, 0x27, 0x0a, 0xda, 0xd0, 0x48, 0x57, 0x30,
	0x12, 0xee, 0x23, 0x38, 0x44, 0x4a, 0x10, 0xf8, 0x11, 0xb0, 0x38, 0xe6, 0x5c, 0x2e, 0x83, 0x43,
	0xcf, 0xde, 0xf3, 0xa9, 0x7b, 0x68, 0x1f, 0x60, 0xb2, 0x7f, 0x20, 0x2c, 0xb0, 0x6a, 0xd4, 0xd3,
	0x68, 0x21, 0xc1, 0x5b, 0xa1, 0xd7, 0x94, 0xe8, 0xe7, 0x0a, 0x84, 0xf7, 0xc0, 0xa2, 0x2a, 0xd9,
	0x56, 0x0a, 0xb4, 0xb9, 0x70, 0x44, 0xcc, 0x6d, 0x12, 0x0a, 0x6b, 0x7a, 0xd5, 0xa8, 0x67, 0xd1,
	0x9c, 0x42, 0x77, 0x25, 0xd8, 0x55, 0x58, 0x3b, 0x14, 0xf0, 0x21, 0x58, 0xe2, 0xb1, 0x2c, 0x02,
	0x33, 0x9b, 0x46, 0x98, 0x39, 0x82, 0xb2, 0x7e, 0xf9, 0xa5, 0x37, 0x94, 0x7f, 0xbd, 0x47, 0xed,
	0x24, 0xcc, 0x04, 0xde, 0xce, 0x14, 0x0c, 0x33, 0xb5, 0x9d, 0x29, 0xe4, 0xcc, 0x7c, 0xed, 0xaf,
	0xc2, 0xb0, 0xbc, 0xbb, 0x58, 0x08, 0x1f, 0x7b, 0xf0, 0x2e, 0x58, 0xd0, 0x65, 0x32, 0xfc, 0x5d,
	0x4c, 0x18, 0x0e, 0x70, 0x28, 0x54, 0xad, 0x29, 0x5d, 0xab, 0x02, 0xd1, 0x00, 0x93, 0xb5, 0xfe,
	0x7b, 0x45, 0x5a, 0x98, 0x44, 0xa4, 0xc5, 0xb7, 0x14, 0x29, 0x78, 0xcf, 0x22, 0x9d, 0x9e, 0x4c,
	0xa4, 0xa5, 0x09, 0x45, 0x3a, 0x33, 0xa1, 0x48, 0xe1, 0x0f, 0x06, 0x98, 0x63, 0xf8, 0xa9, 0xc3,
	0x3c, 0xdb, 0x23, 0x5c, 0x30, 0xb2, 0x17, 0xcb, 0x23, 0x5a, 0xb3, 0xab, 0xe9, 0xfa, 0xf4, 0xdd,
	0x4f, 0xc7, 0x98, 0xec, 0x88, 0x8c, 0x1b, 0x48, 0xf1, 0xb7, 0x86, 0xe8, 0xad, 0x50, 0xb0, 0xe3,
	0xe6, 0xd2, 0x8b, 0x93, 0xea, 0x94, 0x34, 0xdf, 0x80, 0x84, 0xe2, 0xdc, 0xf2, 0x08, 0xb2, 0x11,
	0x0e, 0x7c, 0x6e, 0x80, 0x1b, 0x63, 0x4a, 0xb1, 0x3d, 0x2c, 0x1c, 0xe2, 0x63, 0xcf, 0xba, 0xa6,
	0x6a, 0xfa, 0xff, 0x98, 0x9a, 0x46, 0x2b, 0xd8, 0x52, 0xa4, 0xe6, 0xed, 0xa4, 0x84, 0x2b, 0x17,
	0x46, 0xcb, 0xec, 0x12, 0x3e, 0xf6, 0xa4, 0x0c, 0xb9, 0x3e, 0x67, 0x22, 0x43, 0x73, 0x20, 0xc3,
	0x73, 0x00, 0x2a, 0x25, 0x53, 0x2d, 0xc3, 0x35, 0x00, 0xd4, 0xb1, 0xd5, 0x17, 0xc6, 0x2a, 0x2b,
	0x92, 0x7a, 0x4f, 0x07, 0x51, 0x54, 0x94, 0x63, 0x24, 0x87, 0xcb, 0x2d, 0x70, 0xfd, 0x92, 0x36,
	0x42, 0x13, 0xa4, 0x0f, 0xf1, 0xb1, 0x65, 0x28, 0x25, 0xcb, 0x21, 0x9c, 0x07, 0xd9, 0x23, 0xc7,
	0x8f, 0xb1, 0xf2, 0x89, 0x22, 0xd2, 0x93, 0x4f, 0x52, 0x1f, 0x1b, 0xc3, 0x9e, 0xb3, 0x9d, 0x29,
	0xe4, 0xcd, 0x42, 0xed, 0x37, 0x03, 0xdc, 0x50, 0x8f, 0x6c, 0x63, 0x20, 0xe0, 0xce, 0x11, 0x66,
	0xc9, 0x1b, 0xe1, 0xc1, 0xff, 0x02, 0xf3, 0xe2, 0x0b, 0x91, 0xec, 0x75, 0xed, 0x82, 0xe6, 0xe1,
	0x07, 0x60, 0x71, 0xbc, 0x04, 0x93, 0x42, 0xe6, 0xc7, 0xa9, 0x0c, 0xde, 0x02, 0x33, 0xf8, 0x59,
	0x84, 0x5d, 0xf9, 0xf2, 0xef, 0xc5, 0x2c, 0x54, 0xd6, 0x50, 0x44, 0xa5, 0x5e, 0xb0, 0x19, 0xb3,
	0x10, 0xde, 0x01, 0xb3, 0xf8, 0xc9, 0x13, 0xec, 0x0a, 0x72, 0x84, 0x75, 0x56, 0x4e, 0x65, 0xcd,
	0xf4, 0xa3, 0x32, 0x6d, 0x3b, 0x53, 0x48, 0x9b, 0x99, 0xed, 0x4c, 0x21, 0x63, 0x66, 0x6b, 0xdf,
	0xa7, 0xc1, 0xbc, 0x3a, 0x59, 0x37, 0xd9, 0xb5, 0xeb, 0x3b, 0xfc, 0x60, 0xd8, 0x56, 0x03, 0xc2,
	0x39, 0x09, 0xf7, 0xed, 0x08, 0x87, 0x8e, 0x2f, 0x8e, 0x95, 0x5b, 0x16, 0x13, 0x5b, 0x7d, 0xa0,
	0xb1, 0x5d, 0x0d, 0x5d, 0x70, 0x8d, 0xcc, 0x5b, 0xba, 0x46, 0xf6, 0x3d, 0xbb, 0x46, 0x6e, 0x32,
	0xd7, 0xc8, 0x4f, 0xe8, 0x1a, 0x85, 0x77, 0xfd, 0xb4, 0xa5, 0xcc, 0x74, 0xed, 0x8f, 0x14, 0x98,
	0x1b, 0x78, 0xc2, 0x16, 0xe1, 0xae, 0xc3, 0x3c, 0xec, 0x49, 0x91, 0x62, 0xc6, 0x68, 0x4f, 0x1b,
	0x7a, 0x72, 0xa1, 0xcf, 0xe9, 0xb7, 0xec, 0x73, 0xe6, 0x3d, 0xf7, 0x39, 0x3b, 0x59, 0x9f, 0x73,
	0x13, 0xf6, 0x39, 0xff, 0x4e, 0x7d, 0xae, 0xfd, 0x62, 0x00, 0xeb, 0x32, 0x87, 0x83, 0x2d, 0x50,
	0x66, 0xd8, 0x25, 0x11, 0x91, 0x77, 0x87, 0xde, 0x86, 0xc6, 0x1b, 0x36, 0x34, 0xfb, 0x94, 0x5e,
	0xb7, 0x9a, 0xa0, 0x48, 0xa3, 0xf3, 0x37, 0xec, 0x3b, 0x63, 0x8c, 0x56, 0x5b, 0xbe, 0xbc, 0x8b,
	0x74, 0x22, 0x7d, 0x6b, 0x46, 0x05, 0x9a, 0x8c, 0xe0, 0x22, 0xc8, 0x39, 0x01, 0x8d, 0x43, 0x91,
	0x3c, 0xd7, 0x64, 0x56, 0xfb, 0x29, 0xd5, 0x7b, 0x51, 0xfb, 0xec, 0xa6, 0x23, 0xdc, 0x83, 0x2b,
	0x1f, 0x91, 0x71, 0xd5, 0x23, 0xba, 0x25, 0x4d, 0x39, 0xf4, 0x30, 0xb3, 0x03, 0xea, 0xc5, 0x7e,
	0xcf, 0x08, 0x4b, 0x3a, 0xf8, 0x40, 0xc5, 0xe0, 0x0d, 0x50, 0xec, 0x1f, 0xb3, 0xa7, 0xb4, 0x7e,
	0xe0, 0xfc, 0x81, 0x33, 0x93, 0x1d, 0xf8, 0x26, 0x28, 0x09, 0x2a, 0x1c, 0xdf, 0x4e, 0x8e, 0xad,
	0x8d, 0x6d, 0x5a, 0xc5, 0x36, 0x54, 0x48, 0xea, 0xbd, 0x7f, 0xb5, 0xe2, 0x4a, 0x40, 0x33, 0xea,
	0x7a, 0xa6, 0x5e, 0x16, 0x0e, 0xaf, 0x83, 0x3c, 0x8d, 0x6c, 0xf9, 0x23, 0xa4, 0x45, 0x82, 0x72,
	0x34, 0x7a, 0x78, 0x1c, 0xe1, 0xda, 0xf3, 0x14, 0xb8, 0x7d, 0xd1, 0xb6, 0x11, 0x26, 0xc1, 0x5e,
	0xcc, 0xb8, 0x2a, 0x47, 0x5e, 0x0b, 0x31, 0x17, 0xff, 0xbc, 0x7d, 0x37, 0xc0, 0xdc, 0x80, 0xf5,
	0x34, 0xc4, 0x09, 0x45, 0x37, 0xb4, 0xdc, 0xa7, 0x48, 0x44, 0xe5, 0xbf, 0xc1, 0x49, 0x15, 0xac,
	0x9f, 0x39, 0xf1, 0x92, 0x8e, 0x15, 0x93, 0x48, 0xdb, 0x1b, 0xd2, 0x50, 0x7e, 0x58, 0x43, 0xfa,
	0x93, 0xf6, 0xbf, 0x6f, 0xc1, 0xc2, 0xd8, 0x7f, 0x3c, 0x78, 0x13, 0xac, 0xb4, 0x1e, 0xef, 0xb6,
	0xd1, 0xc6, 0xc3, 0x76, 0x67, 0xc7, 0x46, 0xad, 0x8d, 0x6e, 0x67, 0xc7, 0x7e, 0xb4, 0xd3, 0xdd,
	0x6d, 0x6d, 0xb6, 0xef, 0xb7, 0x5b, 0x5b, 0xe6, 0x14, 0x2c, 0x83, 0x99, 0x5d, 0xd4, 0xe9, 0xdc,
	0xb7, 0x1f, 0xb4, 0xbb, 0xdd, 0xf6, 0xce, 0x67, 0xa6, 0x31, 0x08, 0xb5, 0x77, 0xbe, 0xda, 0xf8,
	0xa2, 0xbd, 0x65, 0xa6, 0x9a, 0x5f, 0xbe, 0x38, 0xad, 0x18, 0x2f, 0x4f, 0x2b, 0xc6, 0xab, 0xd3,
	0x8a, 0xf1, 0xe7, 0x69, 0xc5, 0xf8, 0xf1, 0x75, 0x65, 0xea, 0xe5, 0xeb, 0xca, 0xd4, 0xab, 0xd7,
	0x95, 0xa9, 0xaf, 0xef, 0xed, 0x13, 0x71, 0x10, 0xef, 0x35, 0x5c, 0x1a, 0xac, 0xcb, 0xaf, 0xfc,
	0x5a, 0x88, 0xc5, 0x53, 0xca, 0x0e, 0xd5, 0x84, 0x51, 0xdf, 0x5f, 0x7f, 0x36, 0xf2, 0x83, 0xbb,
	0x97, 0x53, 0x7f, 0xb8, 0xf7, 0xfe, 0x0e, 0x00, 0x00, 0xff, 0xff, 0x47, 0x2e, 0xd9, 0xf6, 0x7f,
	0x0f, 0x00, 0x00,
}

func (m *EventClaimExpired) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventClaimExpired) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventClaimExpired) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SupplierOperatorAddress) > 0 {
		i -= len(m.SupplierOperatorAddress)
		copy(dAtA[i:], m.SupplierOperatorAddress)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.SupplierOperatorAddress)))
		i--
		dAtA[i] = 0x62
	}
	if m.ClaimProofStatusInt != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.ClaimProofStatusInt))
		i--
		dAtA[i] = 0x58
	}
	if m.SessionEndBlockHeight != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.SessionEndBlockHeight))
		i--
		dAtA[i] = 0x50
	}
	if len(m.ApplicationAddress) > 0 {
		i -= len(m.ApplicationAddress)
		copy(dAtA[i:], m.ApplicationAddress)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ApplicationAddress)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ServiceId) > 0 {
		i -= len(m.ServiceId)
		copy(dAtA[i:], m.ServiceId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ServiceId)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ClaimedUpokt) > 0 {
		i -= len(m.ClaimedUpokt)
		copy(dAtA[i:], m.ClaimedUpokt)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ClaimedUpokt)))
		i--
		dAtA[i] = 0x3a
	}
	if m.NumEstimatedComputeUnits != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.NumEstimatedComputeUnits))
		i--
		dAtA[i] = 0x28
	}
	if m.NumClaimedComputeUnits != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.NumClaimedComputeUnits))
		i--
		dAtA[i] = 0x20
	}
	if m.NumRelays != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.NumRelays))
		i--
		dAtA[i] = 0x18
	}
	if m.ExpirationReason != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.ExpirationReason))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *EventClaimSettled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventClaimSettled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventClaimSettled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MintRatio) > 0 {
		i -= len(m.MintRatio)
		copy(dAtA[i:], m.MintRatio)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.MintRatio)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.SettledUpokt) > 0 {
		i -= len(m.SettledUpokt)
		copy(dAtA[i:], m.SettledUpokt)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.SettledUpokt)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.RewardDistributionDetailed) > 0 {
		for iNdEx := len(m.RewardDistributionDetailed) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardDistributionDetailed[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.RewardDistribution) > 0 {
		keysForRewardDistribution := make([]string, 0, len(m.RewardDistribution))
		for k := range m.RewardDistribution {
			keysForRewardDistribution = append(keysForRewardDistribution, string(k))
		}
		github_com_cosmos_gogoproto_sortkeys.Strings(keysForRewardDistribution)
		for iNdEx := len(keysForRewardDistribution) - 1; iNdEx >= 0; iNdEx-- {
			v := m.RewardDistribution[string(keysForRewardDistribution[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintEvent(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForRewardDistribution[iNdEx])
			copy(dAtA[i:], keysForRewardDistribution[iNdEx])
			i = encodeVarintEvent(dAtA, i, uint64(len(keysForRewardDistribution[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintEvent(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.SupplierOperatorAddress) > 0 {
		i -= len(m.SupplierOperatorAddress)
		copy(dAtA[i:], m.SupplierOperatorAddress)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.SupplierOperatorAddress)))
		i--
		dAtA[i] = 0x6a
	}
	if m.ClaimProofStatusInt != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.ClaimProofStatusInt))
		i--
		dAtA[i] = 0x60
	}
	if m.SessionEndBlockHeight != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.SessionEndBlockHeight))
		i--
		dAtA[i] = 0x58
	}
	if len(m.ApplicationAddress) > 0 {
		i -= len(m.ApplicationAddress)
		copy(dAtA[i:], m.ApplicationAddress)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ApplicationAddress)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.ServiceId) > 0 {
		i -= len(m.ServiceId)
		copy(dAtA[i:], m.ServiceId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ServiceId)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ClaimedUpokt) > 0 {
		i -= len(m.ClaimedUpokt)
		copy(dAtA[i:], m.ClaimedUpokt)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ClaimedUpokt)))
		i--
		dAtA[i] = 0x42
	}
	if m.NumEstimatedComputeUnits != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.NumEstimatedComputeUnits))
		i--
		dAtA[i] = 0x28
	}
	if m.NumClaimedComputeUnits != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.NumClaimedComputeUnits))
		i--
		dAtA[i] = 0x20
	}
	if m.NumRelays != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.NumRelays))
		i--
		dAtA[i] = 0x18
	}
	if m.ProofRequirementInt != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.ProofRequirementInt))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *EventApplicationOverserviced) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventApplicationOverserviced) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventApplicationOverserviced) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EffectiveBurn) > 0 {
		i -= len(m.EffectiveBurn)
		copy(dAtA[i:], m.EffectiveBurn)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.EffectiveBurn)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ExpectedBurn) > 0 {
		i -= len(m.ExpectedBurn)
		copy(dAtA[i:], m.ExpectedBurn)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ExpectedBurn)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SupplierOperatorAddr) > 0 {
		i -= len(m.SupplierOperatorAddr)
		copy(dAtA[i:], m.SupplierOperatorAddr)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.SupplierOperatorAddr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ApplicationAddr) > 0 {
		i -= len(m.ApplicationAddr)
		copy(dAtA[i:], m.ApplicationAddr)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ApplicationAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSupplierSlashed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSupplierSlashed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSupplierSlashed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SupplierOperatorAddress) > 0 {
		i -= len(m.SupplierOperatorAddress)
		copy(dAtA[i:], m.SupplierOperatorAddress)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.SupplierOperatorAddress)))
		i--
		dAtA[i] = 0x42
	}
	if m.ClaimProofStatusInt != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.ClaimProofStatusInt))
		i--
		dAtA[i] = 0x38
	}
	if m.SessionEndBlockHeight != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.SessionEndBlockHeight))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ApplicationAddress) > 0 {
		i -= len(m.ApplicationAddress)
		copy(dAtA[i:], m.ApplicationAddress)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ApplicationAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ServiceId) > 0 {
		i -= len(m.ServiceId)
		copy(dAtA[i:], m.ServiceId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ServiceId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ProofMissingPenalty) > 0 {
		i -= len(m.ProofMissingPenalty)
		copy(dAtA[i:], m.ProofMissingPenalty)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ProofMissingPenalty)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *EventClaimDiscarded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventClaimDiscarded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventClaimDiscarded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SupplierOperatorAddress) > 0 {
		i -= len(m.SupplierOperatorAddress)
		copy(dAtA[i:], m.SupplierOperatorAddress)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.SupplierOperatorAddress)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ClaimProofStatusInt != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.ClaimProofStatusInt))
		i--
		dAtA[i] = 0x30
	}
	if m.SessionEndBlockHeight != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.SessionEndBlockHeight))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ApplicationAddress) > 0 {
		i -= len(m.ApplicationAddress)
		copy(dAtA[i:], m.ApplicationAddress)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ApplicationAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ServiceId) > 0 {
		i -= len(m.ServiceId)
		copy(dAtA[i:], m.ServiceId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ServiceId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *RewardDistributionDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardDistributionDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardDistributionDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OpReason != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.OpReason))
		i--
		dAtA[i] = 0x10
	}
	if len(m.RecipientAddress) > 0 {
		i -= len(m.RecipientAddress)
		copy(dAtA[i:], m.RecipientAddress)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.RecipientAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSettlementBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSettlementBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSettlementBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OpType) > 0 {
		i -= len(m.OpType)
		copy(dAtA[i:], m.OpType)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.OpType)))
		i--
		dAtA[i] = 0x3a
	}
	if m.NumClaims != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.NumClaims))
		i--
		dAtA[i] = 0x30
	}
	if len(m.TotalAmount) > 0 {
		i -= len(m.TotalAmount)
		copy(dAtA[i:], m.TotalAmount)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.TotalAmount)))
		i--
		dAtA[i] = 0x2a
	}
	if m.OpReason != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.OpReason))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Recipient) > 0 {
		i -= len(m.Recipient)
		copy(dAtA[i:], m.Recipient)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Recipient)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SenderModule) > 0 {
		i -= len(m.SenderModule)
		copy(dAtA[i:], m.SenderModule)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.SenderModule)))
		i--
		dAtA[i] = 0x12
	}
	if m.SessionEndBlockHeight != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.SessionEndBlockHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventApplicationReimbursementRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventApplicationReimbursementRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventApplicationReimbursementRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SessionId) > 0 {
		i -= len(m.SessionId)
		copy(dAtA[i:], m.SessionId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.SessionId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ServiceId) > 0 {
		i -= len(m.ServiceId)
		copy(dAtA[i:], m.ServiceId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ServiceId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SupplierOwnerAddr) > 0 {
		i -= len(m.SupplierOwnerAddr)
		copy(dAtA[i:], m.SupplierOwnerAddr)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.SupplierOwnerAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SupplierOperatorAddr) > 0 {
		i -= len(m.SupplierOperatorAddr)
		copy(dAtA[i:], m.SupplierOperatorAddr)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.SupplierOperatorAddr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ApplicationAddr) > 0 {
		i -= len(m.ApplicationAddr)
		copy(dAtA[i:], m.ApplicationAddr)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ApplicationAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvent(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvent(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventClaimExpired) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExpirationReason != 0 {
		n += 1 + sovEvent(uint64(m.ExpirationReason))
	}
	if m.NumRelays != 0 {
		n += 1 + sovEvent(uint64(m.NumRelays))
	}
	if m.NumClaimedComputeUnits != 0 {
		n += 1 + sovEvent(uint64(m.NumClaimedComputeUnits))
	}
	if m.NumEstimatedComputeUnits != 0 {
		n += 1 + sovEvent(uint64(m.NumEstimatedComputeUnits))
	}
	l = len(m.ClaimedUpokt)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.ServiceId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.ApplicationAddress)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if m.SessionEndBlockHeight != 0 {
		n += 1 + sovEvent(uint64(m.SessionEndBlockHeight))
	}
	if m.ClaimProofStatusInt != 0 {
		n += 1 + sovEvent(uint64(m.ClaimProofStatusInt))
	}
	l = len(m.SupplierOperatorAddress)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *EventClaimSettled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProofRequirementInt != 0 {
		n += 1 + sovEvent(uint64(m.ProofRequirementInt))
	}
	if m.NumRelays != 0 {
		n += 1 + sovEvent(uint64(m.NumRelays))
	}
	if m.NumClaimedComputeUnits != 0 {
		n += 1 + sovEvent(uint64(m.NumClaimedComputeUnits))
	}
	if m.NumEstimatedComputeUnits != 0 {
		n += 1 + sovEvent(uint64(m.NumEstimatedComputeUnits))
	}
	l = len(m.ClaimedUpokt)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.ServiceId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.ApplicationAddress)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if m.SessionEndBlockHeight != 0 {
		n += 1 + sovEvent(uint64(m.SessionEndBlockHeight))
	}
	if m.ClaimProofStatusInt != 0 {
		n += 1 + sovEvent(uint64(m.ClaimProofStatusInt))
	}
	l = len(m.SupplierOperatorAddress)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if len(m.RewardDistribution) > 0 {
		for k, v := range m.RewardDistribution {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovEvent(uint64(len(k))) + 1 + len(v) + sovEvent(uint64(len(v)))
			n += mapEntrySize + 1 + sovEvent(uint64(mapEntrySize))
		}
	}
	if len(m.RewardDistributionDetailed) > 0 {
		for _, e := range m.RewardDistributionDetailed {
			l = e.Size()
			n += 1 + l + sovEvent(uint64(l))
		}
	}
	l = len(m.SettledUpokt)
	if l > 0 {
		n += 2 + l + sovEvent(uint64(l))
	}
	l = len(m.MintRatio)
	if l > 0 {
		n += 2 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *EventApplicationOverserviced) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ApplicationAddr)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.SupplierOperatorAddr)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.ExpectedBurn)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.EffectiveBurn)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *EventSupplierSlashed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProofMissingPenalty)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.ServiceId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.ApplicationAddress)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if m.SessionEndBlockHeight != 0 {
		n += 1 + sovEvent(uint64(m.SessionEndBlockHeight))
	}
	if m.ClaimProofStatusInt != 0 {
		n += 1 + sovEvent(uint64(m.ClaimProofStatusInt))
	}
	l = len(m.SupplierOperatorAddress)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *EventClaimDiscarded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.ServiceId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.ApplicationAddress)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if m.SessionEndBlockHeight != 0 {
		n += 1 + sovEvent(uint64(m.SessionEndBlockHeight))
	}
	if m.ClaimProofStatusInt != 0 {
		n += 1 + sovEvent(uint64(m.ClaimProofStatusInt))
	}
	l = len(m.SupplierOperatorAddress)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *RewardDistributionDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RecipientAddress)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if m.OpReason != 0 {
		n += 1 + sovEvent(uint64(m.OpReason))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *EventSettlementBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionEndBlockHeight != 0 {
		n += 1 + sovEvent(uint64(m.SessionEndBlockHeight))
	}
	l = len(m.SenderModule)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Recipient)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if m.OpReason != 0 {
		n += 1 + sovEvent(uint64(m.OpReason))
	}
	l = len(m.TotalAmount)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if m.NumClaims != 0 {
		n += 1 + sovEvent(uint64(m.NumClaims))
	}
	l = len(m.OpType)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *EventApplicationReimbursementRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ApplicationAddr)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.SupplierOperatorAddr)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.SupplierOwnerAddr)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.ServiceId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.SessionId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func sovEvent(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvent(x uint64) (n int) {
	return sovEvent(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventClaimExpired) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventClaimExpired: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventClaimExpired: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationReason", wireType)
			}
			m.ExpirationReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationReason |= ClaimExpirationReason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRelays", wireType)
			}
			m.NumRelays = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRelays |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumClaimedComputeUnits", wireType)
			}
			m.NumClaimedComputeUnits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumClaimedComputeUnits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumEstimatedComputeUnits", wireType)
			}
			m.NumEstimatedComputeUnits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumEstimatedComputeUnits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimedUpokt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClaimedUpokt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicationAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionEndBlockHeight", wireType)
			}
			m.SessionEndBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionEndBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimProofStatusInt", wireType)
			}
			m.ClaimProofStatusInt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClaimProofStatusInt |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplierOperatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupplierOperatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventClaimSettled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventClaimSettled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventClaimSettled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofRequirementInt", wireType)
			}
			m.ProofRequirementInt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProofRequirementInt |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRelays", wireType)
			}
			m.NumRelays = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRelays |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumClaimedComputeUnits", wireType)
			}
			m.NumClaimedComputeUnits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumClaimedComputeUnits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumEstimatedComputeUnits", wireType)
			}
			m.NumEstimatedComputeUnits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumEstimatedComputeUnits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimedUpokt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClaimedUpokt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicationAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionEndBlockHeight", wireType)
			}
			m.SessionEndBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionEndBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimProofStatusInt", wireType)
			}
			m.ClaimProofStatusInt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClaimProofStatusInt |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplierOperatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupplierOperatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardDistribution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RewardDistribution == nil {
				m.RewardDistribution = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEvent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEvent
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthEvent
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthEvent
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEvent
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthEvent
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthEvent
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipEvent(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthEvent
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RewardDistribution[mapkey] = mapvalue
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardDistributionDetailed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardDistributionDetailed = append(m.RewardDistributionDetailed, RewardDistributionDetail{})
			if err := m.RewardDistributionDetailed[len(m.RewardDistributionDetailed)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettledUpokt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SettledUpokt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MintRatio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventApplicationOverserviced) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventApplicationOverserviced: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventApplicationOverserviced: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicationAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplierOperatorAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupplierOperatorAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedBurn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpectedBurn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectiveBurn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EffectiveBurn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSupplierSlashed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSupplierSlashed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSupplierSlashed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofMissingPenalty", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofMissingPenalty = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicationAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionEndBlockHeight", wireType)
			}
			m.SessionEndBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionEndBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimProofStatusInt", wireType)
			}
			m.ClaimProofStatusInt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClaimProofStatusInt |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplierOperatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupplierOperatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventClaimDiscarded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventClaimDiscarded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventClaimDiscarded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicationAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionEndBlockHeight", wireType)
			}
			m.SessionEndBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionEndBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimProofStatusInt", wireType)
			}
			m.ClaimProofStatusInt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClaimProofStatusInt |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplierOperatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupplierOperatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardDistributionDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardDistributionDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardDistributionDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipientAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecipientAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpReason", wireType)
			}
			m.OpReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpReason |= SettlementOpReason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSettlementBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSettlementBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSettlementBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionEndBlockHeight", wireType)
			}
			m.SessionEndBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionEndBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderModule", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SenderModule = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpReason", wireType)
			}
			m.OpReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpReason |= SettlementOpReason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumClaims", wireType)
			}
			m.NumClaims = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumClaims |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventApplicationReimbursementRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventApplicationReimbursementRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventApplicationReimbursementRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicationAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplierOperatorAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupplierOperatorAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplierOwnerAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupplierOwnerAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvent(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvent
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvent
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvent
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvent        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvent          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvent = fmt.Errorf("proto: unexpected end of group")
)
