name: Telegram Test Release Notification

on:
  workflow_dispatch:

jobs:
  notify:
    runs-on: ubuntu-latest
    outputs:
      message: ${{ steps.prepare_message.outputs.message }}
    steps:
      - name: Get latest release
        id: get_release
        run: |
          # Get latest release info from GitHub API
          RELEASE_INFO=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/latest")

          # Extract release details and properly escape for GitHub Actions
          RELEASE_NAME=$(echo "$RELEASE_INFO" | jq -r '.name')
          RELEASE_URL=$(echo "$RELEASE_INFO" | jq -r '.html_url')

          echo "Latest release: $RELEASE_NAME"
          echo "Release URL: $RELEASE_URL"

          # Handle multiline release body properly
          echo "release_name=$RELEASE_NAME" >> $GITHUB_OUTPUT
          echo "release_url=$RELEASE_URL" >> $GITHUB_OUTPUT

          # Use EOF delimiter for multiline content
          echo "release_body<<EOF" >> $GITHUB_OUTPUT
          echo "$RELEASE_INFO" | jq -r '.body' >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Prepare release message
        id: prepare_message
        run: |
          # Safely construct message using printf to avoid command execution
          RELEASE_NAME="${{ steps.get_release.outputs.release_name }}"
          RELEASE_URL="${{ steps.get_release.outputs.release_url }}"

          # Read release body and escape it properly to prevent command execution
          RELEASE_BODY=$(cat << 'EOF'
          ${{ steps.get_release.outputs.release_body }}
          EOF
          )

          # Function to convert markdown to HTML for better Telegram compatibility
          convert_markdown_to_html() {
            echo "$1" | \
            # Convert [text](url) links to <a href="url">text</a>
            sed 's/\[\([^]]*\)\](\([^)]*\))/<a href="\2">\1<\/a>/g' | \
            # Convert `code` to <code>code</code>
            sed 's/`\([^`]*\)`/<code>\1<\/code>/g' | \
            # Convert **bold** to <b>bold</b>
            sed 's/\*\*\([^*]*\)\*\*/\<b\>\1\<\/b\>/g' | \
            # Convert *italic* to <i>italic</i> (but avoid conflicts with **bold**)
            sed 's/\([^*]\)\*\([^*][^*]*[^*]\)\*\([^*]\)/\1\<i\>\2\<\/i\>\3/g' | \
            # Convert ## headers to <b>headers</b>
            sed 's/^## \(.*\)$/<b>\1<\/b>/g' | \
            # Convert ### headers to <b>headers</b>
            sed 's/^### \(.*\)$/<b>\1<\/b>/g' | \
            # Convert ‚ùóÔ∏è and other emojis that might be escaped
            sed 's/‚ùóÔ∏è/‚ùó/g'
          }

          # Convert the release body from markdown to HTML
          HTML_RELEASE_BODY=$(convert_markdown_to_html "$RELEASE_BODY")

          # Create message with HTML formatting (with TEST prefix)
          MESSAGE=$(printf "üß™ <b>TEST RELEASE NOTIFICATION</b> üß™\n\nüì£ The <b>%s release is live!</b> üì£\n<a href=\"%s\">View the full release here</a>\n\n%s" "$RELEASE_NAME" "$RELEASE_URL" "$HTML_RELEASE_BODY")

          # Use EOF delimiter for multiline content
          echo "message<<EOF" >> $GITHUB_OUTPUT
          echo "$MESSAGE" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  send-test-release:
    needs: notify
    uses: ./.github/workflows/telegram-test-message.yml
    with:
      message: ${{ needs.notify.outputs.message }}
      parse_mode: "HTML"