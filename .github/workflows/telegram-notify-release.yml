name: Telegram Broadcast New Release

### How to use this? ###
# 1. Finish the release procedure: https://dev.poktroll.com/develop/upgrades/release_procedure?_highlight=release
# 2. Set the latest release to latest and verify here: https://github.com/pokt-network/poktroll/releases/latest
# 3. Manually trigger the workflow by either:
#    - Clicking the "Run workflow" button here: https://github.com/pokt-network/poktroll/actions/workflows/telegram-notify-release.yml
#    - Or by running the following command in your terminal: $ gh workflow run telegram-notify-release.yml

### How to test / debug this? ###
# 1. Submit a new PR in a new branch that's modifying this file
# 2. Trigger the workflow by running the following command in your terminal: $ gh workflow run telegram-notify-release.yml --ref <BRANCH_NAME>
# 3. Verify the workflow worked by viewing the logs here: https://github.com/pokt-network/poktroll/actions/workflows/telegram-notify-release.yml
# 4. Check the output in the telegram bot group: https://web.telegram.org/k/#-2895286734

on:
  workflow_dispatch:
    inputs:
      test_mode:
        description: "If true, only send to testing group"
        required: false
        type: boolean
        default: false
  # Uncomment the lines below to automatically trigger on release publication
  # This is commented out to avoid premature notifications
  # release:
  #   types: [published]

jobs:
  notify:
    runs-on: ubuntu-latest
    # Uncomment the line below when enabling automatic triggers
    # if: github.event.release.prerelease == false
    outputs:
      message: ${{ steps.decode_message.outputs.message }}
    steps:
      - name: Get latest release
        id: get_release
        run: |
          # Get latest release info from GitHub API
          RELEASE_INFO=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/latest")

          # Extract release details and properly escape for GitHub Actions
          RELEASE_NAME=$(echo "$RELEASE_INFO" | jq -r '.name // "Unknown Release"')
          RELEASE_URL=$(echo "$RELEASE_INFO" | jq -r '.html_url // ""')

          echo "Latest release: $RELEASE_NAME"
          echo "Release URL: $RELEASE_URL"

          # Handle multiline release body properly
          echo "release_name=$RELEASE_NAME" >> $GITHUB_OUTPUT
          echo "release_url=$RELEASE_URL" >> $GITHUB_OUTPUT

          # Use EOF delimiter for multiline content and handle null values
          echo "release_body<<RELEASE_BODY_END" >> $GITHUB_OUTPUT
          echo "$RELEASE_INFO" | jq -r '.body // "No release notes available."' >> $GITHUB_OUTPUT
          echo "RELEASE_BODY_END" >> $GITHUB_OUTPUT

      - name: Prepare release message
        id: prepare_message
        run: |
          # Create a Python script to properly handle HTML escaping and message formatting
          cat > format_message.py << 'SCRIPT_END'
          import os
          import html
          import base64

          def format_telegram_message(release_name, release_url, release_body, test_mode=False):
              # Escape HTML entities properly
              escaped_name = html.escape(release_name or "Unknown Release")
              escaped_body = html.escape(release_body or "No release notes available.")

              # Truncate body if it's too long (Telegram has message limits)
              max_body_length = 3000  # Leave room for other parts of message
              if len(escaped_body) > max_body_length:
                  escaped_body = escaped_body[:max_body_length] + "..."

              if test_mode:
                  message = f"ðŸ§ª <b>TEST RELEASE NOTIFICATION</b> ðŸ§ª\n\nðŸ“£ The <b>{escaped_name} release is live!</b> ðŸ“£\n<a href=\"{release_url}\">View the full release here</a>\n\n{escaped_body}"
              else:
                  message = f"ðŸ“£ The <b>{escaped_name} release is live!</b> ðŸ“£\n<a href=\"{release_url}\">View the full release here</a>\n\n{escaped_body}"

              return message

          # Read environment variables
          release_name = os.environ.get('RELEASE_NAME', '')
          release_url = os.environ.get('RELEASE_URL', '')
          release_body = os.environ.get('RELEASE_BODY', '')
          test_mode = os.environ.get('TEST_MODE', 'false').lower() == 'true'

          # Format the message
          message = format_telegram_message(release_name, release_url, release_body, test_mode)

          # Encode as base64 to avoid delimiter issues
          encoded_message = base64.b64encode(message.encode('utf-8')).decode('ascii')

          # Write both versions
          with open('formatted_message.txt', 'w', encoding='utf-8') as f:
              f.write(message)

          with open('encoded_message.txt', 'w') as f:
              f.write(encoded_message)

          print("Message formatted successfully")
          print(f"Message length: {len(message)} characters")
          print(f"Encoded message: {encoded_message[:100]}...")
          SCRIPT_END

          # Set environment variables for Python script
          export RELEASE_NAME="${{ steps.get_release.outputs.release_name }}"
          export RELEASE_URL="${{ steps.get_release.outputs.release_url }}"
          export RELEASE_BODY="${{ steps.get_release.outputs.release_body }}"
          export TEST_MODE="${{ inputs.test_mode }}"

          # Run Python script to format message
          python3 format_message.py

          # Read the base64 encoded message (no delimiters needed for single line)
          ENCODED_MESSAGE=$(cat encoded_message.txt)
          echo "encoded_message=${ENCODED_MESSAGE}" >> $GITHUB_OUTPUT

          # Debug output
          echo "DEBUG: Message preview (first 200 chars):"
          head -c 200 formatted_message.txt
          echo "..."

      - name: Decode and set final message
        id: decode_message
        run: |
          # Decode the base64 message back to original format
          echo "${{ steps.prepare_message.outputs.encoded_message }}" | base64 -d > final_message.txt

          # Set the decoded message as output using a very unique delimiter
          echo "message<<MSG_DELIMITER_XYZ123" >> $GITHUB_OUTPUT
          cat final_message.txt >> $GITHUB_OUTPUT
          echo "MSG_DELIMITER_XYZ123" >> $GITHUB_OUTPUT

          echo "Message successfully decoded and set as output"

  send-release:
    needs: notify
    uses: ./.github/workflows/telegram-send-message.yml
    with:
      message: ${{ needs.notify.outputs.message }}
      parse_mode: "HTML"
      test_mode: ${{ inputs.test_mode }}
