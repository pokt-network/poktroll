name: Telegram Broadcast New Release

### How to use this? ###
# 1. Finish the release procedure: https://dev.poktroll.com/develop/upgrades/release_procedure?_highlight=release
# 2. Set the latest release to latest and verify here: https://github.com/pokt-network/poktroll/releases/latest
# 3. Manually trigger the workflow by either:
#    - Clicking the "Run workflow" button here: https://github.com/pokt-network/poktroll/actions/workflows/telegram-notify-release.yml
#    - Or by running one of these commands in your terminal:
#      $ gh workflow run telegram-notify-release.yml                    # Use latest release
#      $ gh workflow run telegram-notify-release.yml -f release_tag=v0.1.26  # Use specific release

### How to test / debug this? ###
# 1. Submit a new PR in a new branch that's modifying this file
# 2. Trigger the workflow by running the following command in your terminal: $ gh workflow run telegram-notify-release.yml --ref <BRANCH_NAME>
# 3. Verify the workflow worked by viewing the logs here: https://github.com/pokt-network/poktroll/actions/workflows/telegram-notify-release.yml
# 4. Check the output in the telegram bot group: https://web.telegram.org/k/#-2895286734

on:
  workflow_dispatch:
    inputs:
      test_mode:
        description: "If true, only send to testing group"
        required: false
        type: boolean
        default: false
      release_tag:
        description: "Specific release tag to broadcast (e.g., v0.1.26). If empty, uses latest release"
        required: false
        type: string
  # Uncomment the lines below to automatically trigger on release publication
  # This is commented out to avoid premature notifications
  # release:
  #   types: [published]

jobs:
  notify:
    runs-on: ubuntu-latest
    # Uncomment the line below when enabling automatic triggers
    # if: github.event.release.prerelease == false
    outputs:
      message: ${{ steps.prepare_message.outputs.message }}
    steps:
      - name: Get release
        id: get_release
        run: |
          # Determine which release to fetch
          RELEASE_TAG="${{ inputs.release_tag }}"

          if [ -n "$RELEASE_TAG" ]; then
            echo "Fetching specific release: $RELEASE_TAG"
            RELEASE_INFO=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/releases/tags/$RELEASE_TAG")
          else
            echo "Fetching latest release"
            RELEASE_INFO=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/releases/latest")
          fi

          # Check if the API call was successful
          if echo "$RELEASE_INFO" | jq -e '.message' > /dev/null 2>&1; then
            echo "Error: $(echo "$RELEASE_INFO" | jq -r '.message')"
            exit 1
          fi

          # Extract release details and properly escape for GitHub Actions
          RELEASE_NAME=$(echo "$RELEASE_INFO" | jq -r '.name')
          RELEASE_URL=$(echo "$RELEASE_INFO" | jq -r '.html_url')

          echo "Release: $RELEASE_NAME"
          echo "Release URL: $RELEASE_URL"

          # Handle multiline release body properly
          echo "release_name=$RELEASE_NAME" >> $GITHUB_OUTPUT
          echo "release_url=$RELEASE_URL" >> $GITHUB_OUTPUT

          # Use EOF delimiter for multiline content
          echo "release_body<<EOF" >> $GITHUB_OUTPUT
          echo "$RELEASE_INFO" | jq -r '.body' >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Prepare release message
        id: prepare_message
        env:
          RELEASE_BODY_RAW: ${{ steps.get_release.outputs.release_body }}
        run: |
          # Safely construct message using printf to avoid command execution
          RELEASE_NAME="${{ steps.get_release.outputs.release_name }}"
          RELEASE_URL="${{ steps.get_release.outputs.release_url }}"

          # Read release body from environment variable (safer than direct substitution)
          RELEASE_BODY="$RELEASE_BODY_RAW"

          # Function to convert markdown to HTML for better Telegram compatibility
          convert_markdown_to_html() {
            # Use printf to safely pass the content without shell expansion
            printf '%s' "$1" | \
            # Convert markdown tables to simple text first (before escaping)
            # Remove table separator lines
            sed '/^|[-[:space:]|]*$/d' | \
            # Convert table rows to simple text
            sed 's/^|[[:space:]]*//g' | \
            sed 's/[[:space:]]*|[[:space:]]*/ | /g' | \
            sed 's/[[:space:]]*|$//g' | \
            # Now escape HTML special characters
            sed 's/&/\&amp;/g' | \
            sed 's/</\&lt;/g' | \
            sed 's/>/\&gt;/g' | \
            # Convert markdown formatting to HTML
            # Convert **bold** to <b>bold</b> first (before italic)
            sed 's/\*\*\([^*]\+\)\*\*/<b>\1<\/b>/g' | \
            # Convert *italic* to <i>italic</i>
            sed 's/\([^*]\)\*\([^*]\+\)\*\([^*]\)/\1<i>\2<\/i>\3/g' | \
            # Convert `code` to <code>code</code>
            sed 's/`\([^`]*\)`/<code>\1<\/code>/g' | \
            # Convert [text](url) links to <a href="url">text</a>
            sed 's/\[\([^]]*\)\](\([^)]*\))/<a href="\2">\1<\/a>/g' | \
            # Convert ## headers to <b>headers</b>
            sed 's/^## \(.*\)$/<b>\1<\/b>/g' | \
            # Convert ### headers to <b>headers</b>
            sed 's/^### \(.*\)$/<b>\1<\/b>/g' | \
            # Add line breaks between paragraphs
            sed '/^$/s//<br>/g'
          }

          # Convert the release body from markdown to HTML and truncate at Legend
          FULL_HTML_BODY=$(convert_markdown_to_html "$RELEASE_BODY")

          # Truncate the message at the Legend section to avoid "message too long" error
          HTML_RELEASE_BODY=$(echo "$FULL_HTML_BODY" | sed '/^<b>Legend<\/b>:/,$d')

          # Debug: Print the HTML to see what's being generated
          echo "DEBUG: HTML_RELEASE_BODY:"
          echo "$HTML_RELEASE_BODY"
          echo "..."

          # Create message with HTML formatting
          if [ "${{ inputs.test_mode }}" = "true" ]; then
            MESSAGE=$(cat <<EOF
          ðŸ§ª <b>TEST RELEASE NOTIFICATION</b> ðŸ§ª

          ðŸ“£ <b>${RELEASE_NAME} release is live!</b> ðŸ“£
          <a href="${RELEASE_URL}">View the full release here</a>

          ${HTML_RELEASE_BODY}
          EOF
          )
          else
            MESSAGE=$(cat <<EOF
          ðŸ“£ <b>${RELEASE_NAME} release is live!</b> ðŸ“£
          <a href="${RELEASE_URL}">View the full release here</a>

          ${HTML_RELEASE_BODY}
          EOF
          )
          fi

          # Debug: Print the first 200 chars of the message
          echo "DEBUG: First 200 chars of MESSAGE:"
          echo "$MESSAGE" | head -c 200
          echo "..."

          # Use EOF delimiter for multiline content
          echo "message<<EOF" >> $GITHUB_OUTPUT
          echo "$MESSAGE" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  send-release:
    needs: notify
    uses: ./.github/workflows/telegram-send-message.yml
    with:
      message: ${{ needs.notify.outputs.message }}
      parse_mode: "HTML"
      test_mode: ${{ inputs.test_mode }}
