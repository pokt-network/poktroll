// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: pocket/shared/service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "pocket.shared";

/** Enum to define RPC types */
export enum RPCType {
  /** UNKNOWN_RPC - Undefined RPC type */
  UNKNOWN_RPC = 0,
  /** GRPC - gRPC */
  GRPC = 1,
  /** WEBSOCKET - WebSocket */
  WEBSOCKET = 2,
  /** JSON_RPC - JSON-RPC */
  JSON_RPC = 3,
  /** REST - REST */
  REST = 4,
  /** COMET_BFT - CometBFT (REST + JSON-RPC) */
  COMET_BFT = 5,
  UNRECOGNIZED = -1,
}

export function rPCTypeFromJSON(object: any): RPCType {
  switch (object) {
    case 0:
    case "UNKNOWN_RPC":
      return RPCType.UNKNOWN_RPC;
    case 1:
    case "GRPC":
      return RPCType.GRPC;
    case 2:
    case "WEBSOCKET":
      return RPCType.WEBSOCKET;
    case 3:
    case "JSON_RPC":
      return RPCType.JSON_RPC;
    case 4:
    case "REST":
      return RPCType.REST;
    case 5:
    case "COMET_BFT":
      return RPCType.COMET_BFT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RPCType.UNRECOGNIZED;
  }
}

export function rPCTypeToJSON(object: RPCType): string {
  switch (object) {
    case RPCType.UNKNOWN_RPC:
      return "UNKNOWN_RPC";
    case RPCType.GRPC:
      return "GRPC";
    case RPCType.WEBSOCKET:
      return "WEBSOCKET";
    case RPCType.JSON_RPC:
      return "JSON_RPC";
    case RPCType.REST:
      return "REST";
    case RPCType.COMET_BFT:
      return "COMET_BFT";
    case RPCType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Enum to define configuration options
 * TODO_RESEARCH: Should these be configs, SLAs or something else? There will be more discussion once we get closer to implementing onchain QoS.
 */
export enum ConfigOptions {
  /** UNKNOWN_CONFIG - Undefined config option */
  UNKNOWN_CONFIG = 0,
  /** TIMEOUT - Timeout setting */
  TIMEOUT = 1,
  UNRECOGNIZED = -1,
}

export function configOptionsFromJSON(object: any): ConfigOptions {
  switch (object) {
    case 0:
    case "UNKNOWN_CONFIG":
      return ConfigOptions.UNKNOWN_CONFIG;
    case 1:
    case "TIMEOUT":
      return ConfigOptions.TIMEOUT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConfigOptions.UNRECOGNIZED;
  }
}

export function configOptionsToJSON(object: ConfigOptions): string {
  switch (object) {
    case ConfigOptions.UNKNOWN_CONFIG:
      return "UNKNOWN_CONFIG";
    case ConfigOptions.TIMEOUT:
      return "TIMEOUT";
    case ConfigOptions.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Service message to encapsulate unique and semantic identifiers for a service on the network */
export interface Service {
  /** For example, what if we want to request a session for a certain service but with some additional configs that identify it? */
  id: string;
  /** TODO_POST_MAINNET: Rename service.name to service.description */
  name: string;
  /**
   * The cost of a single relay for this service in terms of compute units.
   * Must be used alongside the global 'compute_units_to_tokens_multiplier' to calculate the cost of a relay for this service.
   * cost_per_relay_for_specific_service = compute_units_per_relay_for_specific_service * compute_units_to_tokens_multiplier_global_value
   */
  computeUnitsPerRelay: number;
  /**
   * The owner address that created the service.
   * It is the address that receives rewards based on the Service's onchain usage
   * It is the only address that can update the service configuration (e.g. compute_units_per_relay),
   * or make other updates to it.
   */
  ownerAddress: string;
}

/** ApplicationServiceConfig holds the service configuration the application stakes for */
export interface ApplicationServiceConfig {
  /** The Service ID for which the application is configured */
  serviceId: string;
}

/** SupplierServiceConfig holds the service configuration the supplier stakes for */
export interface SupplierServiceConfig {
  /** The Service ID for which the supplier is configured */
  serviceId: string;
  /** List of endpoints for the service */
  endpoints: SupplierEndpoint[];
  /** List of revenue share configurations for the service */
  revShare: ServiceRevenueShare[];
}

/** SupplierEndpoint message to hold service configuration details */
export interface SupplierEndpoint {
  /** URL of the endpoint */
  url: string;
  /** Type of RPC exposed on the url above */
  rpcType: RPCType;
  /** Additional configuration options for the endpoint */
  configs: ConfigOption[];
}

/** ServiceRevenueShare message to hold revenue share configuration details */
export interface ServiceRevenueShare {
  /** The Bech32 address of the revenue share recipient */
  address: string;
  /** The percentage of revenue share the recipient will receive */
  revSharePercentage: number;
}

/** Key-value wrapper for config options, as proto maps can't be keyed by enums */
export interface ConfigOption {
  /** Config option key */
  key: ConfigOptions;
  /** Config option value */
  value: string;
}

function createBaseService(): Service {
  return { id: "", name: "", computeUnitsPerRelay: 0, ownerAddress: "" };
}

export const Service: MessageFns<Service> = {
  encode(message: Service, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.computeUnitsPerRelay !== 0) {
      writer.uint32(24).uint64(message.computeUnitsPerRelay);
    }
    if (message.ownerAddress !== "") {
      writer.uint32(34).string(message.ownerAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Service {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.computeUnitsPerRelay = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ownerAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Service {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      computeUnitsPerRelay: isSet(object.computeUnitsPerRelay) ? globalThis.Number(object.computeUnitsPerRelay) : 0,
      ownerAddress: isSet(object.ownerAddress) ? globalThis.String(object.ownerAddress) : "",
    };
  },

  toJSON(message: Service): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.computeUnitsPerRelay !== 0) {
      obj.computeUnitsPerRelay = Math.round(message.computeUnitsPerRelay);
    }
    if (message.ownerAddress !== "") {
      obj.ownerAddress = message.ownerAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Service>, I>>(base?: I): Service {
    return Service.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Service>, I>>(object: I): Service {
    const message = createBaseService();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.computeUnitsPerRelay = object.computeUnitsPerRelay ?? 0;
    message.ownerAddress = object.ownerAddress ?? "";
    return message;
  },
};

function createBaseApplicationServiceConfig(): ApplicationServiceConfig {
  return { serviceId: "" };
}

export const ApplicationServiceConfig: MessageFns<ApplicationServiceConfig> = {
  encode(message: ApplicationServiceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceId !== "") {
      writer.uint32(10).string(message.serviceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplicationServiceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplicationServiceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplicationServiceConfig {
    return { serviceId: isSet(object.serviceId) ? globalThis.String(object.serviceId) : "" };
  },

  toJSON(message: ApplicationServiceConfig): unknown {
    const obj: any = {};
    if (message.serviceId !== "") {
      obj.serviceId = message.serviceId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApplicationServiceConfig>, I>>(base?: I): ApplicationServiceConfig {
    return ApplicationServiceConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApplicationServiceConfig>, I>>(object: I): ApplicationServiceConfig {
    const message = createBaseApplicationServiceConfig();
    message.serviceId = object.serviceId ?? "";
    return message;
  },
};

function createBaseSupplierServiceConfig(): SupplierServiceConfig {
  return { serviceId: "", endpoints: [], revShare: [] };
}

export const SupplierServiceConfig: MessageFns<SupplierServiceConfig> = {
  encode(message: SupplierServiceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceId !== "") {
      writer.uint32(10).string(message.serviceId);
    }
    for (const v of message.endpoints) {
      SupplierEndpoint.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.revShare) {
      ServiceRevenueShare.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SupplierServiceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSupplierServiceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.endpoints.push(SupplierEndpoint.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.revShare.push(ServiceRevenueShare.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SupplierServiceConfig {
    return {
      serviceId: isSet(object.serviceId) ? globalThis.String(object.serviceId) : "",
      endpoints: globalThis.Array.isArray(object?.endpoints)
        ? object.endpoints.map((e: any) => SupplierEndpoint.fromJSON(e))
        : [],
      revShare: globalThis.Array.isArray(object?.revShare)
        ? object.revShare.map((e: any) => ServiceRevenueShare.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SupplierServiceConfig): unknown {
    const obj: any = {};
    if (message.serviceId !== "") {
      obj.serviceId = message.serviceId;
    }
    if (message.endpoints?.length) {
      obj.endpoints = message.endpoints.map((e) => SupplierEndpoint.toJSON(e));
    }
    if (message.revShare?.length) {
      obj.revShare = message.revShare.map((e) => ServiceRevenueShare.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SupplierServiceConfig>, I>>(base?: I): SupplierServiceConfig {
    return SupplierServiceConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SupplierServiceConfig>, I>>(object: I): SupplierServiceConfig {
    const message = createBaseSupplierServiceConfig();
    message.serviceId = object.serviceId ?? "";
    message.endpoints = object.endpoints?.map((e) => SupplierEndpoint.fromPartial(e)) || [];
    message.revShare = object.revShare?.map((e) => ServiceRevenueShare.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSupplierEndpoint(): SupplierEndpoint {
  return { url: "", rpcType: 0, configs: [] };
}

export const SupplierEndpoint: MessageFns<SupplierEndpoint> = {
  encode(message: SupplierEndpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.rpcType !== 0) {
      writer.uint32(16).int32(message.rpcType);
    }
    for (const v of message.configs) {
      ConfigOption.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SupplierEndpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSupplierEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.rpcType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.configs.push(ConfigOption.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SupplierEndpoint {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      rpcType: isSet(object.rpcType) ? rPCTypeFromJSON(object.rpcType) : 0,
      configs: globalThis.Array.isArray(object?.configs)
        ? object.configs.map((e: any) => ConfigOption.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SupplierEndpoint): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.rpcType !== 0) {
      obj.rpcType = rPCTypeToJSON(message.rpcType);
    }
    if (message.configs?.length) {
      obj.configs = message.configs.map((e) => ConfigOption.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SupplierEndpoint>, I>>(base?: I): SupplierEndpoint {
    return SupplierEndpoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SupplierEndpoint>, I>>(object: I): SupplierEndpoint {
    const message = createBaseSupplierEndpoint();
    message.url = object.url ?? "";
    message.rpcType = object.rpcType ?? 0;
    message.configs = object.configs?.map((e) => ConfigOption.fromPartial(e)) || [];
    return message;
  },
};

function createBaseServiceRevenueShare(): ServiceRevenueShare {
  return { address: "", revSharePercentage: 0 };
}

export const ServiceRevenueShare: MessageFns<ServiceRevenueShare> = {
  encode(message: ServiceRevenueShare, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.revSharePercentage !== 0) {
      writer.uint32(24).uint64(message.revSharePercentage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceRevenueShare {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceRevenueShare();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.revSharePercentage = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceRevenueShare {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      revSharePercentage: isSet(object.revSharePercentage) ? globalThis.Number(object.revSharePercentage) : 0,
    };
  },

  toJSON(message: ServiceRevenueShare): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.revSharePercentage !== 0) {
      obj.revSharePercentage = Math.round(message.revSharePercentage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceRevenueShare>, I>>(base?: I): ServiceRevenueShare {
    return ServiceRevenueShare.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceRevenueShare>, I>>(object: I): ServiceRevenueShare {
    const message = createBaseServiceRevenueShare();
    message.address = object.address ?? "";
    message.revSharePercentage = object.revSharePercentage ?? 0;
    return message;
  },
};

function createBaseConfigOption(): ConfigOption {
  return { key: 0, value: "" };
}

export const ConfigOption: MessageFns<ConfigOption> = {
  encode(message: ConfigOption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).int32(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfigOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfigOption {
    return {
      key: isSet(object.key) ? configOptionsFromJSON(object.key) : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ConfigOption): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = configOptionsToJSON(message.key);
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfigOption>, I>>(base?: I): ConfigOption {
    return ConfigOption.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfigOption>, I>>(object: I): ConfigOption {
    const message = createBaseConfigOption();
    message.key = object.key ?? 0;
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
