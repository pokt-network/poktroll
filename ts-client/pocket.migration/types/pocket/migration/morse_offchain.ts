// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: pocket/migration/morse_offchain.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Coin } from "../../cosmos/base/v1beta1/coin";
import { Timestamp } from "../../google/protobuf/timestamp";

export const protobufPackage = "pocket.migration";

/**
 * MorseStateExport is the data structure that is serialized and output when running:
 *  $ pocket utils export-genesis-for-reset ...
 *
 * Ref: https://editor.swagger.io/?url=https://raw.githubusercontent.com/pokt-network/pocket-core/staging/doc/specs/rpc-spec.yaml#operations-query-post_query_state
 */
export interface MorseStateExport {
  /** app_hash is the Morse tendermint state hash. */
  appHash: string;
  /** app_state is the entire Morse tendermint application state. */
  appState: MorseTendermintAppState | undefined;
}

/**
 * MorseTendermintAppState is the tendermint application state for the Morse tendermint
 * application; not to be confused with the pokt protocol actor.
 * It is constructed in Morse via `PocketCoreApp#ExportAppState()`.
 *
 * See: https://github.com/pokt-network/pocket-core/blob/5fa61920aa9d45ca6bf9e01e863134e242c95fa7/app/pocket.go#L142
 */
export interface MorseTendermintAppState {
  application: MorseApplications | undefined;
  auth: MorseAuth | undefined;
  pos: MorsePos | undefined;
}

/**
 * A wrapper around the list of MorseApplications, necessary in order to conform to the Morse genesis structure.
 * It encapsulates the minimum information required to import Morse applications.
 *
 * See: https://github.com/pokt-network/pocket-core/blob/staging/x/apps/types/genesis.go#L4
 */
export interface MorseApplications {
  applications: MorseApplication[];
}

/**
 * A wrapper around a list of MorseAuthAccount.
 * It encapsulates the minimum information required to import Morse accounts.
 *
 * See: https://github.com/pokt-network/pocket-core/blob/staging/x/auth/types/genesis.go#L9
 */
export interface MorseAuth {
  accounts: MorseAuthAccount[];
}

/**
 * MorseAuthAccount:
 * * Wraps MorseAuthAccount information to conform to Morse genesis structure
 * * Can represent EITHER an externally owned account OR a module account
 */
export interface MorseAuthAccount {
  type: string;
  /** value is a EITHER a JSON-encoded MorseAccount or a MorseModuleAccount. */
  value: Uint8Array;
}

/**
 * A wrapper around the list of Morse suppliers (aka "validators", "nodes", of "servicers").
 * It is necessary to conform to the Morse genesis structure.
 *
 * See: https://github.com/pokt-network/pocket-core/blob/staging/x/nodes/types/genesis.go#L8
 */
export interface MorsePos {
  validators: MorseValidator[];
}

/**
 * MorseApplication is a subset of the Morse ProtoApplication type.
 * It encapsulates the minimum information required to import Morse applications.
 *
 * See: https://github.com/pokt-network/pocket-core/blob/staging/proto/x/apps/apps.proto#L16
 */
export interface MorseApplication {
  /**
   * Address is a binary representation of the address corresponding
   * to a Morse application's ed25519 public key.
   */
  address: Uint8Array;
  /** PublicKey is the binary representation of a Morse application's ed25519 public key. */
  publicKey: Uint8Array;
  /** TODO_MAINNET_MIGRATION(@Olshansk):  Should status and/or jailed be considered during the migration, and if so, how? */
  jailed: boolean;
  status: number;
  /** The string representation of the BigInt amount of upokt. */
  stakedTokens: string;
  /**
   * The ISO 8601 UTC timestamp after which the Morse node/supplier unbonding period will have elapsed.
   * It reflects the "unbonding completion time" of the Morse node/supplier, but is called "unstaking time" to comply with necessary Morse data structures.
   */
  unstakingTime: Date | undefined;
}

/**
 * MorseValidator is a subset of the Morse ProtoValidator type.
 * It encapsulates the minimum information required to import Morse suppliers (aka "servicers" or "validators").
 *
 * See: https://github.com/pokt-network/pocket-core/blob/staging/proto/x/pos/types.proto#L16
 */
export interface MorseValidator {
  /**
   * Morse non-custodial (i.e. operator) address. If output_address is not set, this is the custodial address.
   * Binary representation of the Morse address corresponding to a Morse node's ed25519 public key.
   * See 'pocket nodes --help' for more information. Note that this refers to the Morse CLI.
   */
  address: Uint8Array;
  /** Binary representation of a Morse node's ed25519 public key. */
  publicKey: Uint8Array;
  /** TODO_MAINNET_MIGRATION(@Olshansk):  Should status and/or jailed be considered during the migration, and if so, how? */
  jailed: boolean;
  status: number;
  /** The string representation of the BigInt amount of upokt. */
  stakedTokens: string;
  /**
   * The ISO 8601 UTC timestamp after which the Morse node/supplier unbonding period will have elapsed.
   * It reflects the "unbonding completion time" of the Morse node/supplier, but is called "unstaking time" to comply with necessary Morse data structures.
   */
  unstakingTime:
    | Date
    | undefined;
  /**
   * Morse custodial (i.e. owner) address, which owns the staked tokens of the operator.
   * Binary representation of the Morse address corresponding to a Morse account's ed25519 public key.
   * See 'pocket nodes --help' for more information. Note that this refers to the Morse CLI.
   */
  outputAddress: Uint8Array;
}

/**
 * MorseAccount is an analog of the Morse ProtoBaseAccount type.
 * It encapsulates the minimum information required to import accounts.
 *
 * See: https://github.com/pokt-network/pocket-core/blob/staging/proto/x/auth/auth.proto#L14.
 */
export interface MorseAccount {
  /** A hex-encoded representation of the address corresponding to a Morse application's ed25519 public key. */
  address: Uint8Array;
  /** The ed25519 public key of the account. */
  pubKey:
    | MorsePublicKey
    | undefined;
  /** The account balance; this does not include any actor stakes. */
  coins: Coin[];
}

/**
 * MorsePublicKey is required to conform to the encoding of the Morse state export.
 * NB: All Morse account public keys will be ed25519 keys by definition.
 */
export interface MorsePublicKey {
  value: Uint8Array;
}

/**
 * MorseModuleAccount is the module account type for Morse, it wraps a MorseAccount
 * and has a unique name, which is used instead of the address.
 */
export interface MorseModuleAccount {
  /** DEV_NOTE: the JSON tag is intentionally cased contrary to convention to match the real-world Morse state export. */
  baseAccount: MorseAccount | undefined;
  name: string;
}

function createBaseMorseStateExport(): MorseStateExport {
  return { appHash: "", appState: undefined };
}

export const MorseStateExport: MessageFns<MorseStateExport> = {
  encode(message: MorseStateExport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appHash !== "") {
      writer.uint32(10).string(message.appHash);
    }
    if (message.appState !== undefined) {
      MorseTendermintAppState.encode(message.appState, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MorseStateExport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMorseStateExport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.appHash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.appState = MorseTendermintAppState.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MorseStateExport {
    return {
      appHash: isSet(object.appHash) ? globalThis.String(object.appHash) : "",
      appState: isSet(object.appState) ? MorseTendermintAppState.fromJSON(object.appState) : undefined,
    };
  },

  toJSON(message: MorseStateExport): unknown {
    const obj: any = {};
    if (message.appHash !== "") {
      obj.appHash = message.appHash;
    }
    if (message.appState !== undefined) {
      obj.appState = MorseTendermintAppState.toJSON(message.appState);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MorseStateExport>, I>>(base?: I): MorseStateExport {
    return MorseStateExport.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MorseStateExport>, I>>(object: I): MorseStateExport {
    const message = createBaseMorseStateExport();
    message.appHash = object.appHash ?? "";
    message.appState = (object.appState !== undefined && object.appState !== null)
      ? MorseTendermintAppState.fromPartial(object.appState)
      : undefined;
    return message;
  },
};

function createBaseMorseTendermintAppState(): MorseTendermintAppState {
  return { application: undefined, auth: undefined, pos: undefined };
}

export const MorseTendermintAppState: MessageFns<MorseTendermintAppState> = {
  encode(message: MorseTendermintAppState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.application !== undefined) {
      MorseApplications.encode(message.application, writer.uint32(10).fork()).join();
    }
    if (message.auth !== undefined) {
      MorseAuth.encode(message.auth, writer.uint32(18).fork()).join();
    }
    if (message.pos !== undefined) {
      MorsePos.encode(message.pos, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MorseTendermintAppState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMorseTendermintAppState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.application = MorseApplications.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.auth = MorseAuth.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pos = MorsePos.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MorseTendermintAppState {
    return {
      application: isSet(object.application) ? MorseApplications.fromJSON(object.application) : undefined,
      auth: isSet(object.auth) ? MorseAuth.fromJSON(object.auth) : undefined,
      pos: isSet(object.pos) ? MorsePos.fromJSON(object.pos) : undefined,
    };
  },

  toJSON(message: MorseTendermintAppState): unknown {
    const obj: any = {};
    if (message.application !== undefined) {
      obj.application = MorseApplications.toJSON(message.application);
    }
    if (message.auth !== undefined) {
      obj.auth = MorseAuth.toJSON(message.auth);
    }
    if (message.pos !== undefined) {
      obj.pos = MorsePos.toJSON(message.pos);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MorseTendermintAppState>, I>>(base?: I): MorseTendermintAppState {
    return MorseTendermintAppState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MorseTendermintAppState>, I>>(object: I): MorseTendermintAppState {
    const message = createBaseMorseTendermintAppState();
    message.application = (object.application !== undefined && object.application !== null)
      ? MorseApplications.fromPartial(object.application)
      : undefined;
    message.auth = (object.auth !== undefined && object.auth !== null) ? MorseAuth.fromPartial(object.auth) : undefined;
    message.pos = (object.pos !== undefined && object.pos !== null) ? MorsePos.fromPartial(object.pos) : undefined;
    return message;
  },
};

function createBaseMorseApplications(): MorseApplications {
  return { applications: [] };
}

export const MorseApplications: MessageFns<MorseApplications> = {
  encode(message: MorseApplications, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.applications) {
      MorseApplication.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MorseApplications {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMorseApplications();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.applications.push(MorseApplication.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MorseApplications {
    return {
      applications: globalThis.Array.isArray(object?.applications)
        ? object.applications.map((e: any) => MorseApplication.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MorseApplications): unknown {
    const obj: any = {};
    if (message.applications?.length) {
      obj.applications = message.applications.map((e) => MorseApplication.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MorseApplications>, I>>(base?: I): MorseApplications {
    return MorseApplications.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MorseApplications>, I>>(object: I): MorseApplications {
    const message = createBaseMorseApplications();
    message.applications = object.applications?.map((e) => MorseApplication.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMorseAuth(): MorseAuth {
  return { accounts: [] };
}

export const MorseAuth: MessageFns<MorseAuth> = {
  encode(message: MorseAuth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.accounts) {
      MorseAuthAccount.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MorseAuth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMorseAuth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accounts.push(MorseAuthAccount.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MorseAuth {
    return {
      accounts: globalThis.Array.isArray(object?.accounts)
        ? object.accounts.map((e: any) => MorseAuthAccount.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MorseAuth): unknown {
    const obj: any = {};
    if (message.accounts?.length) {
      obj.accounts = message.accounts.map((e) => MorseAuthAccount.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MorseAuth>, I>>(base?: I): MorseAuth {
    return MorseAuth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MorseAuth>, I>>(object: I): MorseAuth {
    const message = createBaseMorseAuth();
    message.accounts = object.accounts?.map((e) => MorseAuthAccount.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMorseAuthAccount(): MorseAuthAccount {
  return { type: "", value: new Uint8Array(0) };
}

export const MorseAuthAccount: MessageFns<MorseAuthAccount> = {
  encode(message: MorseAuthAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.value.length !== 0) {
      writer.uint32(26).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MorseAuthAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMorseAuthAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MorseAuthAccount {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: MorseAuthAccount): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MorseAuthAccount>, I>>(base?: I): MorseAuthAccount {
    return MorseAuthAccount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MorseAuthAccount>, I>>(object: I): MorseAuthAccount {
    const message = createBaseMorseAuthAccount();
    message.type = object.type ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMorsePos(): MorsePos {
  return { validators: [] };
}

export const MorsePos: MessageFns<MorsePos> = {
  encode(message: MorsePos, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.validators) {
      MorseValidator.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MorsePos {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMorsePos();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validators.push(MorseValidator.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MorsePos {
    return {
      validators: globalThis.Array.isArray(object?.validators)
        ? object.validators.map((e: any) => MorseValidator.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MorsePos): unknown {
    const obj: any = {};
    if (message.validators?.length) {
      obj.validators = message.validators.map((e) => MorseValidator.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MorsePos>, I>>(base?: I): MorsePos {
    return MorsePos.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MorsePos>, I>>(object: I): MorsePos {
    const message = createBaseMorsePos();
    message.validators = object.validators?.map((e) => MorseValidator.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMorseApplication(): MorseApplication {
  return {
    address: new Uint8Array(0),
    publicKey: new Uint8Array(0),
    jailed: false,
    status: 0,
    stakedTokens: "",
    unstakingTime: undefined,
  };
}

export const MorseApplication: MessageFns<MorseApplication> = {
  encode(message: MorseApplication, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(18).bytes(message.publicKey);
    }
    if (message.jailed !== false) {
      writer.uint32(24).bool(message.jailed);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.stakedTokens !== "") {
      writer.uint32(50).string(message.stakedTokens);
    }
    if (message.unstakingTime !== undefined) {
      Timestamp.encode(toTimestamp(message.unstakingTime), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MorseApplication {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMorseApplication();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.jailed = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.stakedTokens = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.unstakingTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MorseApplication {
    return {
      address: isSet(object.address) ? bytesFromBase64(object.address) : new Uint8Array(0),
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
      jailed: isSet(object.jailed) ? globalThis.Boolean(object.jailed) : false,
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
      stakedTokens: isSet(object.stakedTokens) ? globalThis.String(object.stakedTokens) : "",
      unstakingTime: isSet(object.unstakingTime) ? fromJsonTimestamp(object.unstakingTime) : undefined,
    };
  },

  toJSON(message: MorseApplication): unknown {
    const obj: any = {};
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    if (message.jailed !== false) {
      obj.jailed = message.jailed;
    }
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (message.stakedTokens !== "") {
      obj.stakedTokens = message.stakedTokens;
    }
    if (message.unstakingTime !== undefined) {
      obj.unstakingTime = message.unstakingTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MorseApplication>, I>>(base?: I): MorseApplication {
    return MorseApplication.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MorseApplication>, I>>(object: I): MorseApplication {
    const message = createBaseMorseApplication();
    message.address = object.address ?? new Uint8Array(0);
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    message.jailed = object.jailed ?? false;
    message.status = object.status ?? 0;
    message.stakedTokens = object.stakedTokens ?? "";
    message.unstakingTime = object.unstakingTime ?? undefined;
    return message;
  },
};

function createBaseMorseValidator(): MorseValidator {
  return {
    address: new Uint8Array(0),
    publicKey: new Uint8Array(0),
    jailed: false,
    status: 0,
    stakedTokens: "",
    unstakingTime: undefined,
    outputAddress: new Uint8Array(0),
  };
}

export const MorseValidator: MessageFns<MorseValidator> = {
  encode(message: MorseValidator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(18).bytes(message.publicKey);
    }
    if (message.jailed !== false) {
      writer.uint32(24).bool(message.jailed);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.stakedTokens !== "") {
      writer.uint32(58).string(message.stakedTokens);
    }
    if (message.unstakingTime !== undefined) {
      Timestamp.encode(toTimestamp(message.unstakingTime), writer.uint32(66).fork()).join();
    }
    if (message.outputAddress.length !== 0) {
      writer.uint32(74).bytes(message.outputAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MorseValidator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMorseValidator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.jailed = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.stakedTokens = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.unstakingTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.outputAddress = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MorseValidator {
    return {
      address: isSet(object.address) ? bytesFromBase64(object.address) : new Uint8Array(0),
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
      jailed: isSet(object.jailed) ? globalThis.Boolean(object.jailed) : false,
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
      stakedTokens: isSet(object.stakedTokens) ? globalThis.String(object.stakedTokens) : "",
      unstakingTime: isSet(object.unstakingTime) ? fromJsonTimestamp(object.unstakingTime) : undefined,
      outputAddress: isSet(object.outputAddress) ? bytesFromBase64(object.outputAddress) : new Uint8Array(0),
    };
  },

  toJSON(message: MorseValidator): unknown {
    const obj: any = {};
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    if (message.jailed !== false) {
      obj.jailed = message.jailed;
    }
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (message.stakedTokens !== "") {
      obj.stakedTokens = message.stakedTokens;
    }
    if (message.unstakingTime !== undefined) {
      obj.unstakingTime = message.unstakingTime.toISOString();
    }
    if (message.outputAddress.length !== 0) {
      obj.outputAddress = base64FromBytes(message.outputAddress);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MorseValidator>, I>>(base?: I): MorseValidator {
    return MorseValidator.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MorseValidator>, I>>(object: I): MorseValidator {
    const message = createBaseMorseValidator();
    message.address = object.address ?? new Uint8Array(0);
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    message.jailed = object.jailed ?? false;
    message.status = object.status ?? 0;
    message.stakedTokens = object.stakedTokens ?? "";
    message.unstakingTime = object.unstakingTime ?? undefined;
    message.outputAddress = object.outputAddress ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMorseAccount(): MorseAccount {
  return { address: new Uint8Array(0), pubKey: undefined, coins: [] };
}

export const MorseAccount: MessageFns<MorseAccount> = {
  encode(message: MorseAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    if (message.pubKey !== undefined) {
      MorsePublicKey.encode(message.pubKey, writer.uint32(18).fork()).join();
    }
    for (const v of message.coins) {
      Coin.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MorseAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMorseAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pubKey = MorsePublicKey.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.coins.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MorseAccount {
    return {
      address: isSet(object.address) ? bytesFromBase64(object.address) : new Uint8Array(0),
      pubKey: isSet(object.pubKey) ? MorsePublicKey.fromJSON(object.pubKey) : undefined,
      coins: globalThis.Array.isArray(object?.coins) ? object.coins.map((e: any) => Coin.fromJSON(e)) : [],
    };
  },

  toJSON(message: MorseAccount): unknown {
    const obj: any = {};
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    if (message.pubKey !== undefined) {
      obj.pubKey = MorsePublicKey.toJSON(message.pubKey);
    }
    if (message.coins?.length) {
      obj.coins = message.coins.map((e) => Coin.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MorseAccount>, I>>(base?: I): MorseAccount {
    return MorseAccount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MorseAccount>, I>>(object: I): MorseAccount {
    const message = createBaseMorseAccount();
    message.address = object.address ?? new Uint8Array(0);
    message.pubKey = (object.pubKey !== undefined && object.pubKey !== null)
      ? MorsePublicKey.fromPartial(object.pubKey)
      : undefined;
    message.coins = object.coins?.map((e) => Coin.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMorsePublicKey(): MorsePublicKey {
  return { value: new Uint8Array(0) };
}

export const MorsePublicKey: MessageFns<MorsePublicKey> = {
  encode(message: MorsePublicKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MorsePublicKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMorsePublicKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MorsePublicKey {
    return { value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0) };
  },

  toJSON(message: MorsePublicKey): unknown {
    const obj: any = {};
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MorsePublicKey>, I>>(base?: I): MorsePublicKey {
    return MorsePublicKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MorsePublicKey>, I>>(object: I): MorsePublicKey {
    const message = createBaseMorsePublicKey();
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMorseModuleAccount(): MorseModuleAccount {
  return { baseAccount: undefined, name: "" };
}

export const MorseModuleAccount: MessageFns<MorseModuleAccount> = {
  encode(message: MorseModuleAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseAccount !== undefined) {
      MorseAccount.encode(message.baseAccount, writer.uint32(10).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MorseModuleAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMorseModuleAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseAccount = MorseAccount.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MorseModuleAccount {
    return {
      baseAccount: isSet(object.baseAccount) ? MorseAccount.fromJSON(object.baseAccount) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: MorseModuleAccount): unknown {
    const obj: any = {};
    if (message.baseAccount !== undefined) {
      obj.baseAccount = MorseAccount.toJSON(message.baseAccount);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MorseModuleAccount>, I>>(base?: I): MorseModuleAccount {
    return MorseModuleAccount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MorseModuleAccount>, I>>(object: I): MorseModuleAccount {
    const message = createBaseMorseModuleAccount();
    message.baseAccount = (object.baseAccount !== undefined && object.baseAccount !== null)
      ? MorseAccount.fromPartial(object.baseAccount)
      : undefined;
    message.name = object.name ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
