package memory

import (
	"fmt"
	"sort"
	"sync"
	"time"

	"github.com/pokt-network/poktroll/pkg/cache"
)

var _ cache.HistoricalKeyValueCache[any] = (*historicalKeyValueCache[any])(nil)

// historicalKeyValueCache provides a concurrency-safe in-memory cache implementation
// with support for tracking multiple value versions for a given key.
type historicalKeyValueCache[T any] struct {
	config historicalKeyValueCacheConfig

	// valuesMu is used to protect values AND valueHistories from concurrent access.
	valuesMu sync.RWMutex
	// valueHistories holds the cached historical values.
	valueHistories map[string]cacheValueHistory[T]
}

// cacheValueHistory maintains:
// - Cached values indexed by version number
// - A descending-sorted list of version numbers for existing cached values
//
// The descending sort order optimizes performance by correlating index with age.
type cacheValueHistory[T any] struct {
	// sortedDescVersions is a list of the version numbers for which values are
	// cached. It is sorted in descending order.
	sortedDescVersions []int64
	// versionToValueMap is a map from a version number to the cached value at
	// that version number.
	versionToValueMap map[int64]cacheValue[T]
}

// NewHistoricalKeyValueCache creates a new historicalKeyValueCache with
// the configuration generated by applying the given option functions to
// the DefaultHistoricalKeyValueCacheConfig.
func NewHistoricalKeyValueCache[T any](opts ...KeyValueCacheOptionFn) (*historicalKeyValueCache[T], error) {
	config := DefaultHistoricalKeyValueCacheConfig

	for _, opt := range opts {
		if err := opt(&config); err != nil {
			return nil, err
		}
	}

	if err := config.Validate(); err != nil {
		return nil, err
	}

	return &historicalKeyValueCache[T]{
		valueHistories: make(map[string]cacheValueHistory[T]),
		config:         config,
	}, nil
}

// GetVersion retrieves the value from the cache with the given key and version.
// If a value is not found which meets these criteria, the zero value and false are returned.
func (c *historicalKeyValueCache[T]) GetVersion(key string, version int64) (T, bool) {
	c.valuesMu.RLock()
	defer c.valuesMu.RUnlock()

	return c.getVersion(key, version)
}

// getVersion retrieves the value from the cache with the given key for the given
// version. If a value is not found for that version, the zero value and false are
// returned.
func (c *historicalKeyValueCache[T]) getVersion(key string, version int64) (T, bool) {
	var zero T
	valueHistory, exists := c.valueHistories[key]
	if !exists {
		return zero, false
	}

	cachedValue, exists := valueHistory.versionToValueMap[version]
	if !exists {
		return zero, false
	}

	return cachedValue.value, true
}

// GetVersionLTE retrieves the value from the cache with the given key, as of the
// nearest version <= maxVersion. If a value is not found for that version, the value at the nearest
// previous version is returned.
func (c *historicalKeyValueCache[T]) GetVersionLTE(key string, maxVersion int64) (T, bool) {
	c.valuesMu.RLock()
	defer c.valuesMu.RUnlock()

	var zero T
	valueHistory, exists := c.valueHistories[key]
	if !exists {
		return zero, false
	}

	var nearestCachedVersion int64 = -1
	for _, cachedVersion := range valueHistory.sortedDescVersions {
		if cachedVersion <= maxVersion {
			nearestCachedVersion = cachedVersion
			// DEV_NOTE: Since the list is sorted in descending order, once we
			// encounter a cachedVersion that is less than or equal to version,
			// all subsequent cachedVersions SHOULD also be less than or equal to
			// version.
			break
		}
	}

	if nearestCachedVersion == -1 {
		return zero, false
	}

	cachedValue, exists := valueHistory.versionToValueMap[nearestCachedVersion]
	if !exists {
		// DEV_NOTE: This SHOULD NEVER happen. If it does, it means that the cache has been corrupted.
		return zero, false
	}

	return cachedValue.value, true
}

// GetLatestVersion returns the value of the latest version of the given key.
func (c *historicalKeyValueCache[T]) GetLatestVersion(key string) (T, bool) {
	c.valuesMu.RLock()
	defer c.valuesMu.RUnlock()

	var zero T
	version := c.getLatestVersionNumber(key)
	if version == -1 {
		return zero, false
	}

	return c.getVersion(key, version)
}

// SetVersion adds or updates the historical value in the cache for the given key and version number.
func (c *historicalKeyValueCache[T]) SetVersion(key string, value T, version int64) error {
	c.valuesMu.Lock()
	defer c.valuesMu.Unlock()

	latestVersion := max(version, c.getLatestVersionNumber(key))
	if version > latestVersion {
		latestVersion = version
	}

	valueHistory, exists := c.valueHistories[key]
	if !exists {
		versionToValueMap := make(map[int64]cacheValue[T])
		valueHistory = cacheValueHistory[T]{
			sortedDescVersions: make([]int64, 0),
			versionToValueMap:  versionToValueMap,
		}
	}

	if _, versionExists := valueHistory.versionToValueMap[version]; versionExists {
		return cache.ErrNoOverwrite.Wrapf("version: %d", version)
	}

	// Update sortedDescVersions and ensure the list is sorted in descending order.
	valueHistory.sortedDescVersions = append(valueHistory.sortedDescVersions, version)
	sort.Slice(valueHistory.sortedDescVersions, func(i, j int) bool {
		return valueHistory.sortedDescVersions[i] > valueHistory.sortedDescVersions[j]
	})

	// Prune historical values for this key, where the version
	// is older than the configured maxVersionAge.
	if c.config.maxVersionAge > 0 {
		lenCachedVersions := int64(len(valueHistory.sortedDescVersions))
		for versionIdx := lenCachedVersions - 1; versionIdx >= 0; versionIdx-- {
			cachedVersion := valueHistory.sortedDescVersions[versionIdx]

			// DEV_NOTE: Since the list is sorted, and we're iterating from lowest
			// (oldest) to highest (newest) version, once we encounter a cachedVersion
			// that is newer than the configured maxVersionAge, ALL subsequent
			// heights SHOULD also be newer than the configured maxVersionAge.
			cachedVersionAge := latestVersion - cachedVersion
			if cachedVersionAge <= c.config.maxVersionAge {
				valueHistory.sortedDescVersions = valueHistory.sortedDescVersions[:versionIdx+1]
				break
			}

			delete(valueHistory.versionToValueMap, cachedVersion)
		}
	}

	valueHistory.versionToValueMap[version] = cacheValue[T]{
		value:    value,
		cachedAt: time.Now(),
	}

	c.valueHistories[key] = valueHistory

	// Evict after adding the new key/value.
	if err := c.evictKey(); err != nil {
		return err
	}

	return nil
}

// evictKey removes one key/value pair (and all its versions) from the cache,
// to make space for a new one, according to the configured eviction policy.
func (c *historicalKeyValueCache[T]) evictKey() error {
	isMaxKeysConfigured := c.config.maxKeys > 0
	cacheMaxKeysReached := int64(len(c.valueHistories)) > c.config.maxKeys
	if !isMaxKeysConfigured || !cacheMaxKeysReached {
		return nil
	}

	switch c.config.evictionPolicy {
	case FirstInFirstOut:
		var (
			first      = true
			oldestKey  string
			oldestTime time.Time
		)
		for key, valueHistory := range c.valueHistories {
			latestVersion := valueHistory.sortedDescVersions[0]
			value, exists := valueHistory.versionToValueMap[latestVersion]
			if !exists {
				return cache.ErrCacheInternal.Wrapf(
					"expected value history for key %s to contain version %d but it did not ðŸ’£",
					key, latestVersion,
				)
			}

			if first || value.cachedAt.Before(oldestTime) {
				oldestKey = key
				oldestTime = value.cachedAt
			}
			first = false
		}
		delete(c.valueHistories, oldestKey)
		return nil

	case LeastRecentlyUsed:
		// TODO_IMPROVE: Implement LRU eviction
		// This will require tracking access times
		panic("LRU eviction not implemented")

	case LeastFrequentlyUsed:
		// TODO_IMPROVE: Implement LFU eviction
		// This will require tracking access times
		panic("LFU eviction not implemented")

	default:
		// DEV_NOTE: This SHOULD NEVER happen, KeyValueCacheConfig#Validate, SHOULD prevent it.
		panic(fmt.Sprintf("unsupported eviction policy: %d", c.config.evictionPolicy))
	}
}

// getLatestVersionNumber returns the latest version number (not the value) of the given key.
// It is NOT safe to call concurrently; i.e., the caller MUST hold the valuesMu lock.
func (c *historicalKeyValueCache[T]) getLatestVersionNumber(key string) int64 {
	valueHistory, exists := c.valueHistories[key]
	if !exists {
		return -1
	}

	return valueHistory.sortedDescVersions[0]
}
