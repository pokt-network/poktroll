package memory

import (
	"errors"
	"sort"
	"sync"
	"time"

	"github.com/pokt-network/poktroll/pkg/cache"
)

var _ cache.HistoricalKeyValueCache[any] = (*historicalKeyValueCache[any])(nil)

// historicalKeyValueCache provides a concurrency-safe in-memory cache implementation
// with support for tracking multiple value versions for a given key.
type historicalKeyValueCache[T any] struct {
	config queryCacheConfig

	// valuesMu is used to protect values AND valueHistories from concurrent access.
	valuesMu sync.RWMutex
	// valueHistories holds the cached historical values in historical mode.
	valueHistories map[string]cacheValueHistory[T]
}

// cacheValueHistory stores cachedValues by version number and maintains a sorted
// list of version numbers for which cached values exist. This list is sorted in
// descending order to improve performance characteristics by positively correlating
// index with age.
type cacheValueHistory[T any] struct {
	// sortedDescVersions is a list of the version numbers for which values are
	// cached. It is sorted in descending order.
	sortedDescVersions []int64
	// versionToValueMap is a map from a version number to the cached value at
	// that version number, if present.
	versionToValueMap map[int64]cacheValue[T]
}

// NewHistoricalKeyValueCache creates a new historicalKeyValueCache with the
// configuration generated by the given option functions.
func NewHistoricalKeyValueCache[T any](opts ...QueryCacheOptionFn) (*historicalKeyValueCache[T], error) {
	config := DefaultQueryCacheConfig

	for _, opt := range opts {
		opt(&config)
	}

	if err := config.Validate(); err != nil {
		return nil, err
	}

	return &historicalKeyValueCache[T]{
		valueHistories: make(map[string]cacheValueHistory[T]),
		config:         config,
	}, nil
}

// GetVersion retrieves the value from the cache with the given key, as of the
// given version. If a value is not found for that version, the value at the nearest
// previous version is returned. If the cache is not configured for historical mode,
// it returns an error.
func (c *historicalKeyValueCache[T]) GetVersion(key string, version int64) (T, error) {
	var zero T

	if !c.config.historical {
		return zero, cache.ErrHistoricalModeNotEnabled
	}

	c.valuesMu.RLock()
	defer c.valuesMu.RUnlock()

	valueHistory, exists := c.valueHistories[key]
	if !exists {
		return zero, cache.ErrCacheMiss.Wrapf("key: %s", key)
	}

	var nearestCachedVersion int64 = -1
	for _, cachedVersion := range valueHistory.sortedDescVersions {
		if cachedVersion <= version {
			nearestCachedVersion = cachedVersion
			// DEV_NOTE: Since the list is sorted in descending order, once we
			// encounter a cachedVersion that is less than or equal to version,
			// all subsequent cachedVersions SHOULD also be less than or equal to
			// version.
			break
		}
	}

	if nearestCachedVersion == -1 {
		return zero, cache.ErrCacheMiss.Wrapf("key: %s, version: %d", key, version)
	}

	value, exists := valueHistory.versionToValueMap[nearestCachedVersion]
	if !exists {
		// DEV_NOTE: This SHOULD NEVER happen. If it does, it means that the cache has been corrupted.
		return zero, cache.ErrCacheInternal.Wrapf("failed to load historical value for key: %s, version: %d", key, version)
	}

	isTTLEnabled := c.config.ttl > 0
	isCacheValueExpired := time.Since(value.cachedAt) > c.config.ttl
	if isTTLEnabled && isCacheValueExpired {
		// DEV_NOTE: Intentionally not pruning here to improve concurrent speed;
		// otherwise, the read lock would be insufficient. The value will be pruned
		// in the subsequent call to SetVersion() after c.config.maxVersionAge
		// blocks have elapsed. If usage is such that historical values aren't being
		// subsequently set, numHistoricalBlocks (if configured) will eventually
		// cause the pruning of historical values with expired TTLs.
		return zero, cache.ErrCacheMiss.Wrapf("key: %s, version: %d", key, version)
	}

	return value.value, nil
}

// GetLatestVersion returns the value of the latest version of the given key.
func (c *historicalKeyValueCache[T]) GetLatestVersion(key string) (T, error) {
	var zero T
	if !c.config.historical {
		return zero, cache.ErrHistoricalModeNotEnabled
	}

	version, err := c.getLatestVersionNumber(key)
	if err != nil {
		return zero, err
	}

	return c.GetVersion(key, version)
}

// SetVersion adds or updates the historical value in the cache for the given key,
// and at the version number. If the cache is not configured for historical mode, it
// returns an error.
func (c *historicalKeyValueCache[T]) SetVersion(key string, value T, version int64) error {
	if !c.config.historical {
		return cache.ErrHistoricalModeNotEnabled
	}

	// DEV_NOTE: MUST call getLatestVersionNumber() before locking valuesMu.
	latestVersion, err := c.getLatestVersionNumber(key)
	if err != nil {
		if !errors.Is(err, cache.ErrCacheMiss) {
			return err
		}
	}
	if version > latestVersion {
		latestVersion = version
	}

	c.valuesMu.Lock()
	defer c.valuesMu.Unlock()

	valueHistory, exists := c.valueHistories[key]
	if !exists {
		versionToValueMap := make(map[int64]cacheValue[T])
		valueHistory = cacheValueHistory[T]{
			sortedDescVersions: make([]int64, 0),
			versionToValueMap:  versionToValueMap,
		}
	}

	// Update sortedDescVersions and ensure the list is sorted in descending order.
	if _, versionExists := valueHistory.versionToValueMap[version]; !versionExists {
		valueHistory.sortedDescVersions = append(valueHistory.sortedDescVersions, version)
		sort.Slice(valueHistory.sortedDescVersions, func(i, j int) bool {
			return valueHistory.sortedDescVersions[i] > valueHistory.sortedDescVersions[j]
		})
	}

	// Prune historical values for this key, where the version
	// is older than the configured maxVersionAge.
	if c.config.maxVersionAge > 0 {
		lenCachedVersions := int64(len(valueHistory.sortedDescVersions))
		for versionIdx := lenCachedVersions - 1; versionIdx >= 0; versionIdx-- {
			cachedVersion := valueHistory.sortedDescVersions[versionIdx]

			// DEV_NOTE: Since the list is sorted, and we're iterating from lowest
			// (oldest) to highest (newest) version, once we encounter a cachedVersion
			// that is newer than the configured maxVersionAge, ALL subsequent
			// heights SHOULD also be newer than the configured maxVersionAge.
			cachedVersionAge := latestVersion - cachedVersion
			if cachedVersionAge <= c.config.maxVersionAge {
				valueHistory.sortedDescVersions = valueHistory.sortedDescVersions[:versionIdx+1]
				break
			}

			delete(valueHistory.versionToValueMap, cachedVersion)
		}
	}

	valueHistory.versionToValueMap[version] = cacheValue[T]{
		value:    value,
		cachedAt: time.Now(),
	}

	c.valueHistories[key] = valueHistory

	// Evict after adding the new key/value.
	if err = c.evict(); err != nil {
		return err
	}

	return nil
}

// evict removes one value (and all its versions) from the cache,
// to make space for a new one, according to the configured eviction policy.
func (c *historicalKeyValueCache[T]) evict() error {
	// TODO_IN_THIS_COMMIT: reconcile config(s) with splitting of the cache implementations.
	isMaxKeysConfigured := c.config.maxKeys > 0
	cacheMaxKeysReached := int64(len(c.valueHistories)) > c.config.maxKeys
	if !isMaxKeysConfigured || !cacheMaxKeysReached {
		return nil
	}

	switch c.config.evictionPolicy {
	case FirstInFirstOut:
		var oldestKey string
		var oldestTime time.Time
		for key, valueHistory := range c.valueHistories {
			mostRecentVersion := valueHistory.sortedDescVersions[0]
			value, exists := valueHistory.versionToValueMap[mostRecentVersion]
			if !exists {
				return cache.ErrCacheInternal.Wrapf(
					"expected value history for key %s to contain version %d but it did not ðŸ’£",
					key, mostRecentVersion,
				)
			}

			if value.cachedAt.IsZero() || value.cachedAt.Before(oldestTime) {
				oldestKey = key
				oldestTime = value.cachedAt
			}
		}
		delete(c.valueHistories, oldestKey)
		return nil

	case LeastRecentlyUsed:
		// TODO_IMPROVE: Implement LRU eviction
		// This will require tracking access times
		return cache.ErrCacheInternal.Wrap("LRU eviction not implemented")

	case LeastFrequentlyUsed:
		// TODO_IMPROVE: Implement LFU eviction
		// This will require tracking access times
		return cache.ErrCacheInternal.Wrap("LFU eviction not implemented")

	default:
		// DEV_NOTE: This SHOULD NEVER happen, QueryCacheConfig#Validate, SHOULD prevent it.
		return cache.ErrCacheInternal.Wrapf("unsupported eviction policy: %d", c.config.evictionPolicy)
	}
}

// getLatestVersionNumber returns the latest version number (not the value) of the given key.
func (c *historicalKeyValueCache[T]) getLatestVersionNumber(key string) (int64, error) {
	if !c.config.historical {
		return 0, cache.ErrHistoricalModeNotEnabled
	}

	c.valuesMu.Lock()
	defer c.valuesMu.Unlock()

	valueHistory, exists := c.valueHistories[key]
	if !exists {
		return 0, cache.ErrCacheMiss.Wrapf("key: %s", key)
	}

	return valueHistory.sortedDescVersions[0], nil
}
