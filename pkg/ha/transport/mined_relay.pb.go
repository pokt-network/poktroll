// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pocket/ha/mined_relay.proto

package transport

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MinedRelayMessage is the message format for mined relays transported via Redis Streams
// from the horizontally-scaled Relayer instances to the singleton Miner service.
//
// This message contains all data needed to:
// 1. Deduplicate relays (via relay_hash)
// 2. Route to correct SMST (via session_id, supplier_operator_address)
// 3. Aggregate into session tree (via relay_bytes, compute_units_per_relay)
type MinedRelayMessage struct {
	// relay_hash is the SHA256 hash of the serialized relay.
	// Used for deduplication and as the SMST key.
	RelayHash []byte `protobuf:"bytes,1,opt,name=relay_hash,json=relayHash,proto3" json:"relay_hash,omitempty"`
	// relay_bytes is the serialized relay (RelayRequest + RelayResponse).
	// Stored as-is in the SMST as the value.
	RelayBytes []byte `protobuf:"bytes,2,opt,name=relay_bytes,json=relayBytes,proto3" json:"relay_bytes,omitempty"`
	// compute_units_per_relay is the weight of this relay for tokenomics.
	// Used as the SMST weight parameter.
	ComputeUnitsPerRelay uint64 `protobuf:"varint,3,opt,name=compute_units_per_relay,json=computeUnitsPerRelay,proto3" json:"compute_units_per_relay,omitempty"`
	// session_id identifies which session this relay belongs to.
	// Used to route the relay to the correct SessionTree.
	SessionId string `protobuf:"bytes,4,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	// session_end_height is the block height at which the session ends.
	// Used for session lifecycle management and TTL calculations.
	SessionEndHeight int64 `protobuf:"varint,5,opt,name=session_end_height,json=sessionEndHeight,proto3" json:"session_end_height,omitempty"`
	// supplier_operator_address is the bech32 address of the supplier operator.
	// Used to route the relay to the correct supplier's Redis stream.
	SupplierOperatorAddress string `protobuf:"bytes,6,opt,name=supplier_operator_address,json=supplierOperatorAddress,proto3" json:"supplier_operator_address,omitempty"`
	// service_id is the on-chain service ID this relay was served for.
	// Used for metrics and validation.
	ServiceId string `protobuf:"bytes,7,opt,name=service_id,json=serviceId,proto3" json:"service_id,omitempty"`
	// application_address is the bech32 address of the application that sent the relay.
	// Used for deduplication scoping and metrics.
	ApplicationAddress string `protobuf:"bytes,8,opt,name=application_address,json=applicationAddress,proto3" json:"application_address,omitempty"`
	// arrival_block_height is the block height when the relay arrived at the Relayer.
	// Pinned at receipt time to avoid grace period race conditions.
	ArrivalBlockHeight int64 `protobuf:"varint,9,opt,name=arrival_block_height,json=arrivalBlockHeight,proto3" json:"arrival_block_height,omitempty"`
	// published_at_unix_nano is the Unix timestamp (nanoseconds) when the relay was published.
	// Used for latency metrics and debugging.
	PublishedAtUnixNano int64 `protobuf:"varint,10,opt,name=published_at_unix_nano,json=publishedAtUnixNano,proto3" json:"published_at_unix_nano,omitempty"`
	// session_start_height is the block height at which the session started.
	// Used for session lifecycle management and SessionHeader construction.
	SessionStartHeight int64 `protobuf:"varint,11,opt,name=session_start_height,json=sessionStartHeight,proto3" json:"session_start_height,omitempty"`
}

func (m *MinedRelayMessage) Reset()         { *m = MinedRelayMessage{} }
func (m *MinedRelayMessage) String() string { return proto.CompactTextString(m) }
func (*MinedRelayMessage) ProtoMessage()    {}
func (*MinedRelayMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_f94e9428a47077fe, []int{0}
}
func (m *MinedRelayMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MinedRelayMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MinedRelayMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MinedRelayMessage.Merge(m, src)
}
func (m *MinedRelayMessage) XXX_Size() int {
	return m.Size()
}
func (m *MinedRelayMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_MinedRelayMessage.DiscardUnknown(m)
}

var xxx_messageInfo_MinedRelayMessage proto.InternalMessageInfo

func (m *MinedRelayMessage) GetRelayHash() []byte {
	if m != nil {
		return m.RelayHash
	}
	return nil
}

func (m *MinedRelayMessage) GetRelayBytes() []byte {
	if m != nil {
		return m.RelayBytes
	}
	return nil
}

func (m *MinedRelayMessage) GetComputeUnitsPerRelay() uint64 {
	if m != nil {
		return m.ComputeUnitsPerRelay
	}
	return 0
}

func (m *MinedRelayMessage) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *MinedRelayMessage) GetSessionEndHeight() int64 {
	if m != nil {
		return m.SessionEndHeight
	}
	return 0
}

func (m *MinedRelayMessage) GetSupplierOperatorAddress() string {
	if m != nil {
		return m.SupplierOperatorAddress
	}
	return ""
}

func (m *MinedRelayMessage) GetServiceId() string {
	if m != nil {
		return m.ServiceId
	}
	return ""
}

func (m *MinedRelayMessage) GetApplicationAddress() string {
	if m != nil {
		return m.ApplicationAddress
	}
	return ""
}

func (m *MinedRelayMessage) GetArrivalBlockHeight() int64 {
	if m != nil {
		return m.ArrivalBlockHeight
	}
	return 0
}

func (m *MinedRelayMessage) GetPublishedAtUnixNano() int64 {
	if m != nil {
		return m.PublishedAtUnixNano
	}
	return 0
}

func (m *MinedRelayMessage) GetSessionStartHeight() int64 {
	if m != nil {
		return m.SessionStartHeight
	}
	return 0
}

func init() {
	proto.RegisterType((*MinedRelayMessage)(nil), "pocket.ha.MinedRelayMessage")
}

func init() { proto.RegisterFile("pocket/ha/mined_relay.proto", fileDescriptor_f94e9428a47077fe) }

var fileDescriptor_f94e9428a47077fe = []byte{
	// 442 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x4c, 0x92, 0xb1, 0x6f, 0xd4, 0x30,
	0x14, 0xc6, 0xcf, 0x5c, 0x29, 0x9c, 0xcb, 0x00, 0xee, 0x89, 0x06, 0x10, 0xe1, 0xc4, 0x74, 0x03,
	0x5c, 0x40, 0x15, 0x0b, 0x5b, 0x4f, 0x42, 0x6a, 0x87, 0x52, 0x14, 0xd4, 0x85, 0xc5, 0x72, 0xe2,
	0xa7, 0xd8, 0x4a, 0xce, 0xb6, 0x6c, 0xa7, 0xb4, 0xff, 0x05, 0x7f, 0x16, 0x63, 0xc7, 0x8e, 0xe8,
	0xee, 0xdf, 0x60, 0x40, 0xb6, 0x13, 0xd4, 0x2d, 0xf9, 0x7e, 0xef, 0x7b, 0xdf, 0x27, 0xeb, 0xe1,
	0x57, 0x46, 0xd7, 0x2d, 0xf8, 0x42, 0xb0, 0x62, 0x23, 0x15, 0x70, 0x6a, 0xa1, 0x63, 0x37, 0x2b,
	0x63, 0xb5, 0xd7, 0x64, 0x96, 0xe0, 0x4a, 0xb0, 0x97, 0xf3, 0x46, 0x37, 0x3a, 0xaa, 0x45, 0xf8,
	0x4a, 0x03, 0x6f, 0xff, 0x4e, 0xf1, 0xb3, 0xf3, 0x60, 0x2b, 0x83, 0xeb, 0x1c, 0x9c, 0x63, 0x0d,
	0x90, 0xd7, 0x18, 0xc7, 0x2d, 0x54, 0x30, 0x27, 0x32, 0xb4, 0x40, 0xcb, 0x27, 0xe5, 0x2c, 0x2a,
	0xa7, 0xcc, 0x09, 0xf2, 0x06, 0x1f, 0x24, 0x5c, 0xdd, 0x78, 0x70, 0xd9, 0x83, 0xc8, 0x93, 0x63,
	0x1d, 0x14, 0xf2, 0x09, 0x1f, 0xd5, 0x7a, 0x63, 0x7a, 0x0f, 0xb4, 0x57, 0xd2, 0x3b, 0x6a, 0xc0,
	0xa6, 0x5e, 0xd9, 0x74, 0x81, 0x96, 0x7b, 0xe5, 0x7c, 0xc0, 0x97, 0x81, 0x7e, 0x03, 0x1b, 0xd3,
	0x43, 0xac, 0x03, 0xe7, 0xa4, 0x56, 0x54, 0xf2, 0x6c, 0x6f, 0x81, 0x96, 0xb3, 0x72, 0x36, 0x28,
	0x67, 0x9c, 0xbc, 0xc3, 0x64, 0xc4, 0xa0, 0x38, 0x15, 0x20, 0x1b, 0xe1, 0xb3, 0x87, 0x0b, 0xb4,
	0x9c, 0x96, 0x4f, 0x07, 0xf2, 0x45, 0xf1, 0xd3, 0xa8, 0x93, 0xcf, 0xf8, 0x85, 0xeb, 0x8d, 0xe9,
	0x24, 0x58, 0xaa, 0x0d, 0x58, 0xe6, 0xb5, 0xa5, 0x8c, 0x73, 0x0b, 0xce, 0x65, 0xfb, 0x71, 0xf7,
	0xd1, 0x38, 0x70, 0x31, 0xf0, 0x93, 0x84, 0x53, 0x11, 0x7b, 0x25, 0x6b, 0x08, 0x45, 0x1e, 0x8d,
	0x45, 0xa2, 0x72, 0xc6, 0x49, 0x81, 0x0f, 0x59, 0x30, 0xd6, 0xcc, 0x87, 0x32, 0xe3, 0xd2, 0xc7,
	0x71, 0x8e, 0xdc, 0x43, 0xe3, 0xbe, 0x0f, 0x78, 0xce, 0xac, 0x95, 0x57, 0xac, 0xa3, 0x55, 0xa7,
	0xeb, 0x76, 0xec, 0x3e, 0x8b, 0xdd, 0xc9, 0xc0, 0xd6, 0x01, 0x0d, 0xed, 0x8f, 0xf1, 0x73, 0xd3,
	0x57, 0x9d, 0x74, 0x02, 0x38, 0x65, 0x3e, 0x3c, 0xe3, 0x35, 0x55, 0x4c, 0xe9, 0x0c, 0x47, 0xcf,
	0xe1, 0x7f, 0x7a, 0xe2, 0x2f, 0x95, 0xbc, 0xfe, 0xca, 0x94, 0x0e, 0x31, 0xe3, 0x03, 0x39, 0xcf,
	0xac, 0x1f, 0x63, 0x0e, 0x52, 0xcc, 0xc0, 0xbe, 0x07, 0x94, 0x62, 0xd6, 0x17, 0xbf, 0xb7, 0x39,
	0xba, 0xdd, 0xe6, 0xe8, 0x6e, 0x9b, 0xa3, 0x3f, 0xdb, 0x1c, 0xfd, 0xda, 0xe5, 0x93, 0xdb, 0x5d,
	0x3e, 0xb9, 0xdb, 0xe5, 0x93, 0x1f, 0x1f, 0x1b, 0xe9, 0x45, 0x5f, 0xad, 0x6a, 0xbd, 0x29, 0x8c,
	0x6e, 0xfd, 0x7b, 0x05, 0xfe, 0xa7, 0xb6, 0x6d, 0xfc, 0xb1, 0xba, 0xeb, 0x0a, 0xd3, 0x36, 0xe1,
	0xf0, 0xbc, 0x65, 0xca, 0x19, 0x6d, 0x7d, 0xb5, 0x1f, 0xcf, 0xea, 0xf8, 0x5f, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x4e, 0x1f, 0x6a, 0xba, 0x96, 0x02, 0x00, 0x00,
}

func (m *MinedRelayMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MinedRelayMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MinedRelayMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SessionStartHeight != 0 {
		i = encodeVarintMinedRelay(dAtA, i, uint64(m.SessionStartHeight))
		i--
		dAtA[i] = 0x58
	}
	if m.PublishedAtUnixNano != 0 {
		i = encodeVarintMinedRelay(dAtA, i, uint64(m.PublishedAtUnixNano))
		i--
		dAtA[i] = 0x50
	}
	if m.ArrivalBlockHeight != 0 {
		i = encodeVarintMinedRelay(dAtA, i, uint64(m.ArrivalBlockHeight))
		i--
		dAtA[i] = 0x48
	}
	if len(m.ApplicationAddress) > 0 {
		i -= len(m.ApplicationAddress)
		copy(dAtA[i:], m.ApplicationAddress)
		i = encodeVarintMinedRelay(dAtA, i, uint64(len(m.ApplicationAddress)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ServiceId) > 0 {
		i -= len(m.ServiceId)
		copy(dAtA[i:], m.ServiceId)
		i = encodeVarintMinedRelay(dAtA, i, uint64(len(m.ServiceId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SupplierOperatorAddress) > 0 {
		i -= len(m.SupplierOperatorAddress)
		copy(dAtA[i:], m.SupplierOperatorAddress)
		i = encodeVarintMinedRelay(dAtA, i, uint64(len(m.SupplierOperatorAddress)))
		i--
		dAtA[i] = 0x32
	}
	if m.SessionEndHeight != 0 {
		i = encodeVarintMinedRelay(dAtA, i, uint64(m.SessionEndHeight))
		i--
		dAtA[i] = 0x28
	}
	if len(m.SessionId) > 0 {
		i -= len(m.SessionId)
		copy(dAtA[i:], m.SessionId)
		i = encodeVarintMinedRelay(dAtA, i, uint64(len(m.SessionId)))
		i--
		dAtA[i] = 0x22
	}
	if m.ComputeUnitsPerRelay != 0 {
		i = encodeVarintMinedRelay(dAtA, i, uint64(m.ComputeUnitsPerRelay))
		i--
		dAtA[i] = 0x18
	}
	if len(m.RelayBytes) > 0 {
		i -= len(m.RelayBytes)
		copy(dAtA[i:], m.RelayBytes)
		i = encodeVarintMinedRelay(dAtA, i, uint64(len(m.RelayBytes)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RelayHash) > 0 {
		i -= len(m.RelayHash)
		copy(dAtA[i:], m.RelayHash)
		i = encodeVarintMinedRelay(dAtA, i, uint64(len(m.RelayHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMinedRelay(dAtA []byte, offset int, v uint64) int {
	offset -= sovMinedRelay(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MinedRelayMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RelayHash)
	if l > 0 {
		n += 1 + l + sovMinedRelay(uint64(l))
	}
	l = len(m.RelayBytes)
	if l > 0 {
		n += 1 + l + sovMinedRelay(uint64(l))
	}
	if m.ComputeUnitsPerRelay != 0 {
		n += 1 + sovMinedRelay(uint64(m.ComputeUnitsPerRelay))
	}
	l = len(m.SessionId)
	if l > 0 {
		n += 1 + l + sovMinedRelay(uint64(l))
	}
	if m.SessionEndHeight != 0 {
		n += 1 + sovMinedRelay(uint64(m.SessionEndHeight))
	}
	l = len(m.SupplierOperatorAddress)
	if l > 0 {
		n += 1 + l + sovMinedRelay(uint64(l))
	}
	l = len(m.ServiceId)
	if l > 0 {
		n += 1 + l + sovMinedRelay(uint64(l))
	}
	l = len(m.ApplicationAddress)
	if l > 0 {
		n += 1 + l + sovMinedRelay(uint64(l))
	}
	if m.ArrivalBlockHeight != 0 {
		n += 1 + sovMinedRelay(uint64(m.ArrivalBlockHeight))
	}
	if m.PublishedAtUnixNano != 0 {
		n += 1 + sovMinedRelay(uint64(m.PublishedAtUnixNano))
	}
	if m.SessionStartHeight != 0 {
		n += 1 + sovMinedRelay(uint64(m.SessionStartHeight))
	}
	return n
}

func sovMinedRelay(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMinedRelay(x uint64) (n int) {
	return sovMinedRelay(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MinedRelayMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMinedRelay
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MinedRelayMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MinedRelayMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMinedRelay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMinedRelay
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMinedRelay
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelayHash = append(m.RelayHash[:0], dAtA[iNdEx:postIndex]...)
			if m.RelayHash == nil {
				m.RelayHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMinedRelay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMinedRelay
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMinedRelay
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelayBytes = append(m.RelayBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.RelayBytes == nil {
				m.RelayBytes = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputeUnitsPerRelay", wireType)
			}
			m.ComputeUnitsPerRelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMinedRelay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComputeUnitsPerRelay |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMinedRelay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMinedRelay
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMinedRelay
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionEndHeight", wireType)
			}
			m.SessionEndHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMinedRelay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionEndHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplierOperatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMinedRelay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMinedRelay
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMinedRelay
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupplierOperatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMinedRelay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMinedRelay
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMinedRelay
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMinedRelay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMinedRelay
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMinedRelay
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicationAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArrivalBlockHeight", wireType)
			}
			m.ArrivalBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMinedRelay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArrivalBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishedAtUnixNano", wireType)
			}
			m.PublishedAtUnixNano = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMinedRelay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PublishedAtUnixNano |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionStartHeight", wireType)
			}
			m.SessionStartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMinedRelay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionStartHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMinedRelay(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMinedRelay
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMinedRelay(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMinedRelay
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMinedRelay
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMinedRelay
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMinedRelay
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMinedRelay
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMinedRelay
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMinedRelay        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMinedRelay          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMinedRelay = fmt.Errorf("proto: unexpected end of group")
)
