// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pocket/relayerminer/backup.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	types "github.com/pokt-network/poktroll/x/session/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// RelayDataEntry represents a single relay entry from the SMT
type RelayDataEntry struct {
	// key is the SMT key (typically relay hash)
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// value is the SMT value (typically serialized relay data)
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// weight is the relay weight used in the SMST (typically compute units)
	Weight uint64 `protobuf:"varint,3,opt,name=weight,proto3" json:"weight,omitempty"`
}

func (m *RelayDataEntry) Reset()         { *m = RelayDataEntry{} }
func (m *RelayDataEntry) String() string { return proto.CompactTextString(m) }
func (*RelayDataEntry) ProtoMessage()    {}
func (*RelayDataEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b92638510e6f551, []int{0}
}
func (m *RelayDataEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RelayDataEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RelayDataEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RelayDataEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RelayDataEntry.Merge(m, src)
}
func (m *RelayDataEntry) XXX_Size() int {
	return m.Size()
}
func (m *RelayDataEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_RelayDataEntry.DiscardUnknown(m)
}

var xxx_messageInfo_RelayDataEntry proto.InternalMessageInfo

func (m *RelayDataEntry) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *RelayDataEntry) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *RelayDataEntry) GetWeight() uint64 {
	if m != nil {
		return m.Weight
	}
	return 0
}

// SessionTreeBackupData represents the protobuf message for backing up session trees.
// This structure is optimized for efficient binary serialization and storage.
// Supports both metadata-only backups (legacy) and full SMT data backups (current).
type SessionTreeBackupData struct {
	// session_header contains the session metadata
	SessionHeader types.SessionHeader `protobuf:"bytes,1,opt,name=session_header,json=sessionHeader,proto3" json:"session_header"`
	// supplier_operator_address is the Bech32 address of the supplier operator
	SupplierOperatorAddress string `protobuf:"bytes,2,opt,name=supplier_operator_address,json=supplierOperatorAddress,proto3" json:"supplier_operator_address,omitempty"`
	// claimed_root is the root hash of the SMST needed for submitting the claim
	ClaimedRoot []byte `protobuf:"bytes,3,opt,name=claimed_root,json=claimedRoot,proto3" json:"claimed_root,omitempty"`
	// proof_path is the path for which the proof was generated
	ProofPath []byte `protobuf:"bytes,4,opt,name=proof_path,json=proofPath,proto3" json:"proof_path,omitempty"`
	// compact_proof_bz is the marshaled compact proof for the session
	CompactProofBz []byte `protobuf:"bytes,5,opt,name=compact_proof_bz,json=compactProofBz,proto3" json:"compact_proof_bz,omitempty"`
	// is_claiming indicates if the session tree is currently being processed for claiming
	IsClaiming bool `protobuf:"varint,6,opt,name=is_claiming,json=isClaiming,proto3" json:"is_claiming,omitempty"`
	// backup_timestamp is the Unix timestamp when this backup was created
	BackupTimestamp int64 `protobuf:"varint,7,opt,name=backup_timestamp,json=backupTimestamp,proto3" json:"backup_timestamp,omitempty"`
	// smt_data contains the actual relay data from the SMT key-value store
	// This field is optional for backward compatibility with legacy backups
	SmtData []*RelayDataEntry `protobuf:"bytes,8,rep,name=smt_data,json=smtData,proto3" json:"smt_data,omitempty"`
	// smt_root is the current SMT root at the time of backup
	// This is used to properly reconstruct the SMT during restoration
	SmtRoot []byte `protobuf:"bytes,9,opt,name=smt_root,json=smtRoot,proto3" json:"smt_root,omitempty"`
	// service_compute_units_per_relay is the compute units per relay for this service
	// This is needed to properly restore relay weights during restoration
	ServiceComputeUnitsPerRelay uint64 `protobuf:"varint,10,opt,name=service_compute_units_per_relay,json=serviceComputeUnitsPerRelay,proto3" json:"service_compute_units_per_relay,omitempty"`
}

func (m *SessionTreeBackupData) Reset()         { *m = SessionTreeBackupData{} }
func (m *SessionTreeBackupData) String() string { return proto.CompactTextString(m) }
func (*SessionTreeBackupData) ProtoMessage()    {}
func (*SessionTreeBackupData) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b92638510e6f551, []int{1}
}
func (m *SessionTreeBackupData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionTreeBackupData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionTreeBackupData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionTreeBackupData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionTreeBackupData.Merge(m, src)
}
func (m *SessionTreeBackupData) XXX_Size() int {
	return m.Size()
}
func (m *SessionTreeBackupData) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionTreeBackupData.DiscardUnknown(m)
}

var xxx_messageInfo_SessionTreeBackupData proto.InternalMessageInfo

func (m *SessionTreeBackupData) GetSessionHeader() types.SessionHeader {
	if m != nil {
		return m.SessionHeader
	}
	return types.SessionHeader{}
}

func (m *SessionTreeBackupData) GetSupplierOperatorAddress() string {
	if m != nil {
		return m.SupplierOperatorAddress
	}
	return ""
}

func (m *SessionTreeBackupData) GetClaimedRoot() []byte {
	if m != nil {
		return m.ClaimedRoot
	}
	return nil
}

func (m *SessionTreeBackupData) GetProofPath() []byte {
	if m != nil {
		return m.ProofPath
	}
	return nil
}

func (m *SessionTreeBackupData) GetCompactProofBz() []byte {
	if m != nil {
		return m.CompactProofBz
	}
	return nil
}

func (m *SessionTreeBackupData) GetIsClaiming() bool {
	if m != nil {
		return m.IsClaiming
	}
	return false
}

func (m *SessionTreeBackupData) GetBackupTimestamp() int64 {
	if m != nil {
		return m.BackupTimestamp
	}
	return 0
}

func (m *SessionTreeBackupData) GetSmtData() []*RelayDataEntry {
	if m != nil {
		return m.SmtData
	}
	return nil
}

func (m *SessionTreeBackupData) GetSmtRoot() []byte {
	if m != nil {
		return m.SmtRoot
	}
	return nil
}

func (m *SessionTreeBackupData) GetServiceComputeUnitsPerRelay() uint64 {
	if m != nil {
		return m.ServiceComputeUnitsPerRelay
	}
	return 0
}

func init() {
	proto.RegisterType((*RelayDataEntry)(nil), "pocket.relayerminer.RelayDataEntry")
	proto.RegisterType((*SessionTreeBackupData)(nil), "pocket.relayerminer.SessionTreeBackupData")
}

func init() { proto.RegisterFile("pocket/relayerminer/backup.proto", fileDescriptor_9b92638510e6f551) }

var fileDescriptor_9b92638510e6f551 = []byte{
	// 530 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x53, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0x8e, 0x49, 0xff, 0xb2, 0x29, 0xa5, 0x2c, 0x05, 0xdc, 0xa0, 0x3a, 0xa6, 0x5c, 0x0c, 0x12,
	0xb6, 0x14, 0x6e, 0x1c, 0x90, 0x48, 0x8b, 0xc4, 0x01, 0xa9, 0x91, 0x29, 0x17, 0x2e, 0xab, 0x8d,
	0x33, 0x38, 0x2b, 0xff, 0xec, 0x6a, 0x77, 0xdd, 0x2a, 0x7d, 0x0a, 0x1e, 0x83, 0x23, 0x8f, 0xd1,
	0x63, 0x8f, 0x9c, 0x10, 0x4a, 0x0e, 0x3c, 0x05, 0x12, 0xf2, 0xee, 0x46, 0x2a, 0x12, 0x17, 0x6b,
	0xe6, 0xfb, 0xbe, 0x9d, 0x99, 0x4f, 0x33, 0x46, 0xa1, 0xe0, 0x59, 0x01, 0x3a, 0x91, 0x50, 0xd2,
	0x05, 0xc8, 0x8a, 0xd5, 0x20, 0x93, 0x29, 0xcd, 0x8a, 0x46, 0xc4, 0x42, 0x72, 0xcd, 0xf1, 0x03,
	0xab, 0x88, 0x6f, 0x2b, 0x06, 0xf7, 0x69, 0xc5, 0x6a, 0x9e, 0x98, 0xaf, 0xd5, 0x0d, 0x0e, 0x72,
	0x9e, 0x73, 0x13, 0x26, 0x6d, 0xe4, 0xd0, 0x81, 0xab, 0xaf, 0x40, 0x29, 0xc6, 0xeb, 0x44, 0x2f,
	0x04, 0x28, 0xcb, 0x1d, 0x4f, 0xd0, 0x5e, 0xda, 0x16, 0x3d, 0xa5, 0x9a, 0xbe, 0xab, 0xb5, 0x5c,
	0xe0, 0x7d, 0xd4, 0x2d, 0x60, 0xe1, 0x7b, 0xa1, 0x17, 0xed, 0xa6, 0x6d, 0x88, 0x0f, 0xd0, 0xe6,
	0x05, 0x2d, 0x1b, 0xf0, 0xef, 0x18, 0xcc, 0x26, 0xf8, 0x11, 0xda, 0xba, 0x04, 0x96, 0xcf, 0xb5,
	0xdf, 0x0d, 0xbd, 0x68, 0x23, 0x75, 0xd9, 0xf1, 0x9f, 0x2e, 0x7a, 0xf8, 0xd1, 0x76, 0x3a, 0x97,
	0x00, 0x63, 0xe3, 0xa3, 0x2d, 0x8f, 0xcf, 0xd0, 0x9e, 0x1b, 0x81, 0xcc, 0x81, 0xce, 0x40, 0x9a,
	0x26, 0xfd, 0xd1, 0x51, 0xec, 0xec, 0x39, 0x36, 0x76, 0xcf, 0xdf, 0x1b, 0xd1, 0xb8, 0x77, 0xfd,
	0x73, 0xd8, 0xf9, 0xf6, 0xfb, 0xfb, 0x0b, 0x2f, 0xbd, 0xab, 0x6e, 0x33, 0xf8, 0x35, 0x3a, 0x54,
	0x8d, 0x10, 0x25, 0x03, 0x49, 0xb8, 0x00, 0x49, 0x35, 0x97, 0x84, 0xce, 0x66, 0x12, 0x94, 0x32,
	0xc3, 0xf6, 0xd2, 0xc7, 0x6b, 0xc1, 0x99, 0xe3, 0xdf, 0x5a, 0x1a, 0x3f, 0x45, 0xbb, 0x59, 0x49,
	0x59, 0x05, 0x33, 0x22, 0x39, 0xb7, 0x26, 0x76, 0xd3, 0xbe, 0xc3, 0x52, 0xce, 0x35, 0x3e, 0x42,
	0x48, 0x48, 0xce, 0xbf, 0x10, 0x41, 0xf5, 0xdc, 0xdf, 0x30, 0x82, 0x9e, 0x41, 0x26, 0x54, 0xcf,
	0x71, 0x84, 0xf6, 0x33, 0x5e, 0x09, 0x9a, 0x69, 0x62, 0x65, 0xd3, 0x2b, 0x7f, 0xd3, 0x88, 0xf6,
	0x1c, 0x3e, 0x69, 0xe1, 0xf1, 0x15, 0x1e, 0xa2, 0x3e, 0x53, 0xc4, 0x94, 0x66, 0x75, 0xee, 0x6f,
	0x85, 0x5e, 0xb4, 0x93, 0x22, 0xa6, 0x4e, 0x1c, 0x82, 0x9f, 0xa3, 0x7d, 0xbb, 0x6f, 0xa2, 0x59,
	0x05, 0x4a, 0xd3, 0x4a, 0xf8, 0xdb, 0xa1, 0x17, 0x75, 0xd3, 0x7b, 0x16, 0x3f, 0x5f, 0xc3, 0xf8,
	0x0d, 0xda, 0x51, 0x95, 0x26, 0x33, 0xaa, 0xa9, 0xbf, 0x13, 0x76, 0xa3, 0xfe, 0xe8, 0x59, 0xfc,
	0x9f, 0xeb, 0x88, 0xff, 0xdd, 0x6a, 0xba, 0xad, 0x2a, 0x6d, 0x96, 0x70, 0x68, 0xdf, 0x1b, 0xcf,
	0x3d, 0x33, 0x6d, 0x4b, 0x19, 0xbf, 0xa7, 0x68, 0xa8, 0x40, 0x5e, 0xb0, 0x0c, 0x48, 0x6b, 0xa0,
	0xd1, 0x40, 0x9a, 0x9a, 0x69, 0x45, 0x04, 0x48, 0x62, 0x8a, 0xfb, 0xc8, 0xac, 0xfa, 0x89, 0x93,
	0x9d, 0x58, 0xd5, 0xa7, 0x56, 0x34, 0x01, 0x69, 0x5a, 0x8e, 0x3f, 0x5c, 0x2f, 0x03, 0xef, 0x66,
	0x19, 0x78, 0xbf, 0x96, 0x81, 0xf7, 0x75, 0x15, 0x74, 0x6e, 0x56, 0x41, 0xe7, 0xc7, 0x2a, 0xe8,
	0x7c, 0x1e, 0xe5, 0x4c, 0xcf, 0x9b, 0x69, 0x9c, 0xf1, 0x2a, 0x11, 0xbc, 0xd0, 0x2f, 0x6b, 0xd0,
	0x97, 0x5c, 0x16, 0x26, 0x91, 0xbc, 0x2c, 0x13, 0x51, 0xe4, 0xeb, 0xbf, 0xc0, 0x5e, 0xe9, 0x74,
	0xcb, 0x9c, 0xe9, 0xab, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xaf, 0xe9, 0xb3, 0x64, 0x24, 0x03,
	0x00, 0x00,
}

func (m *RelayDataEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RelayDataEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RelayDataEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Weight != 0 {
		i = encodeVarintBackup(dAtA, i, uint64(m.Weight))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintBackup(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintBackup(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SessionTreeBackupData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionTreeBackupData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionTreeBackupData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ServiceComputeUnitsPerRelay != 0 {
		i = encodeVarintBackup(dAtA, i, uint64(m.ServiceComputeUnitsPerRelay))
		i--
		dAtA[i] = 0x50
	}
	if len(m.SmtRoot) > 0 {
		i -= len(m.SmtRoot)
		copy(dAtA[i:], m.SmtRoot)
		i = encodeVarintBackup(dAtA, i, uint64(len(m.SmtRoot)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.SmtData) > 0 {
		for iNdEx := len(m.SmtData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SmtData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBackup(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.BackupTimestamp != 0 {
		i = encodeVarintBackup(dAtA, i, uint64(m.BackupTimestamp))
		i--
		dAtA[i] = 0x38
	}
	if m.IsClaiming {
		i--
		if m.IsClaiming {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.CompactProofBz) > 0 {
		i -= len(m.CompactProofBz)
		copy(dAtA[i:], m.CompactProofBz)
		i = encodeVarintBackup(dAtA, i, uint64(len(m.CompactProofBz)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ProofPath) > 0 {
		i -= len(m.ProofPath)
		copy(dAtA[i:], m.ProofPath)
		i = encodeVarintBackup(dAtA, i, uint64(len(m.ProofPath)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ClaimedRoot) > 0 {
		i -= len(m.ClaimedRoot)
		copy(dAtA[i:], m.ClaimedRoot)
		i = encodeVarintBackup(dAtA, i, uint64(len(m.ClaimedRoot)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SupplierOperatorAddress) > 0 {
		i -= len(m.SupplierOperatorAddress)
		copy(dAtA[i:], m.SupplierOperatorAddress)
		i = encodeVarintBackup(dAtA, i, uint64(len(m.SupplierOperatorAddress)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.SessionHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintBackup(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintBackup(dAtA []byte, offset int, v uint64) int {
	offset -= sovBackup(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RelayDataEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	if m.Weight != 0 {
		n += 1 + sovBackup(uint64(m.Weight))
	}
	return n
}

func (m *SessionTreeBackupData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SessionHeader.Size()
	n += 1 + l + sovBackup(uint64(l))
	l = len(m.SupplierOperatorAddress)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	l = len(m.ClaimedRoot)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	l = len(m.ProofPath)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	l = len(m.CompactProofBz)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	if m.IsClaiming {
		n += 2
	}
	if m.BackupTimestamp != 0 {
		n += 1 + sovBackup(uint64(m.BackupTimestamp))
	}
	if len(m.SmtData) > 0 {
		for _, e := range m.SmtData {
			l = e.Size()
			n += 1 + l + sovBackup(uint64(l))
		}
	}
	l = len(m.SmtRoot)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	if m.ServiceComputeUnitsPerRelay != 0 {
		n += 1 + sovBackup(uint64(m.ServiceComputeUnitsPerRelay))
	}
	return n
}

func sovBackup(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBackup(x uint64) (n int) {
	return sovBackup(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RelayDataEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBackup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelayDataEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelayDataEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBackup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionTreeBackupData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBackup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionTreeBackupData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionTreeBackupData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SessionHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplierOperatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupplierOperatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimedRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClaimedRoot = append(m.ClaimedRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.ClaimedRoot == nil {
				m.ClaimedRoot = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofPath", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofPath = append(m.ProofPath[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofPath == nil {
				m.ProofPath = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactProofBz", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompactProofBz = append(m.CompactProofBz[:0], dAtA[iNdEx:postIndex]...)
			if m.CompactProofBz == nil {
				m.CompactProofBz = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsClaiming", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsClaiming = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupTimestamp", wireType)
			}
			m.BackupTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackupTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmtData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SmtData = append(m.SmtData, &RelayDataEntry{})
			if err := m.SmtData[len(m.SmtData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmtRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SmtRoot = append(m.SmtRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.SmtRoot == nil {
				m.SmtRoot = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceComputeUnitsPerRelay", wireType)
			}
			m.ServiceComputeUnitsPerRelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServiceComputeUnitsPerRelay |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBackup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBackup(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBackup
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBackup
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBackup
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBackup
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBackup        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBackup          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBackup = fmt.Errorf("proto: unexpected end of group")
)
