syntax = "proto3";
package poktroll.tokenomics;

option go_package = "github.com/pokt-network/poktroll/x/tokenomics/types";
option (gogoproto.stable_marshaler_all) = true;

import "cosmos/base/v1beta1/coin.proto";
import "gogoproto/gogo.proto";
import "poktroll/proof/types.proto";

enum ClaimExpirationReason {
  EXPIRATION_REASON_UNSPECIFIED = 0; // Default value, means may be valid
  PROOF_MISSING = 1;
  PROOF_INVALID = 2;
}

// EventClaimExpired is an event emitted during settlement whenever a claim requiring
// an on-chain proof doesn't have one. The claim cannot be settled, leading to that work
// never being rewarded.
message EventClaimExpired {
    poktroll.proof.Claim claim = 1 [(gogoproto.jsontag) = "claim"];
    // The reason why the claim expired, leading to a Supplier being penalized (i.e. burn).
    ClaimExpirationReason expiration_reason = 2 [(gogoproto.jsontag) = "expiration_reason"];
    //Number of relays claimed to be in the session tree.
    uint64 num_relays = 3 [(gogoproto.jsontag) = "num_relays"];
    // Number of compute units claimed as a function of the number of relays
    // and the compute units per relay for the particular service.
    // TODO_IN_THIS_PR: Should we call this "num_claimed_compute_units"?
    uint64 num_compute_units = 4 [(gogoproto.jsontag) = "num_compute_units"];
    // Number of estimated compute units serviced off chain taking into account
    // the claimed compute units and the service relay mining difficulty.
    // TODO_IN_THIS_PR: Should we call this "num_actual_compute_units"?
    uint64 num_estimated_compute_units = 5 [(gogoproto.jsontag) = "num_estimated_compute_units"];
}

// EventClaimSettled is an event emitted whenever a claim is settled.
// The proof_required determines whether the claim requires a proof that has been submitted or not
message EventClaimSettled {
    poktroll.proof.Claim claim = 1 [(gogoproto.jsontag) = "claim"];
    // The reason why the claim was settled, leading to a Supplier being rewarded (i.e. mint).
    poktroll.proof.ProofRequirementReason proof_requirement = 2 [(gogoproto.jsontag) = "proof_requirement"];
    // Number of relays claimed to be in the session tree.
    uint64 num_relays = 3 [(gogoproto.jsontag) = "num_relays"];
    // Number of compute units claimed as a function of the number of relays
    // and the compute units per relay for the particular service.
    uint64 num_compute_units = 4 [(gogoproto.jsontag) = "num_compute_units"];
    // Number of estimated compute units serviced off chain taking into account
    // the claimed compute units and the service relay mining difficulty.
    uint64 num_estimated_compute_units = 5 [(gogoproto.jsontag) = "num_estimated_compute_units"];
}

// EventRelayMiningDifficultyUpdated is an event emitted whenever the relay mining difficulty is updated
// for a given service.
message EventRelayMiningDifficultyUpdated {
    string service_id = 1;
    string prev_target_hash_hex_encoded = 2;
    string new_target_hash_hex_encoded = 3;
    uint64 prev_num_relays_ema = 4;
    uint64 new_num_relays_ema = 5;
}

// EventApplicationOverserviced is emitted when an application has less stake than
// what a supplier is claiming (i.e. amount available for burning is insufficient).
// This means the following will ALWAYS be strictly true: effective_burn < expected_burn.
message EventApplicationOverserviced {
    string application_addr = 1;
    string supplier_operator_addr = 2;
    // Expected burn is the amount the supplier is claiming for work done
    // to service the application during the session.
    // This is usually the amount in the Claim submitted.
    cosmos.base.v1beta1.Coin expected_burn  = 3;
    // Effective burn is the amount that is actually being paid to the supplier
    // for the work done. It is less than the expected burn (claim amount) and
    // is a function of the relay mining algorithm.
    // E.g. The application's stake divided by the number of suppliers in a session.
    cosmos.base.v1beta1.Coin effective_burn  = 4;
}