syntax = "proto3";
package pocket.tokenomics;

option go_package = "github.com/pokt-network/poktroll/x/tokenomics/types";
option (gogoproto.stable_marshaler_all) = true;

import "gogoproto/gogo.proto";
import "pocket/proof/types.proto";

import "pocket/tokenomics/types.proto";

// TODO_CONSIDERATION: Consider prefixing these enums with CLAIM_EXPIRATION_REASON_
enum ClaimExpirationReason {
    // Default value, means may be valid
    EXPIRATION_REASON_UNSPECIFIED = 0;

    // A proof was required but not submitted
    PROOF_MISSING = 1;

    // A proof was submitted but was invalid
    PROOF_INVALID = 2;
}

// EventClaimExpired is emitted during settlement when a claim expires.
// This is likely the result of a claim requiring an onchain proof not being submitted.
// The claim cannot be settled, leading to that work never being rewarded.
message EventClaimExpired {
    // Next index: 8

    // cosmos.base.v1beta1.Coin claimed_upokt = 6 [(gogoproto.jsontag) = "claimed_upokt"];
    reserved 6;

    // The claim that expired
    pocket.proof.Claim claim = 1 [(gogoproto.jsontag) = "claim"];

    // The reason why the claim expired, leading to a Supplier being penalized (i.e. burn).
    ClaimExpirationReason expiration_reason = 2 [(gogoproto.jsontag) = "expiration_reason"];

    // Number of relays claimed to be in the session tree.
    uint64 num_relays = 3 [(gogoproto.jsontag) = "num_relays"];

    // Number of compute units claimed in the session tree.
    // It is a function of the number of relays in the session tree and onchain parameters.
    uint64 num_claimed_compute_units = 4 [(gogoproto.jsontag) = "num_claimed_compute_units"];

    // Number of total estimated compute units of work done.
    // It is a function of the number of claimed compute units and the relay difficulty multiplier.
    uint64 num_estimated_compute_units = 5 [(gogoproto.jsontag) = "num_estimated_compute_units"];

    // The amount of uPOKT claimed for the work done.
    // It is a function of the number of estimated compute units and the compute units to token multiplier.
    string claimed_upokt = 7 [(gogoproto.jsontag) = "claimed_upokt"];
}

// EventClaimSettled is emitted during settlement whenever a claim is successfully settled.
// It may or may not require a proof depending on various on-chain parameters and other factors.
message EventClaimSettled {
    // Next index: 9

    // cosmos.base.v1beta1.Coin claimed_upokt = 6 [(gogoproto.jsontag) = "claimed_upokt"];
    // ClaimSettlementResult settlement_result = 7 [(gogoproto.nullable) = false, (gogoproto.jsontag) = "settlement_result"];
    reserved 6, 7;

    // The claim that was settled.
    pocket.proof.Claim claim = 1 [(gogoproto.jsontag) = "claim"];

    // Whether a proof was required for the claim to be settled.
    pocket.proof.ProofRequirementReason proof_requirement = 2 [(gogoproto.jsontag) = "proof_requirement"];

    // Number of relays claimed to be in the session tree.
    uint64 num_relays = 3 [(gogoproto.jsontag) = "num_relays"];

    // Number of compute units claimed in the session tree.
    // It is a function of the number of relays in the session tree and onchain parameters.
    uint64 num_claimed_compute_units = 4 [(gogoproto.jsontag) = "num_claimed_compute_units"];

    // Number of estimated compute units claimed in the session tree.
    // It is a function of the number of claimed compute units and the relay difficulty multiplier for the particular service.
    uint64 num_estimated_compute_units = 5 [(gogoproto.jsontag) = "num_estimated_compute_units"];

    // The uPOKT coin claimed to be rewarded for the work done as a function of
    // the number of estimated compute units and the compute units to token multiplier.
    string claimed_upokt = 8 [(gogoproto.jsontag) = "claimed_upokt"];
}

// EventApplicationOverserviced is emitted when an Application's stake cannot cover the Supplier's claim.
// This means the following will ALWAYS be strictly true:  effective_burn < expected_burn
// - Number of tokens burnt from app stake < Number of tokens burnt from supplier stake
message EventApplicationOverserviced {
    // Next index: 7

    // cosmos.base.v1beta1.Coin expected_burn = 3;
    // cosmos.base.v1beta1.Coin effective_burn = 4;
    reserved 3, 4;

    // The application address consuming onchain services
    string application_addr = 1;

    // The supplier operator address providing onchain services
    string supplier_operator_addr = 2;

    // Expected number of tokens to be burnt from the application's stake.
    // A function of the actual amount of work claimed to be done.
    string expected_burn  = 5;

    // Actual number of tokens burnt from the application's stake.
    // A function of the amount that could be covered (less than) relative to the amount of work claimed to be done.
    string effective_burn  = 6;
}

// EventSupplierSlashed is emitted when a supplier is slashed.enum
// This can happen for in cases such as missing or invalid proofs for submitted claims.
message EventSupplierSlashed {
    // Next index: 4

    // cosmos.base.v1beta1.Coin proof_missing_penalty = 2;
    reserved 2;

    // The claim the supplier is being slashed for.
    pocket.proof.Claim claim = 1;

    // Amount slashed from the supplier's stake.
    // A function of the claim size, supplier stake, and various onchain parameters.
    string proof_missing_penalty = 3;
}

// EventClaimDiscarded is emitted when a claim is discarded due to unexpected situations.
// It is used to prevent chain halts in favor of some missing claims.
message EventClaimDiscarded {
    // The claim that was discarded.
    pocket.proof.Claim claim = 1;

    // The error that caused the claim to be discarded.
    string error = 2;
}

// EventApplicationReimbursementRequest is emitted when an application requests a reimbursement from the DAO.
// It is intended to prevent self dealing attacks when global inflation is enabled.
// TODO_DISTANT_FUTURE: Remove this once global inflation is disabled in perpetuity.
message EventApplicationReimbursementRequest {
    // Next index: 8

    // cosmos.base.v1beta1.Coin amount = 6;
    reserved 6;

    // The application address consuming onchain services requesting reimbursement.
    string application_addr = 1;

    // The supplier operator address providing onchain services
    string supplier_operator_addr = 2;

    // The supplier owner address providing onchain services
    string supplier_owner_addr = 3;

    // The service ID associated with the session where a claim was submitted.
    string service_id = 4;

    // The session ID associated with the session where a claim was submitted.
    string session_id = 5;

    // The amount of uPOKT to be reimbursed to the application.
    string amount = 7;
}